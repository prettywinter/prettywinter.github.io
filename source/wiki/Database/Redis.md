---
wiki: Database
layout: wiki
title: Redis
order: 6
---

Redis 是一个 Key-Value 结构的开源（BSD）的非关系型数据库。

<!-- more -->

<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=6 orderedList=true} -->

<!-- code_chunk_output -->

- [一、了解Redis](#一了解redis)
  - [两种数据持久化方式](#两种数据持久化方式)
    - [1. RDB（数据快照）](#1-rdb数据快照)
    - [2. AOF（操作记录）](#2-aof操作记录)
  - [内存淘汰策略](#内存淘汰策略)
- [二、Redis的几种模式](#二redis的几种模式)
  - [伪集群搭建配置文件示例](#伪集群搭建配置文件示例)
- [三、缓存设计典型问题](#三缓存设计典型问题)
  - [1. 缓存穿透](#1-缓存穿透)
    - [布隆过滤器](#布隆过滤器)
  - [2. 缓存击穿（失效）](#2-缓存击穿失效)
  - [3. 缓存雪崩](#3-缓存雪崩)
  - [热点缓存key重建优化](#热点缓存key重建优化)
- [四、规范建议](#四规范建议)
  - [1. key名设计](#1-key名设计)
  - [2. value设计](#2-value设计)

<!-- /code_chunk_output -->

## 一、了解Redis

Redis 是一个开源（BSD 许可）的内存数据结构存储，用作数据库、缓存、消息代理和流引擎。Redis 提供数据结构，例如字符串、散列、列表、集合、排序集合、带范围查询的位图、超日志、地理空间索引和流。Redis 内置复制、Lua 脚本、LRU 驱逐、事务和不同级别的磁盘持久性，并通过Redis Sentinel提供高可用，Redis Cluster 提供自动分区。

您可以原子操作对这些类型附加到字符串；增加哈希值；将元素推入列表；计算集交并、差；或获取排序集中排名最高的成员。

为了达到最佳性能，Redis 使用内存中的数据集。根据您的用例，Redis 可以通过定期将数据集转储到磁盘或将每个命令附加到基于磁盘的日志。如果您只需要一个功能丰富的网络内存缓存，您也可以禁用持久性。

Redis 支持异步复制，具有快速非阻塞同步和自动重新连接以及网络拆分上的部分重新同步。

应用场景举例：缓存系统（“热点”数据：高频读、低频写）、计数器、消息队列系统、排行榜、社交网络和实时系统。

### [两种数据持久化方式](https://www.jianshu.com/p/1d9ab6bc0835)

#### 1. RDB（数据快照）

优点：RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于进行备份：并且 Redis 加载 RDB 恢复数据远远快于 AOF 的方式。你可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。
缺点：由于每次生成 RDB 开销较大，非实时持久化，可能会出现数据丢失（类似于定时任务）。

> 体积更小；恢复更快；性能更高

#### 2. AOF（操作记录）

优点：数据保证
开启后，Redis每执行一个修改数据的命令，都会把这个命令追加到 AOF 文件中。
AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。
Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。

缺点：对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积（和 RDB 相反）。

根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。

> 如果开启了 AOF，在服务重启恢复数据时会以 AOF 为准恢复数据；
> 如果同时开启了 AOF 和 RDB持久化，在服务重启恢复数据时会以 AOF 为准恢复数据；
> 如果只开启了 RDB，在服务重启恢复数据时会以 dump 的方式恢复数据；

### 内存淘汰策略

内存淘汰策略：Redis 的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。

## 二、Redis的几种模式

1. 主从模式
   redis 主从复制，从节点默认是只读的，当 master 服务挂掉之后，从节点不能代替主节点；主从复制架构只是一个数据的备份。
2. 哨兵模式(建立在主从模式上)
   哨兵的作用，就是监控主、从数据库的状态，当主数据库宕机以后，哨兵会在一定的时间内去判断，然后在从数据库中选举出一个去顶替主数据库，从而实现redis数据的高可用。
3. 集群模式

Redis 的集群模式使用了 CRC16 算法，该算法有以下特点:

1. 对集群模式下的所有key进行 CRC16 计算，计算的结果始终在 0-16383 之间（Redis 有 16384 的 slot）
2. 对客户端的key进行CRC16算法计算时，同一个key经过多次计算，计算结果始终一致。
3. 对客户端的不同的key进行CRC16计算，会出现不同的key计算结果一致。

### 伪集群搭建配置文件示例

搭建 redis 伪集群实现 session 共享：
修改不同端口的配置文件：

```bash
# 启动端口号
port 7000
# 允许远程连接
bind 0.0.0.0
# rdb 方式持久化数据的文件名
dbfilename dump-7000.rdb
# 开启守护进程(即后台运行)
daemonize yes
# 开启 aof 缓存并指定 aof 方式持久化数据的文件名
appendonly yes
appendonlyfilename "appendonly-7000.aof"
# 开启集群配置
cluster-enabled yes
# 配置集群节点名称
cluster-config-file nodes-7000.conf
# 集群超时时间 5s
cluster-node-timeout 5000
```

配置主从数据库后使用 redis-cli 进行连接后，使用 `info replication` 命令查看当前数据库的 role，“master” 是主节点，“slave” 是从节点。默认从库是只读的，不能进行写操作。

## 三、缓存设计典型问题

### 1. 缓存穿透

缓存穿透是指查询一个根本不存在的数据，缓存层和存储层都不会命中，通常出于容错的考虑，如果从存储层查不到数据则不写入缓存层。缓存穿透将导致不存在的数据每次请求都要到存储层去查询，失去了缓存保护后端存储的意义。
造成缓存穿透的基本原因有两个：第一，自身业务代码或者数据出现问题。第二，一些恶意攻击、爬虫等造成大量空命中。

解决方案：
1. 缓存空对象；
2. 布隆过滤器
对于恶意攻击，向服务器请求大量不存在的数据造成的缓存穿透，还可以用布隆过滤器先做一次过滤，对于不存在的数据，布隆过滤器一般都能够过滤掉，不让请求再往后端发送。当布隆过滤器说某个值存在时，这个值可 能不存在；当它说不存在时，那就肯定不存在。

#### 布隆过滤器

布隆过滤器就是一个大型的位数组和几个不一样的无偏 hash 函数。所谓无偏就是能够把元素的 hash 值算得比较均匀。 向布隆过滤器中添加 key 时，会使用多个 hash 函数对 key 进行 hash，算得一个整数索引值然后对位数组长度进行取模运算得到一个位置，每个 hash 函数都会算得一个不同的位置。再把位数组的这几个位置都置为 1 就完成了 add 操作。
向布隆过滤器询问 key 是否存在时，跟 add 一样，也会把 hash 的几个位置都算出来，看看位数组中这几个位置是否都为 1，只要有一个位为 0，那么说明布隆过滤器中这个 key 不存在。如果都是 1，这并不能说明这 个 key 就一定存在，只是极有可能存在，因为这些位被置为 1 可能是因为其它的 key 存在所致。如果这个位数组比较稀疏，这个概率就会很大，如果这个位数组比较拥挤，这个概率就会降低。
这种方法适用于数据命中不高、数据相对固定、实时性低（通常是数据集较大）的应用场景，代码维护较为 **复杂**，但是缓存空间占用很少。

### 2. 缓存击穿（失效）

由于大批量缓存在同一时间失效可能导致大量请求同时穿透缓存直达数据库，可能会造成数据库瞬间压力过大甚至挂掉，对于这种情况我们在批量增加缓存时最好将这一批数据的缓存过期时间设置为一个时间段内的不同时间。

### 3. 缓存雪崩

由于缓存层承载着大量请求，能够有效地保护存储层，但是如果缓存层由于某些原因不能提供服务(比如超大并 发过来，缓存层支撑不住，或者由于缓存设计不好，类似大量请求访问bigkey，导致缓存能支撑的并发急剧下降)，于是大量请求都会打到存储层，存储层的调用量会暴增，造成存储层也会级联宕机的情况。
预防和解决缓存雪崩问题，可以从以下三个方面进行着手。
1） 保证缓存层服务高可用性，比如使用 Redis Sentinel 或 Redis Cluster。
2） 依赖隔离组件为后端限流熔断并降级。比如使用 Sentinel 或 Hystrix 限流降级组件。比如服务降级，我们可以针对不同的数据采取不同的处理方式。当业务应用访问的是非核心数据（例如电商商 品属性，用户信息等）时，暂时停止从缓存中查询这些数据，而是直接返回预定义的默认降级信息、空值或是错误提示信息；当业务应用访问的是核心数据（例如电商商品库存）时，仍然允许查询缓存，如果缓存缺失，也可以继续通过数据库读取。
3） 提前演练。在项目上线前，演练缓存层宕掉后，应用以及后端的负载情况以及可能出现的问题，在此基础上做一些预案设定。

### 热点缓存key重建优化

开发人员使用“缓存+过期时间”的策略既可以加速数据读写，又保证数据的定期更新，这种模式基本能够满足绝大部分需求。 但是有两个问题如果同时出现，可能就会对应用造成致命的危害：当前key是一个热点key（例如一个热门的娱乐新闻），并发量非常大。重建缓存不能在短时间完成，可能是一个复杂计算，例如复杂的SQL、多次IO、多个依赖等。在缓存失效的瞬间， 有大量线程来重建缓存，造成后端负载加大，甚至可能会让应用崩溃。
要解决这个问题主要就是要避免大量线程同时重建缓存。我们可以利用互斥锁来解决，此方法只允许一个线程重建缓存，其他线程等待重建缓存的线程执行完，重新从缓存获取数据即可。

```java 伪代码
String get(String key) { 
  // 从Redis中获取数据
  String value = redis.get(key);
  // 如果value为空，则开始重构缓存
  if (value == null) { 
    String mutexKey = "mutext:key:" + key;
    // 只允许一个线程重建缓存，使用nx，并设置过期时间ex
    if (redis.set(mutexKey, "1", "ex 180", "nx")) {
      // 从数据源获取数据
      value = db.get(key);
      // 回写Redis，并设置过期时间
      redis.setex(key, timeout, value);
      // 删除key_mutex
      redis.delete(mutexKey); 
    } else {
      // 其他线程休息50毫秒后重试
      Thread.sleep(50);
      get(key);
      }
  }
  return value; 
}
```

## 四、规范建议

### 1. key名设计

1. 可读性和可管理性：以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如 {% kbd 业务名:表名:id %}。 
2. 简洁性：保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视。
3. 不要包含特殊字符。

### 2. value设计

1. 拒绝bigkey(防止网卡流量、慢查询) 在Redis中，一个字符串最大512MB，一个二级数据结构（例如hash、list、set、zset）可以存 储大约40亿个(2^32-1)个元素，但实际中如果下面两种情况，我就会认为它是bigkey。
    1. 字符串类型：它的big体现在单个value值很大，一般认为超过10KB就是bigkey。
    2. 非字符串类型：哈希、列表、集合、有序集合，它们的big体现在元素个数太多。一般来说，string类型控制在10KB以内，hash、list、set、zset元素个数不要超过5000。反例：一个包含200万个元素的list。非字符串的bigkey，不要使用del删除，使用hscan、sscan、zscan方式渐进式删除，同时要注意防止bigkey过期时间自动删除问题(例如一个200万的zset设置1小时过期，会触发del操作，造成阻塞）。

bigkey的危害：
1. 导致redis阻塞
2. 网络拥塞
bigkey也就意味着每次获取要产生的网络流量较大，假设一个 bigkey 为 1 MB，客户端每秒访问量为1000，那么每秒产生1000MB的流量，对于普通的千兆网卡(按照字节算是128MB/s)的服务器来说简直是灭顶之灾，而且一般服务器会采用单机多实例的方式来部署，也就是说一个 bigkey 可能会对其他实例也造成影响，其后果不堪设想。
1. 过期删除
有个bigkey，它安分守己（只执行简单的命令，例如hget、lpop、zscore等），但它设置了过期时间，当它过期后，会被删除，如果没有使用 Redis4.0 的过期异步删除(lazyfree-lazy-expire yes)，就会存在阻塞Redis的可能性。

一般来说，bigkey 的产生都是由于程序设计不当，或者对于数据规模预料不清楚造成的，来看几个例子：
(1) 社交类：粉丝列表，如果某些明星或者大v不精心设计下，必是bigkey。
(2) 统计类：例如按天存储某项功能或者网站的用户集合，除非没几个人用，否则必是bigkey。
(3) 缓存类：将数据从数据库 load 出来序列化放到 Redis 里，这个方式非常常用，但有两个地方需要注意。第一，是不是有必要把所有字段都缓存；第二，有没有相关关联的数据，有的同学为了图方便把相关数据都存一个 key 下，产生 bigkey。

如何优化bigkey？

1. 拆
big list： list1、list2、...listN；
big hash：可以讲数据分段存储，比如一个大的key，假设存了1百万的用户数据，可以拆分成 200 个key，每个key下面存放5000个用户数据
2. 如果 bigkey 不可避免，也要思考一下要不要每次把所有元素都取出来(例如有时候仅仅需要 hmget，而不是 hgetall)，删除也是一样，尽量使用优雅的方式来处理。
3. 选择适合的数据类型。 例如：实体类型(要合理控制和使用数据结构，但也要注意节省内存和性能之间的平衡)



{% ablock %}
{% tabs %}
<!-- tab 正例 -->
{% ablock child:codeblock color:green %}
{% codeblock lang:bash %}
hmset user:1 name tom age 19 favor football
{% endcodeblock %}
{% endablock %}

<!-- tab 反例 -->
{% ablock child:codeblock color:red %}
{% codeblock lang:bash %}
set user:1:age 19 3 
set user:1:favor football
set user:1:name tom
{% endcodeblock %}
{% endablock %}

{% endtabs %}
{% endablock %}
