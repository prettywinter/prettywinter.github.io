---
title: 认识程序中的锁
categories: Skill
cover: lock
abbrlink: 43c52b29
---

认识程序中的 “锁”。

<!-- more -->

<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=4 orderedList=true}-->

<!-- code_chunk_output -->

- [锁](#锁)
- [锁分类](#锁分类)
  - [悲观锁](#悲观锁)
  - [乐观锁](#乐观锁)
  - [死锁](#死锁)
    - [产生死锁的四个必要条件](#产生死锁的四个必要条件)
    - [死锁的解除](#死锁的解除)

<!-- /code_chunk_output -->

## 锁

## 锁分类

### 悲观锁

使用系统层面的加锁方式

### 乐观锁

数据库层面的锁，通过增加 `version` 字段以及使用数据库的 **事务** 的方式加锁

可以解决超卖等问题，一般使用乐观锁，乐观锁的性能相较于悲观锁要好得多，这样在不影响用户的体验下保证了应用的性能。

### 死锁

原因：死锁是由于两个或以上的线程互相持有对方需要的资源，导致这些线程处于等待状态，无法执行。

#### 产生死锁的四个必要条件

1.互斥性：线程对资源的占有是排他性的，一个资源只能被一个线程占有，直到释放。

2.请求和保持条件：一个线程对请求被占有资源发生阻塞时，对已经获得的资源不释放。

3.不剥夺：一个线程在释放资源之前，其他的线程无法剥夺占用。

4.循环等待：发生死锁时，线程进入死循环，永久阻塞。

#### 死锁的解除

1.抢占资源，从一个或多个进程中抢占足够数量的资源，分配给死锁进程，以解除死锁状态。

2.终止（或撤销）进程，终止（或撤销）系统中的一个或多个死锁进程，直至打破循环环路，使系统从死锁状态解脱出来.
