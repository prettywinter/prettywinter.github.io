[{"title":"宋词，线装的美酒","path":"/p/73f87394/","content":"如果有人说宋词是线装的美酒，我就会说至今香醇满喉；如果有人说宋词点亮了满天的星斗，我就会说它妩媚了整个文字的宇宙；如果有人说宋词是千年的花后，我就会说它始终栖息在玫瑰的枝头，至今余香满手；如果有人说宋词是千年的凝眸，我就会说它始终蕴藏在灯火阑珊后，至今温暖心头。 宋词，它与唐诗争奇，它与元曲斗艳，承前启后。它比元曲含蓄，欲说还休；它比唐诗自由，挥洒风流。它错落有致，雪清玉瘦；它韵律优美，朗朗上口。它是几千年文字长廊里的美人，清丽婉柔，回眸处暗香盈袖；它是文学圣坛的巨钻，才高八斗，始终镶嵌在岁月的路口。 它是洒不完的清愁，斟不完的美酒，弹不完的箜篌，剪不断的离愁。它可以是纤纤手，云鬓柔，泪沾佳人衣袖；它可以是和羞走，金钗溜，却把青梅嗅；它可以是人约黄昏后，月上柳梢头。花间一壶酒，远山挂帘钩。它可以是一种相思，两处闲愁，才下眉头，却上心头；它可以是粉面含羞，花自飘零水自流，也可以是倚门回首，千年的梅香不朽；它可以是琼花吹落一江的清愁，也可以是红粉抚过百花的肩头。 它在莲心里漫游，在红尘中等候，在水之湄梳头，在幽竹林间行走。无论经过多少朝代的更迭，都新眉画就，山明水秀；无论经过多少时间的沙漏，都冰心雪柳，风采依旧。 它可以是李煜的无言独上西楼，月如钩，寂寞梧桐深院锁清秋的离愁；是剪不断，理还乱，别是一番滋味在心头的烦绪苦酒；是问君能有几多愁，恰似一江春水向东流的故国不堪回首；是一棹春风一叶舟，一纶茧缕一轻钩。花满渚，酒满瓯，万顷碧波里向往的自由。覆水难收，阶下囚，事事休，多少苦，多少忧，卡在喉；多少屈辱，多少磨难，泪满异乡的月头。失败的皇帝，词坛的巨斗，多少泪断脸，多少恨，说不出口，可怜小周后，终落赵光义之手，屈辱堵满心头，就是骂遍九州，怨都不能休！可怜李煜还是遭毒手，小周后也随夫天堂收，免得再在尘世遭污垢。 它可以是李清照的蹴罢秋千，起来慵整纤纤手，露浓花瘦，薄汗轻衣透；是昨夜雨疏风骤，浓睡不消残酒，金炉次第添香兽，红锦地衣随步皱，薄雾浓云愁永昼，瑞脑销金兽；是莫道不消魂，帘卷西风，人比黄花瘦。多少清丽在手，多少空灵满眸，多少锦心绣口，多少雪地轻柔。她与赵明诚，情深意厚，志趣相投；赌书泼茶，相思煮豆，大相国寺同游，好梦几回，却难白头。她的一生，非干病酒，不是悲秋，是千古第一才女的亡国之忧。 宋词不光是有着婉约的温柔，更有着豪放的风流，是陆游的胡未灭，鬓先秋，泪空流，身老沧州的志未酬；是红酥手，黄縢酒，满城春色宫墙柳的爱恨悠悠；是苏轼的大江东去，千堆雪，上下几千年的指点春秋；是竹杖芒鞋轻胜马，一蓑烟雨任平生的淡然悟透；是锦帽貂裘，千骑卷平冈的豪情演奏；是辛弃疾的千古兴亡多少事，不尽长江滚滚流，坐断东南战未休的恨不退敌寇；是岳飞的三十功名尘与土，八千里路云和月的故土难收！ 走在宋词的渡口，雪滩沙鸥，乌篷小舟，深黄一点入烟流，露华凄冷蓼花愁。你可以遥遥望见阮小七驾一叶扁舟，鬓角插一朵火红的石榴，你可以看见燕青倜傥风流，白锦上铺满软翠般的花绣。 千年的美酒，醉了多少人的心。万年的邂逅，有了心灵的悸动！如果你说那时的汴京是红肥绿瘦，我就会说那时的水城真是花团锦绣。如果你说那日的龙亭将相王侯，我就会说昔日的虹桥尽显风流；如果你说那时的清明繁华尽收，我就会说没有宋词的双眸，美丽就是海市蜃楼。没有宋词的巧手，隔着悠悠的岁月，荒凉就会爬满额头。","tags":["裁云剪水","月章","清音幽韵"],"categories":["月章星句"]},{"title":"你笑起来真好看","path":"/p/4ef26754/","content":"你笑起来真好看，像春天的花一样。 萌萌的小橘子。 太阳是我滚圆的！月亮是我咬弯的！ “我嫁人了你来砸我婚礼吗？”“开玩笑砸我自己婚礼干嘛！” 帆布鞋咱也能走出猫步，格子衫咱也能耍出帅气。 “收破烂！”，“卖垃圾！”。","tags":["星句","奇文瑰句"],"categories":["月章星句"]},{"title":"本是青灯不归客","path":"/p/30ddfd7e/","content":"看风光你是他人过客，观内心你才是生命主人。 灾难对于愚蠢的人是无底深渊，对于聪明的人是宝贵的财富。 看取莲花清，方知不染心。 我已经过了餐桌上有只鸡就一定能吃到鸡腿的年纪了。 把告别的话藏匿于盈盈眼波。 妖若有情妖非孽，人若无情怎为人？ ——陶醉 身心尘外远，岁月坐中长。 一个人久了，煮个饺子看见两个粘在一起的也要给它分开! 当你觉得孤独无助时，想一想还有十几亿的细胞只为了你一个人而活 医不自医，人不度己。 云敛晴空，冰轮乍涌；风扫残红，香阶乱拥；离恨千端，闲愁万种。 ——《西厢记》 玉宇无尘，银河泻影；月色横空，花阴满庭；罗袂生寒，芳心自警。 ——《西厢记》 室雅何须大，花香不在多。 贾岛醉来非假倒，刘伶饮尽不留零。 福禄寿三星高照，天地人一体同春。 或为才子佳人，或为君子小人，出场便见。有时欢天喜地，有时惊天动地，转眼皆空。 ——《少年大钦差》 演尽人间悲欢事，唱出天上思凡情。 ——《少年大钦差》 水天一色，风月无边。 养天地正气，法古今完人。 贵有恒何必三更眠五更起；最无益只怕一日曝十日寒。 学如逆水行舟不进则退；心似平原走马易放难收。 侯门深似海，怎许故人敲。 我曾七次鄙视自己的灵魂: 第一次,当它本可进取时，却故作谦卑；第二次,当它空虚时，用爱欲来填充；第三次,在困难和容易之间，它选择了容易；第四次,它犯了错，却借由别人也会犯错来宽慰自己；第五次,它自由软弱，却把它认为是生命的坚韧；第六次,当它鄙夷一张丑恶的嘴脸时，却不知那正是自己面具中的一副；第七次,它侧身于生活的污泥中虽不甘心，却又畏首畏尾. 笔底烟花传海国，袖中诗句落吴船。 世俗希望你在意的事情，你是否还耿耿于怀？ 无论我修魔修仙，修的都是心，修的都是真，只要心存善念，魔道亦是真道。 天上冷飕飕，地上滚绣球。有馅的是包子，没馅的是窝头。 你去问问你的佛，当年飞花可记得？你去问问你的佛，炼狱九层可去过？你去问问你的佛，三生石上刻什么？你去问问你的佛，能度苦厄，怎不渡我？ 你不要问我爱不爱你，如果有变，我会通知你的。 世界上只有一个我称之为家的地方，因为你在那里。 这么说吧，和你在一起就像人生病，离不开药方。 我思考良久，答案是我爱你。 “如果免费的话，我全要。”“真的？我就是免费的！” 这儿没人，我的心里有人。 没有人喜欢我，没有人想主动靠近我，每个人都在隔岸观火，看着我失魂落魄。 我怀疑你的本质是一本書,不然为什么我越看越想睡。 说书人乱改离分，演戏的人入戏太深。 你们知道最强的武器是什么？没错，就是补丁！ 你将忘记呼吸，你将忘记爱情。 你我的约定我一向记得，那一道道璀璨的光束，都是为你所亮。 世界上最痛苦的事情，莫过于爱你，却不能对你说出，我只能倾注于我的琴，让我的旋律诉说我的爱。 半途而废不好，所以我建议你喜欢我到老。 烟火慰风尘。 拨雪寻春，烧灯续昼。 林无静树，川无停流。 风带来故事的种子，时间使其发芽。 ——原神 花颜之所以绝世，不过在于攀折刹那的凄美。 把握现在时，将来怎会虚拟语气。追求最高级，理想常融情态动词。 行来春色三分雨，睡去巫山一片云。 窗外日光弹指过，席间花影坐前移。 流于尘世之中，行于天堂之上。 世间万物，表里如一者，又有几何？ 共君一夜话三生，话正投机君又行。 我们用初中三年去盼望高中三年，高中三年去憧憬大学四年，而用大学四年去怀念中学六年，最终用一生去祭奠我们的青春。大学毕业一年后的样子，是生活变得越来越压抑，而你，变得越来越不像自己。但逼你往前走的，不是前方希望的微弱光芒，而是身后现实的深渊万丈。 借千万人之眼，领会千万种人间。 佳思忽来，書能下酒；侠情一往，云可赠人。 极难处是書生落魄，最可怜是浪子白头。 山市晴岚、远浦帆归、平沙落雁、潇湘夜雨、烟寺晚钟、渔村夕照、江天暮雪、洞庭秋月。 二八笙歌云幕下，三千世界雪花中。 眼眸正似琉璃瓶，心荡秋水横波清。 天地不过是飘摇的逆旅，昼夜不过是光阴的门户。 人生总会有不期而遇的温暖和生生不息的希望。 凡有等待，就有启程。 躲得了对酒当歌的夜，躲不了四下无人的街。 半溪流水绿，千树落花红。 真实诞于虚拟，黑夜预告曙光。 野树晚风轻蝶梦，曲池芳草乱蛙声。","tags":["星句","语妙天下"],"categories":["月章星句"]},{"title":"如果没有李白","path":"/p/3b62cf4e/","content":"如果没有李白 如果没有李白 如果没有李白 似乎没有什么太大的影响 不过千年前少了一个文学家 《全唐诗》会变薄一点点 但程度相当有限 如果没有李白 几乎所有唐代大诗人的地位 都会提升一档 李商隐不用再叫小李 王昌龄会是唐代绝句首席 杜甫会成为最伟大的诗人 没有之一 如果没有李白 我们应该会少背很多唐诗 少用很多成语 说童年 没有青梅竹马 说爱情 没有刻骨铭心 说享受 没有天伦之乐 说豪气 没有一掷千金 浮生若梦 扬眉吐气 仙风道骨 这些词都不存在 蚍蜉撼树 妙笔生花 惊天动地 也都不见了踪迹 如果没有李白 我们的生活应该会失去不少鼓励 犯了难 说不了长风破浪会有时 想辞职 说不了我辈岂是蓬蒿人 处逆境 说不了天生我材必有用 赔了钱 说不了千金散尽还复来 更不要说 大鹏一日同风起 扶摇直上九万里 安能摧眉折腰事权贵 使我不得开心颜 如果没有李白 我们熟知的神州大地 也会模糊起来 我们不再知道 黄河之水哪里来 庐山瀑布有多高 燕山雪花有多大 桃花潭水有多深 蜀道究竟有多难 白帝城 黄鹤楼 洞庭湖的名气 都要略降一格 黄山 天台山 峨眉山的风景 也会失色几许 如果没有李白 历朝历代的文豪词帝 也会少了很多名句 没有举杯邀明月 苏东坡未必会有把酒问青天 没有请君试问东流水 李后主不会让一江春水向东流 没有事了拂衣去 深藏身与名 金庸的武侠江湖 将会天缺一角《侠客行》 千百年来 蜀人以李白为蜀产 陇西人以为陇西产 山东人以为山东产 一个李白 生时无所容入 死后千百年 慕而争者无数 是故 无处不是其生之地 无时不是其生之年 他是天上星 亦是地上英 亦是巴西人 亦是陇西人 亦是山东人 亦是会稽人 亦是浔阳人 亦是夜郎人 死之处亦荣 生之处亦荣 流之处亦荣 囚之处亦荣 不游 不囚 不流 不到之处 读其书 见其人 亦荣亦荣 幸甚至哉 我们的历史有一个李白 幸甚至哉 我们的心中有一个李白 你是谪仙人 你是明月魂","tags":["乐章","俊采星驰","裁云剪水"],"categories":["月章星句"]},{"title":"布袋戏诗号","path":"/p/ceb074a4/","content":"地灵人杰拂远志，梦定三生效谪仙诗成断雨流云外，人在光风霁月中。 霹雳布袋戏有心天下，却输一筆多情，我的山水落在你的眉间，你肯入画吗？——南风不竞 如果梦醒，总是要这般折磨，还不如未曾入梦。\t——南风不竞 驰来北马多骄气，歌到南风尽死声。 ——南风不竞 追浴沂之风徽，法舞雩之咏叹。 ——杜舞雩（yu二声） 别见风，别见尘，别见风尘染故人。 一恨才人无行，二恨红颜薄命。三恨江浪不息，四恨世态炎凉。五恨月台易漏，六恨兰叶多焦。七恨河豚甚毒，八恨架花生刺。九恨夏夜有蚊，十恨薜萝藏虺。十一恨未逢敌手，十二恨天下无敌。 ——剑君十二恨 满天银雪梦一生，悲乎？乐乎？遍地寒霜醉红尘，仇乎？情乎？流金岁月，难忘忆秋年。过眼云烟，独留风之痕。 过去，是我错了：我错在轻纵奸邪，任其荼毒苍生我错在诛魔无力，致使天下受害我错在失信红颜，难挽香消玉殒我错在有负师恩，愧让道剑蒙尘历历四错在，一剑一悔改醒悟的心，冷测的剑光象征道者的决然意志 一个人要退到哪里，才不是江湖。 ——皇甫笑禅 何为天命，不可屈服于天之命，谓之天命。 时间从来只留恨，不留人。 ——三余无梦生 江山如画，怎比拟你眉间一点朱砂岁月如歌，何曾改我心中半世痴情 人生须知负责的苦处，方能了解尽责任的乐处。 简默沉静者，大用有余；轻薄浮躁者，小用不足。以浮躁为之，则必坏事；以沉静为拙，则必失人。遇横逆之来而不怒，遭变故之起而不惊，当非常之谤而不辩，可以任大事矣。 有过往的堆累，才有生命的厚度；有生命的厚度，现在才能活的精彩；有精彩的现在，才有希望去展望未来。 人生在世就是要多学、多听、多看，时常充实自己，好学不倦。 ——疏楼龙宿 静思静心，是修智修行的第一步。 ——剑子仙迹 相遇就是巧合，巧合就是顺其自然，顺其自然就是回归原本，回归原本就是不要想太多，不要想太多就是不要多怀疑跟爱操烦。\t——破戒僧 诸法无常，为心自造，心之所向，无处不自往。 ——雅僧 很多人喜欢说无情，但真正的无情，汝可知？无情不是寡情，而是这份感情，无人能懂。 ——吞佛童子 真正有力量的人，是能施与他人爱的人，而不是等待他人的施舍。 要认识一个人，不一定要从他的过去开始参与。 人生不能一直挂念着遗憾，这样旅程怎会快活？ ——冰无漪 人生有些事情，错过一时，就错过一世。 ——冰无漪 当希望只能是希望时，代表逝去的，永远无法回来了。 ——意琦行 善不是一种言语，也不是一种学问，而是一种发自内心的行动。 很多时候，事情不能以对错来论，而是要用更温柔的心，来表达自己坚持与想法。这世上，就是有太多自认为没错的人，将似是而非的道理，当成了伤害他人的利器。站在道理高点的人，不代表他就是有依循道理的人。 不言过去如何难，只言难题如何过。 一个遭逢变故的人，最怕的就是安慰。安慰只会引来悲伤，却无法改变现状。 只要内心净白，何必在意外表的污秽呢？ 有时候，对善的苛求造成的伤害，并不下于为恶。 无我不能之事，无我不解之谜，无我不为之利，无我不胜之争。 识无用之用，通无能之能，了无道之道，化无极之极。 一萧一剑平生意，负尽狂名十五年。 ——乱世狂刀 昨日的关系，会因明日的情势不同而改变。 ——素还真 逆天，尚有例外；逆吾，绝无生机。 ——意琦行 人间，又污秽了！ ——弃天帝 人世的风雪，不是说停就停，如同命运的选择，并非尽由人意。 ——宫无后 迷惘时，不要想太多，只要循心而往，那就是方向了。 ——素还真 当初的景，当初的人，皆已不复当初，就连当初的记忆，也开始模糊。 ——倦收天 可以载清风，不可载人言；可以屈其身，不可屈其心。 ——无衣师尹 我不想夺走你什么，但我不想再让你夺走什么。 ——剑之初 所谓的会议，不过是一群彼此不能被说服的人，在努力呻吟而已。 ——魔王子 既然世俗的天不容你，那从此刻起，吾便是你的天。 ——一剑封禅 我只是低调，不代表没料。 ——唐绝 降者生，不降者，超生！ ——矩业烽昙 枪啊枪，不珍惜生命是现在的潮流吗？ ——生命练习生 陌路相逢，只不过一个错身，但在心上安一个人之后，轻易便是一生。 ——剑非道 風不失期，君不失期。 ——慕容清 我欲抱歉天下，试问谁敢多谢。 ——风之痕 一日三千斩，风神睨九天。剑锋英雄墓，杀佛不留仙。 ——风之痕 弃天帝，一剑，让你含恨！ ——风之痕 抱歉一出尊天下，剑界神话笑群雄。 ——风之痕 别人的多谢，就是吾的抱歉。 ——风之痕 多谢不语，抱歉化身。封喉净世，吾名正义。 ——风之痕 风剑随手出鞘，问谁人、敢言多谢？ ——风之痕 一剑越山河，九天寰宇谁称雄？抱歉封不尽，废物垃圾何其多。 ——风之痕 一声多谢，抱歉索命。 ——风之痕 抱歉纵横三万里，一剑封喉十九州。 ——风之痕 多谢方能抱歉，净手方能封喉，强敌方能证剑。 ——风之痕 问普天之下，敢在风之痕面前多谢者，能有几人。 ——风之痕 抱歉无情，你承受不了。 ——风之痕 平生横剑傲顶峰，无人敢言多谢梗。英雄遇吾恨气短，抱歉斩下绝苍生。 ——风之痕 横一眼秋波即别，仰饮岁月；掠一笔千林妩媚，不世风流。 南风不竞，南风不竞，狂情成画，歌到尽头。清风三巡不解意，拈来落花笑情多啊。 天外情风吹云立，红尘飞雨悟剑声。 山水有尽，一梦一生，何求千古空名。咏怀骋岭，舟平涛惊，长啸剑舞风轻。 ——慕灵风(山隐浮云映霜清) 观人之道以德为主，以才为辅，才德全者，尚已共次；有德无才者，其德可用；有才无德者，其才难用。问之以是非，而观其志；穷之以辞辩，而观其变；咨之以计谋，而观其识；告之以祸乱，而观其勇；醉之以酒，而观其性；临之以利，而观其廉；期之以事，而观其信。 命里有时终须有 凡事不可强求 时至运就到，苍天不会辜负苦心人。 此后，岁月不堪记，无衣师尹不堪提。 ——无衣师尹 纵横西武林百载，神采绝顶，意气风发，败尽江山万里。独身覆灭西城魔域、缁衣十三楼，孤仞峰之战，无分正邪，群雄惊惧，再无抗手。神天三响一弦天听，万籁俱寂，千百苍生，十方归灭。初达道已感罪孽难堪，自裁三指，匿身失迹，后谓琴中伏羲，弦上魔圣。 这一剑，是忆秋年敬你人外有人，天外有天；这一剑，是风之痕示你高山叠山，海底藏海。 你有死的觉悟吗？你有生的能为吗？ 人生就像品茗，懂得吃苦，才能回甘。 ——鷇音子 檀鸾托情遣風辞，曳如弱柳挽别思。 ——秋别 原来这个江湖，我连十天都撑不下去。 ——笑十天 错不在你，你该面对的，是人一生皆要正视的三个问题——失去什么会令人恐惧？什么值得人活下去？以及什么值得你牺牲性命？每一个问题的答案都一样，就是爱，爱不会因为你们不再相见就结束。 向佛之心无前恶。 蛰龙已惊眠，一啸动千山。 ——龙王鱽 是谁多事入江湖？人也累苦，心也累苦。是君无聊又糊涂，不在江湖，偏问江湖。 ——药师、朱痕染迹壁有瑕 非吾小天下，才高而已。非吾纵古今，时赋而已。非吾睨九州，宏观而已。三非罪焉，无梦至胜。 天上星多月难明，地上人多心难平。是非曲直终有论，善恶到头须现形。 有心无心，心在人间。多情薄情，情系江湖。 运筹决策，坐拥江山；神飘羽动，谈笑倾城。 昂首秋千远，啸傲风间，堪寻敌手共论剑，高处不胜寒。 青灯风雨夜，白首故人心。 一曲一调流水吟，清风绿竹伴古琴。指拨千古叠叠音，震荡天下茫茫心。 身入无间，足踏黄泉。 金光布袋戏吾黑白郎君要以东瀛第一人的失败，来书写吾天下第一的风采！ 活在胜利之中，才是黑白郎君生存的意义。 为他人而死，就是伟大？不追求保护自己的能力，只期盼著他人的救援，这种人，真的值得帮助吗？你口中的勇气，能保护这群人到几时？今日有魔世，明日是苗疆，总有一日，你会保护不了。然后，在你看不见的地方，那些人一个一个死亡，你帮助他们了吗？没有！你只是给他们软弱的藉口，绝望时的错望！ ——黑白郎君 忏悔几时，拎剑挥尘，不省风波染一身。玩物丧志，无地埋根，人生何处不留恨。 ——欲星移 何为天命？不可屈服于天之命运，谓之天命。 ——苍越孤鸣 其实人都有脆弱的一面，为什么不能给予包容呢？正因我们自己也同样脆弱，同样会犯错，才更需要互相扶持，赤羽先生，你不也扶持了俏如来的脆弱？ ——俏如来 为何你们每一个人，都叫我别放弃自己，最后，却是你们自己放弃自己。 ——月牙岚 无心无我，不思量，不分别，不执著，人无我，法无我，自无我，他无我，一切成空。 不生不灭，无德无功，一念缘起，一步禅空。 ——一步禅空 贱又如何？比得起遭受世俗眼光，而压抑本性的人，奴家活得何等的自在。 ——女暴君 男人的眉角就是死也不能退。 ——邪马台笑 因为历史无法回头，我们无法证明没改变会更好，所以对赞同的群众而言，只要改变就必然是正确。否则，他们就必须接受，自己是让天下动荡的原因。 ——俏如来 观星望斗惯幽居，一片神鳞渡太虚。伯仲分时同授冕，虹霓过处尽疆域。 ——欲星移 好茶要有茶味，人，也要保持一点人味，过头就会失去身为人的骄傲。智者善于谋划人心，智者却也最难筹划感情，人心千万种，谁能逐一掌握？ ——赤羽信之介 嘘……闻到了吗？又来了，愚蠢的气息又浮现咯 ——雁王 三千白发三千恨，八百红尘八百深。纸碎形余空伞骨，无情拆作鬼萧吟。 ——白练飞踪锦烟霞 身似秋水任飘渺，名剑求瑕亦多愁。独向苍天开冷眼，笑问岁月几时休。 ——秋水浮萍任飘渺 风满楼，卷黄沙，舞剑春秋，名震天下。雨飘渺，倦红尘，还君明珠，秋水浮萍。 ——任飘渺 芳菲阑珊，夙缘鶗鴃，風驷云轩愁誓约。夜蝶飞阶，霎微雨阙，剑锋无情人葬月。 ——无情葬月 人非神人，怎可能无所不晓，正因不知，所以查探。 ——赤羽信之介 霓霞羽战火连天，墨影神誓护千年。寄语孤鸿诛邪灭，止戈剑印荡魔渊。 ——孤鸿寄语默苍离 到目前为止，天，还不是我的对手。 ——孤鸿寄语默苍离 你以为天衣无缝的计划，破绽多的简直要吾做笔记才记得住。如果思考是生存的证明，我很难判断，你是不是一具尸体。 ——孤鸿寄语默苍离 修罗夜叉，百年孤寂，就是为了在这一刻，化为人身重逢。薰，我愿为你，再等一百年。 ——柳生鬼哭 没有决断之心的舍弃过往，不过是故作姿态。神蛊温皇要毁，不但要回去过去，还有现在、未来。 ——神蛊温皇 世人传颂的桃源仙境，原来从不存在，我一直没讲过，我不喜欢风花雪月。这四个字，风逝、花凋、雪融、月缺，这名字…太悲伤了。风中散发着背叛的味道，那是血腥的气味。雪，消逝了，消逝在风中，消逝在花香中，太无情了。雪中刻画出背叛的印记，制造了痛心的回忆，本属于无情的剑，用血来了解这一切哀悲。我又想起了，多情的花，无情的雪，当風停止追逐，月只能无言，太悲痛了。你们都问过我，为什么我要叫做无情葬月，我一直都没向你们解释，应该说，是我不敢解释，因为，无情最是多情人。 ——无情葬月 冷静，并不是智者的专属，成功固然欢喜，失败固然愤怒，重要的是如何保住性命。自失败中站起，不管在什么情绪之下，都要保持三分冷静，才能扳回劣势。 ——赤羽信之介 既有默契，何须多言。若无默契，无须多言。 ——赤羽信之介 肯努力突破者，便无废物之说，言辞苛刻者，也非必是自慢之徒。\t——赤羽信之介 人，总是会有迷失、犹豫、痛苦、徘徊的时候，不知道自己是对还是不对。在旁人看来，你是虚弱而且优柔寡断，但那只是因为他们自己不是亲身经历的人，用一张嘴说别人那都是很简单。 ——剑无极 得到了三十年所等待结果，却失去了三十年来曾经与共的一切，这是否值得？叛逆，竞日孤鸣，已经伏诛。 数载传承太白行，惊涛骇浪剑锋鸣。凌波仙影扬尘过，潮汐瑰瑕渡死生。 ——东皇战影 夜坠天崩人失向，星沉月落鬼埋霜。 ——鬼途奇行录 23 “你要多少兵力协防？”“我，一个人。”“不需要更多？”“不能更少了” ——军师与小王对话 剑无极：这些死人跟你有什么关系？风逍遥：他们是我杀的，全部都是。（剑无极和雪山银燕一怔）剑无极：你若不是在开玩笑，那你就真正不简单了。风逍遥：哈，你们更不简单。雪山银燕：同为苗疆的人，为什么要这样互相残杀？风逍遥：别说得好像不是同族的人，就可以随便杀。在苗疆，各个山头彼此攻伐，不服王权；出了苗疆，中苗就有分别；出了中原，如今人魔对立。就算是一个门派，内部也有派系之分，小至一个家族，也会兄弟阋墙。讲到底，分的是彼此，争的是权利，抢的是利益，夺的是名声。除了自己人，就不是自己人。不是自己人，就是别人。这个分别，到底到哪里可以停止？！剑无极：哇，老贼头突然说起哲理来了。你所讲的我能够体会，东瀛的西剑流、东剑道之争，也是如此。雪山银燕：讲到底，那些都是少数的野心份子的欲望。风逍遥：如果只是少数野心份子就算了。分别，人永远会有分别。中原杀了苗人，就比苗人杀了苗人更罪恶。魔杀了人，又比人杀了人更可恶。大大小小的分别，种族的分别，属地的分别，姓氏的分别，家族的分别，血缘的分别。人啊，永远可以找出与自己不同的族群作为敌人，所以永远不会停止战争。（风逍遥仰头而饮，又再次酹酒）风逍遥：安心上路。雪山银燕：但是你呢？你又为什么作战？你说这群人都是你所杀的，你为什么要杀他们？风逍遥：工作。雪山银燕：我不能认同你这种工作。如果你不想做，你可以别做。杀了人，才来这用酒吊祭，太伪善！剑无极：笨牛啊，脾气别这么大啊。（转向风逍遥）是说我赞成他讲的话，你这种行为太假掰了。风逍遥：我不杀他们，就是他们杀别人，或者别人杀他们。我的方针，是能少死几个就是几个。剑无极：等你杀完了就世界和平了，是吗？风逍遥：不可能会有那一天。你们不就讲过，你们是中原人，我是苗人，今日萍水相逢，他日敌友难辨。这是人的劣根性。我没伟大到能够阻止。剑无极：中苗如果和平，还有这种的分别吗？风逍遥：就算和平，苗人仍是苗人，中原人仍是中原人。这就是分别。雪山银燕：这只是思考上的谬误。人可以排除这种分别。风逍遥：你了解，我了解，你能够让全天下的人都了解吗？剑无极：消极。风逍遥：各人的看法不同罢了。剑无极：好了，到了这里，我们也应离开了。风逍遥：在我们成为敌人之前，还能交一个朋友吗？（从怀中掏出酒，三人同干）剑无极：敬你，老贼头。雪山银燕：我结交的朋友，无论立场怎转换，永远是朋友。风逍遥：希望如此。对了，提醒你们一件事情，无论是谁叫你们来偷酒，我想啊，他都不是安什么好心。雪山银燕：多谢你，再会。剑无极：有机会就再见。 风逍遥：老板娘都亲自帮你们倒酒了你们还不喝吗？还是你们比较想喝我身上这坛？（司空知命默然将手伸进铁拳）他乡遇故知，卖一点面子，来一杯嘛！岁无偿：请酒省下，我们倒是有不少的事情想问，望同乡不吝指教！敢问哪处山头、哪处买卖？风逍遥：捧一只铁碗，装九斤货，四处讨一点残羹冷饭，求一个遮风避雨、天下太平。 玉笔难图，千篇离骚，入世不踏沧桑路，出尘不落槁朽苏。别离书卷，人海泛渡，闲时舞剑点飞霜。谁人疏狂？自在如吾，一诗一剑定风波。 ——莫离骚(天之道) 山辽水阔碧连清，一步江湖几忘龄。莫使鬼途欺侠道，卓然尘外执天刑。 ——岳灵休 功名爵禄尽迷津，贝叶菩提不受尘。久住青山无白眼，巢禽穴兽四时驯。 ——神蛊温皇 炊烟尽处有人家，一亩耕勤到日斜。薄米犹同星入碗，桑居亦可号琅琊。 ——北竞王 月华缠绵登高楼，清霜秋露只无情。落梅横笛寻旧梦，平生叹愿未识卿。 ——聆秋露 善恶纷纭炼一丸，悬坨秤上两相难。三千乐土无人至，十八泥犁百事宽。 ——鸩罂粟 封侯盛世灯宵，权衡天下，百代风骚。功名不过传谣，回眸一笑，举步烟硝。 ——凰后 听琵琶，随波逐浪风流计；赏绝艺，骇浪惊波入酒茶。 ——北冥殇 人情事理，似砚多磨。登台将相，日久牢枷。扬波蹼影，不过群鹅。无争此世，得愿长歌。 ——砚寒清 星耀自古晦明时，不持太阿误剑诗。 ——李剑诗（旻月） 沉刀埋霜小楼庭，回首江湖风云轻。 君有才能纵捭阖，清溪仰望有遥星。 ——别小楼（遥星） 十方萧索无涯，千古夕阳有主。 ——星月合招 岁月年华，醉态拈花，小风时雨摘云霞，堂前燕来谁人家。行天涯，扇风雅，独倚晚沙，叹剑无瑕。 ——慕容宁 口无分寸，不识王孙；美酒香唇，颠倒晨昏。散尽金银，当头鸿运；赌定乾坤，笑杀风云。 ——风云太岁孟高飞","tags":["布袋戏","诗号"],"categories":["布袋戏"]},{"title":"金光剧集","path":"/p/b2303b63/","content":"地灵人杰拂远志，梦定三生效谪仙诗成断雨流云外，人在光风霁月中。 决战时刻决战时刻集数标题预告时间DVD封面包装纸套横幅01（无）同步发行12.06.27史艳文、藏镜人史艳文、藏镜人藏镜人02金刀 魔刀炎魔幻十郎03碎心修罗同步发行12.07.11柳生鬼哭、桐山薰炎魔幻十郎、柳生鬼哭、桐山守独眼龙04是魔非魔千雪孤鸣05绝世不败三度开战12.07.25梁皇无忌梁皇无忌炎魔幻十郎06情义抉择独眼龙07怒佛泣云愤怒开战12.08.08赤羽信之介赤羽信之介、神蛊温皇任飘渺、剑无极08（无）神蛊温皇09最后的决杀全面开战12.08.22月牙岚、爱灵灵任飘渺雪山银燕、雨音霜10风云辟易任飘渺11南宫之恨终极开战12.09.05俏如来雪山银燕、俏如来天海光流12一剑生死雪山银燕13最后一战浴血开战12.09.19史艳文、藏镜人宫本总司史艳文、藏镜人14血染江湖剑无极15泣血之泪同步上市12.10.03宫本总司、月牙泪独眼龙宫本总司、月牙岚、月牙泪16生死由吾不由天女暴君17光与影真情上市12.10.17天海光流、邪马台笑网中人女暴君18一着之差网中人19天下第一最后奋战12.10.31黑龙、白狼黑白郎君炎魔幻十郎、黑白郎君20全面封杀黑白郎君 九龙变九龙变集数标题预告时间封面封底横幅01（无）蜕变上市12.12.05史艳文、藏镜人藏镜人史艳文02魔中谜03雪刀朔夜惊变上市12.12.19万朔夜赤羽信之介神田京一、衣川紫04新局05孤鸿寄语默苍离隆重上市13.01.03竞日孤鸣酆都月万朔夜、聆秋露06生离死别07最后的考验轰动上市13.01.16默苍离苏厉神蛊温皇、宫本总司08双狼决09暴雨将至贺岁上市13.01.30网中人忆无心梁皇无忌、月牙岚10三王骨 九龙秘11神魔非我 剑十一剑者之终13.02.13宫本总司任飘渺任飘渺12魔之变13全面溃败溃败之战13.02.27苗王女暴君网中人、魔司令14央 殃15第二个魔魔之泣13.03.13梁皇无忌月牙岚剑无极、春桃16逆转的战局17永远的遗憾宿敌终战13.03.27黑白郎君网中人藏镜人、忆无心18书中计19宿敌终战复苏的剑意13.04.10剑无极樱吹雪黑白郎君20天书现世21兄弟落燕孤鸣13.04.24雪山银燕邪马台笑雪山银燕22牺牲23飘渺 无极传承的意志13.05.08剑无极凤蝶万朔夜、独眼龙24第三本天书25浴血双雄兄弟无悔13.05.22藏镜人千雪孤鸣默苍离26变生枝节27已逝的情分情断一剑13.06.05聆秋露冽风涛千雪孤鸣、苗王28黑色的手 杀人杀手29三步棋 杀温皇弑皇 王计13.06.19任飘渺令狐千里竞日孤鸣30诡谲的战局31战死的狂人计杀 战死 牺牲13.07.03独眼龙黑白郎君酆都月32第二个局33算不出的异变听不见的狼鸣13.07.17中谷大娘冥医樱吹雪34暴雨前夕35末端的谜底算尽的天意13.07.31俏如来苗王樱吹雪36九龙变 魔世现 剑影魔踪剑影魔踪集数标题预告时间封面封底横幅01（无）不说兄弟、魔世开启13.08.28藏镜人、千雪孤鸣任飘渺（无）02魔之始动03牺牲者彻底溃败、魔世开杀13.09.11苍狼魔世七先锋殁神翼04帝鬼的战策05流离的王子修罗征伐13.09.25帝鬼史艳文史艳文06恶首 撼天阙07苍狼之誓决断的亲情、决断亲情13.10.09撼天阙废苍生撼天阙、苍狼08始战09腥风再起过往曾经、绝不背叛13.10.23战兵卫锻神锋战兵卫10战祸来临11血战天擘峡似亲或仇、再现蜕变13.11.06戮世摩罗邪马台笑、天海光流天海光流12诛魔之决13战修罗 帝鬼全面始动、天罗地网13.11.20铁骕求衣风逍遥帝鬼14墨狂15（无）坠下的金刀、止戈开阵13.12.04雪山银燕独眼龙雪山银燕16极端之路17天伦梦断杀父的刃、局中之局13.12.18默苍离竞日孤鸣默苍离、俏如来18破碎的师徒19（无）弃命斗天14.01.01俏如来网中人剑无极20末日鬼修罗 魔戮血战魔戮血战集数标题预告时间封面封底横幅01（无）消失的英雄、魔戮始动14.01.15风逍遥荡神灭、炽阎天、曼邪音黑白郎君、戮世摩罗02胜邪封盾03四界连动寻心少女14.01.29欲星移忘今焉欲星移04非然踏古忘今焉05狼之变（无）14.02.05黑白郎君忆无心06熟悉的身影07再现不败（无）14.02.12梁皇无忌万雪夜、聆秋露08血洗梅香坞09灭日之局魔性人心、连环劫14.02.26竞日孤鸣戮世摩罗竞日孤鸣10杀着11血战幽林情义决、众叛亲离14.03.12战兵卫撼天阙撼天阙12决战将启13围城之战似马骷髅、命悬一线14.03.26网中人修儒梁皇无忌14三掌三危15阴阳两隔卸下的亲情、倒下的王者14.04.09忆无心冥医戮世摩罗16明朗的局势 晦暗的心17情断义绝断情刀、快意恩仇14.04.23赤羽信之介神田京一赤羽信之介18突破僵局19无情刀真情如魔、绽放的血花14.05.07荡神灭恋红梅荡神灭20围城之战21倾城之战情义末路、末路狂涛14.05.21铁骕求衣竞日孤鸣苍越孤鸣22狼王 狼亡止不住的泪、终战14.05.28戮世摩罗雪山银燕、剑无极（血刃神罡）23魔势力反扑的狼、一念无间14.06.04一步禅空、法涛无赦赤羽信之介一步禅空24变乱回不去的曾经14.06.11神田京一俏如来姚金池25背叛的魔意外之变14.06.18苍越孤鸣冽风涛、岁无偿、叉猡神田京一26母女劫绝情蝎14.06.25女暴君白日无迹女暴君27千丈之弓弦断失策14.07.02荡神灭、炽阎天、曼邪音铁骕求衣、欲星移、赤羽信之介曼邪音28魔的逆袭带杀佛怒14.07.09忘今焉一步禅空、法涛无赦法涛无赦29逆袭的修罗白雾飞踪14.07.16俏如来废苍生（无）30人 佛 魔佛劫魔威14.07.23玄之玄酆都月锦烟霞31蔓延的魔血染天门14.07.30废苍生锻神锋酆都月32魔之锋暗锋14.08.06冥医玄狐玄狐33沉潜的暗流宿敌终局14.08.13锦烟霞欲星移网中人34决战达摩金光塔佛魔魔戮14.08.20雪山银燕、剑无极无情葬月俏如来 墨武侠锋墨武侠锋集数标题预告时间封面封底横幅01（无）亲脉断情14.09.03俏如来雪山银燕、剑无极雪山银燕02风花雪月平地风雷14.09.10戮世摩罗梁皇无忌荡神灭03百年情仇九旋之渊14.09.17荻花题叶禹晔授真梁皇无忌04新局一步雷池14.09.24玄之玄欲星移剑无极05杀魔的刀 渡魔的手奏不出的挽歌14.10.01网中人戮世摩罗网中人06剑之魔爱随风逝14.10.08玄狐一步禅空雨音霜07慈悲的代价众生何辜14.10.15法涛无赦凤蝶玄之玄08存于风中的刀夺命花14.10.22锦烟霞神田京一荻花题叶09真相 假象不该揭开的秘密14.10.29无情葬月梵海惊鸿风逍遥10飞雪中的玲珑佛殇 蝶恸14.11.05风逍遥玲珑雪霏梵海惊鸿11连环局佛魔殊途14.11.12苍越孤鸣雨音霜一步禅空12崩裂的如来轮回无解 因果非爱14.11.19一步禅空锦烟霞锦烟霞13（无）无情 无情14.11.26欲星移修儒无情葬月14逐渐揭开的真相失败的剑 归佛的魔14.12.03雪山银燕、剑无极玄狐剑无极15胜负逆转影形之秘14.12.10玄之玄、俏如来赤羽信之介玄之玄16天门佛血亡命如来14.12.17忘今焉荻花题叶俏如来17坠途血杀尊颠倒世间 梦想开杀14.12.24梵海惊鸿玄之玄梵海惊鸿18锋海剑夺凤凰折翼14.12.31法涛无赦锻神锋赤羽信之介19不可撼动的神兵金刚不灭15.01.07白日无迹靖灵君法涛无赦20一局十年虬龙腾 道剑争15.01.14玲珑雪霏梦虬孙梦虬孙21飘散在风中的血泣月悲风15.01.21风逍遥无情葬月无情葬月22燕血凝霜落燕覆霜15.01.28雨音霜雪山银燕、苍越孤鸣雨音霜23禁地狼影狼现踪 佛断首15.02.04靖灵君万雪夜千雪孤鸣24缺舟一帆渡再造轮回15.02.11千雪孤鸣缺舟一帆渡缺舟一帆渡25逆转局势的一着觉醒的逆刃15.02.18凤蝶剑无极剑无极26最虚伪的友情弃生同死 蝶剑不分15.02.25无情葬月忘今焉凤蝶27羽国访客暗日雁影15.03.04万雪夜俏如来雁王28无情葬月落月残雪15.03.11缺舟一帆渡风逍遥玲珑雪霏29开杀的刀 风中的血风月悲歌15.03.18铁骕求衣风中捉刀风中捉刀30谋女 魔女王者膝地15.03.25梦虬孙鳞王苍越孤鸣31傲邪残月风停 落月15.04.01风中捉刀雁王无情葬月32黑暗中的智慧墨世开道 净土来临15.04.08藏镜人、千雪孤鸣独眼龙、逾霄汉藏镜人 墨世佛劫墨世佛劫集数标题预告时间封面封底横幅01（无）钟破 钵散 天门留憾15.04.22梵海惊鸿锦烟霞梵海惊鸿02正面交锋废铁神兵15.04.29雁王赤羽信之介废苍生03佛劫来临不曾离开15.05.06废苍生任飘渺一步禅空04雁王开局无法驾驭的神兵15.05.13俏如来玄狐俏如来05佛杀如来立身光明下的影形15.05.20玄之玄锻神锋玄之玄06佛劫再临迷海一航渡如来15.05.27赤羽信之介、神田京一雪山银燕、雨音霜缺舟一帆渡07（无）兄弟决裂15.06.03独眼龙万雪夜雪山银燕、剑无极08月凝湾的秘密神鳞之变15.06.10铁骕求衣风逍遥欲星移09无法回头的选择翻掌起风云15.06.17飞渊凰后藏镜人10始战佛劫异境 绝风15.06.24风逍遥巧灵风逍遥11王者 亡者军亡风止震板荡15.07.01凰后铁骕求衣铁骕求衣12扩散的救赎观虚梦 破实影15.07.08玄狐飞渊忆无心13光明无水两分界 鸿飞岂复计东西消失的故事15.07.15缺舟一帆渡、念荼罗雁王玄狐14（无）咫尺天涯15.07.22风间始、鲁玉北冥觞风间始15光明中的黑暗战役冰融剑断 入地成佛15.07.29锻神锋鲁缺千雪孤鸣16最后的王牌换不回的亲情15.08.05苍越孤鸣千雪孤鸣苍越孤鸣17（无）（无）15.08.12大智慧（无）（无）18（无）父与子 仇与情15.08.19北冥封宇欲星移鲁缺19不及挽回的亲情血染黄沙15.08.26无名浪客神蛊温皇鲁玉20（无）大谋不谋15.09.02凤蝶剑无极欲星移21久别的风采轮回飘渺 云海奇踪15.09.09鲁缺废苍生、鲁玉任飘渺22武智之斗生机 牺牲15.09.16玄狐、俏如来云海过客梦虬孙23（无）自我之战15.09.23梦虬孙雪山银燕缺舟一帆渡24（无）沸腾的杀意15.09.30欲星移银娥、七巧逾霄汉25神剑 剑神神剑一瞬15.10.07剑无极缺舟一帆渡、任飘渺剑无极26孤雁斗狂龙龙泉现踪15.10.14史艳文御兵韬史艳文27空门 死门殊途15.10.21北冥觞忆无心、燕驼龙千雪孤鸣28云海惊雁觉醒的过往15.10.28云海过客藏镜人藏镜人29苦海沉舟梦幻泡影 智慧不存15.11.04雪山银燕苍越孤鸣大智慧30决战之前决战变数15.11.11御兵韬北冥封宇公子开明31最终的圣战全面溃败15.11.18神蛊温皇俏如来俏如来32最后的圣战绝望的圣战15.11.25缺舟一帆渡玄狐玄狐 墨邪录墨邪录集数标题预告时间封面封底横幅01（无）魔威 佛劫15.12.16元邪皇欲星移缺舟一帆渡02魔劫再起 人界无光黄土之上15.12.23梦虬孙北冥觞北冥觞03龙魂强者 谋者15.12.30独眼龙逾霄汉西经无缺04全面投降降服的代价16.01.07银娥、七巧千雪孤鸣长琴无焰05各方算计狼摧 人散 计连环16.01.14御兵韬长琴无焰千雪孤鸣06战火燎原奇兵 奇策16.01.21俏如来曼邪音鬼飘伶07魔啸 龙鸣 天下乱龙鸣之斗16.01.28炽阎天锦烟霞应龙师08鱼龙变龙硝鳞散16.02.03剑无极西经无缺北冥封宇09新战端计中计 谋中谋16.02.10飞渊北冥封宇公子开明10一剑之争冷剑冽锋16.02.17公子开明鬼飘伶任飘渺11公子谋 弦主计弦外之音 暗行之策16.02.24雪山银燕应龙师独眼龙12杀龙开路魔龙斗 生死决16.03.02榕桂菲御兵韬苍越孤鸣13六绝禁地逼命时刻16.03.09废苍生鲁缺史艳文14元邪皇的秘密锋火神兵16.03.16天地不容客史艳文天地不容客15天下无敌 天下公敌灭世邪威 斩武归始16.03.23玄狐飞渊玄狐16魔乱沙场魔魂16.03.30墨雪不沾衣榕桂菲炽阎天17血战天下撕裂的真相16.04.06西经无缺剑无极雁王18血战尸山双阵撼魔龙16.04.13千雪孤鸣雪山银燕元邪皇19出卖的魔魔心不屈16.04.20鬼飘伶公子开明曼邪音20双重背叛绝境 谲境16.04.27狷螭狂梦虬孙凰后21战神斗邪皇最强之战16.05.04长琴无焰未珊瑚（无）22料不到的决战意外之战16.05.11应龙师元邪皇俏如来 东皇战影东皇战影集数标题预告时间封面封底横幅01（无）纯魔之佛16.05.25公子开明应龙师公子开明02心魔绝望深渊16.06.01墨雪不沾衣长琴无焰雪山银燕03魔心 心魔诡魔逼命16.06.08天地不容客元邪皇戮世摩罗04超渡一帆引渡16.06.15雪山银燕缺舟一帆渡缺舟一帆渡05燕杀生死赌注16.06.22鬼飘伶公子开明鬼飘伶06史家人的抉择绝雁 燕绝16.06.29榕桂菲铁骕求衣雁王07血战孤燕最难的抉择16.07.06史艳文天地不容客史艳文08（无）情义关 生死决16.07.13元邪皇雪山银燕元邪皇09（无）最后的血战16.07.20未珊瑚北冥华（佛珠）10深海波涛阎王索命16.07.27梦虬孙北冥缜梦虬孙11幕后黑手悬天约 绊心寒16.08.03神蛊温皇、千雪孤鸣鬼门开神蛊温皇12毒 药覆面杀机16.08.10北冥封宇鸩罂粟覆面人13毒手 杀手 幕后的手侠义之心 愤怒之火16.08.17任飘渺伴风宵、误芭蕉任飘渺14难以抉择的取舍幕后黑手16.08.24俏如来北冥异误芭蕉15一剑断情剑残 蝶碎16.08.31剑无极、凤蝶神蛊温皇剑无极16谜团中的阴谋虎狼之势16.09.07误芭蕉榕桂菲北冥华17波涛汹涌暗涌潮动16.09.14北冥缜狷螭狂北冥缜18（无）东皇现 新局生16.09.21北冥异剑无极剑无极19御魂笑光辉侠道 武道16.09.28御魂笑光辉砚寒清江宪龙一20操线鬼手异杀之术16.10.05江宪龙一千雪孤鸣幻刃残心21樱之谜月之樱 樱之谜16.10.12樱吹雪御魂笑光辉樱吹雪22恩仇抉择血泪泣恩仇16.10.19幻姬重子出云能火、衣川紫出云能火23血扇狂花龙足断 灵能现16.10.26月牙诚梦虬孙爱灵灵24（无）燃眉之择16.11.02风间久护紊劫刀北冥异25（无）收不住的刀16.11.09北冥华安倍博雅千雪孤鸣26（无）天伦悲歌16.11.16午砗磲风间久护风间久护27（无）龙虎争 危势起16.11.23风间烈江宪龙一风间烈28龙决 雷鸣 山神威血舞 血刃 生死门16.11.30安倍博雅桃子姐望月咲29溃败之战含笑九泉16.12.07立花雷藏俏如来立花雷藏30雷动 灵恸 雁动荡血染黄沙16.12.14月牙岚立花雷藏月牙岚31（无）樱 凋零16.12.21鬼夜丸樱吹雪樱吹雪32（无）覆翻玄黄16.12.28雁王幻姬重子雁王33皇权败 胧中现一战存亡17.01.04八纮稣浥风间烈北冥缜34（无）围杀之局17.01.11月牙岚望月咲天宫伊织35（无）缜落 雷绝 岚坠渊17.01.18天宫伊织赤羽信之介月牙岚36寒澈 魂清 月泣血玩命之局17.01.25砚寒清天宫伊织月牙诚37前兆 惊爆线索惊爆线索17.02.01紊劫刀风逍遥木魅38不速之客揭心露相17.02.08赤羽信之介幻刃残心安倍博雅39凶潮异火灼剑赤焰17.02.15上杉龙矢八纮稣浥上杉龙矢40（无）绝情雷 剑无悔17.02.22北冥皇渊胧三郎风间烈 魆妖记魆妖纪集数标题预告时间封面封底横幅01天书再现妖启暗世17.03.22北冥封宇北冥皇渊俏如来、赤羽、剑无极、砚寒清、北冥皇渊02背叛者璞镜映妖17.03.29废苍生奇客不染尘砚寒清03逆转局势的一着虎父不容17.04.05天地不容客忆无心风间久护04鬼之踪 妖之迹纵横争锋17.04.12蜃虹蜺望月咲北冥皇渊05不断翻转的险局妖间炼狱17.04.19胧三郎柴田道末红翎06不堪回首的故人假面修罗17.04.26风间烈御魂笑光辉御魂笑光辉07争斗下的牺牲品仇心不泯17.05.03梦虬孙上官鸿信月牙诚08节外生枝戮世战端17.05.10山神剑无极陇三郎09踏向胜利的一步星亮 玄破 剑断碎17.05.17俏如来梦虬孙蜃虹蜺10同志 敌人杀皇刃 夺桃镖 妖魔战启17.05.24上杉龙矢风间久护北冥华11龙与泷飞刃传噩17.05.31古辰雅久安倍博雅安倍博雅12业罪终途赎业斩罪17.06.07覆秋霜八紘稣浥霏泷13一刀断情碎心怒龙17.06.14紊劫刀狷螭狂梦虬孙14双龙决龙绝 名裂 亲毁17.06.21狷螭狂霏泷狷螭狂15悲情一战心碎 友诀 箭穿心17.06.28霏泷上杉龙矢上杉龙矢16决战 死战天雷破甲17.07.05月牙诚月牙诚立花雷藏17无法置信的结果惊见幽灵马 再现一嚣狂17.07.12梦虬孙砚寒清幽灵马车、黑白郎君18反击战狂人之怒17.07.19未珊瑚北冥异北冥异19战神斗狂人战浪狂涛17.07.26黑白郎君天地不容客天地不容客、黑白郎君20妖魔战 鬼胎生八雷绝杀17.08.02风间久护胧三郎胧三郎21无声的雷鸣雪燕 沉渊 天雷灭17.08.09立花雷藏胧三郎胧三郎22毒解真心命证真情17.08.16枭岳古辰雅久北冥皇渊23罗妖魔网舍命 镔碎 妖界启17.08.23网中人北冥华月牙诚24第九界魔甲异境17.08.30北冥异覆秋霜天地不容客25人鬼殊途天诀降邪17.09.06安倍博雅雪山银燕安倍博雅26凶燕狂龙 凶燕 战无双17.09.13雪山银燕风间始雪山银燕27凶狂血战杀生 求死 赎罪业17.09.20幽梅薄寒君昔苍白昔苍白28狂龙之战星爆暗流17.09.27八纮稣浥八纮稣浥、北冥皇渊欲星移29（无）九炼同灭 太虚尽毁17.10.04北冥皇渊北冥封宇北冥皇渊30坏孩子的复仇妖驰电击17.10.11木魅望月咲、幻姬重子木魅31决战之前黑夜 穿梭 英雄影17.10.18砚寒清梦虬孙黑白郎君32谁是顶峰酒吞戮世17.10.25赤羽信之介黑白郎君胧三郎 鬼途奇行录鬼途奇行录集数标题预告时间封面封底横幅01（无）酒吞称雄17.11.22胧三郎安倍博雅胧三郎02（无）玄影纵横17.11.29苍越孤鸣风中捉刀苍越孤鸣03阎王十部众鬼途飘渺17.12.06覆秋霜鸩罂粟任飘渺04不死之身绝命挑衅17.12.13风间始鲁玉鸩罂粟05血水城鬼谷战帖17.12.20李剑诗俏如来俏如来06黑暗的交易苦链锁魂17.12.27九冥杀神诸葛穷九冥杀神07狂人与豪杰剑刃纵横18.01.03步天踪殷若微御兵韬08阎王 诡图银槐争锋18.01.10御兵韬覆秋霜覆秋霜09向天借时 天下风云天刑审判18.01.17方之墨慕容胜雪方之墨10绝命司的真相狂豪对决18.01.24黑白郎君岳灵休慕容胜雪11绝命司 司绝命绝命围杀18.01.31魈毒童子别小楼殷若微12天下无墨 纵横一刀一刀纵横18.02.07别小楼绝命司（覆秋霜）别小楼13风雨故人绝命天定18.02.14白比丘魈毒童子、无患开膛安倍博雅14黑水城一剑无霜18.02.21锻神锋老爷丁凌霜15不亡的亡魂恩仇黎明18.02.28剑无极丁凌霜剑无极16封城之战一击取城18.03.07千雪孤鸣安倍博雅千雪孤鸣17血城干戈墨入豪劫18.03.14岳灵休白比丘凰后18消散的英灵鸿门恶宴18.03.21鸩罂粟榕桂菲玄冥19烽烟四起绝命阎罗18.03.28诸葛穷六隐神镞白比丘20顶峰之决王者殒落18.04.04凰后黑白郎君黑白郎君21换命交易向天抢时18.04.11风逍遥、无患开膛步清云风逍遥22侠侣同落难 天涯裹尸还鬼入阎途18.04.18俏如来尸叟钓烟波李剑诗23夜坠天崩人失向 星沉月落鬼埋霜绝命鸳鸯18.04.25（潮夕瑰霞、诗赋）李剑诗李剑诗、别小楼24长生血 及时雨恩断命绝18.05.02慕容宁玄冥鸩罂粟25逆命血亡水 仇霜随风明各怀鬼胎18.05.09六隐神镞慕容宁绝命司（岳灵休）26比丘尼的路 十三叔的剑鹬蚌杀机18.05.16随风起飞大仔慕容宁27漂萍不老花绝一无二18.05.23丁凌霜随风起修儒28一掌翻玄黄 天伦几浮沉魂断沄渊18.05.30步清云步天踪忆无心29阴阳一水 天人分垒绝命时刻18.06.06地宿剑无极诸葛穷30浑沌缈无极 双分日月明混沌阴阳18.06.13慕容胜雪天首天首31（无）战力全开18.06.20天首徐福（安倍博雅）（永生树）32最终一战亡命九界18.06.27胧三郎、徐福（安倍）别小楼、李剑诗胧三郎、徐福（安倍） 齐神箓齐神箓集数标题预告时间封面封底横幅01（无）风云再起18.08.29剑无极（天下风云碑）慕容烟雨、任飘渺、俏如来、苍越孤鸣、靳铅华、黑白郎君02天下风云争 江湖暗潮生神临天下18.09.05黑白郎君接天岚落拓子03小楼会星辰 烟雨见斜阳狼影刀 纵横决18.09.12千雪孤鸣别小楼千雪孤鸣04一剑震银槐 苦海任孤沉无相驭虚18.09.19任孤沉（斜阳）慕容烟雨05凰鸣巧木庭 一刀响风铃青萤飞露18.09.26风铃一刀声司马魁宗随风起06暗局赌风云 剑神会无双剑神无双18.10.03冷秋颜地宿任飘渺07（无）王者之决18.10.10六隐神镞祝武娘风铃一刀声08（无）诗仙飘渺18.10.17任飘渺李剑诗李剑诗09极端双峰会 裂羽断云飞裂羽断魂18.10.24凰后天首天首10一笔定春秋 鸿鹄向云飞折锋断笔18.10.31傅天行羚罕傅天行11遥星斗龙刃 刀啸风云巅刀落星殒18.11.07御兵韬别小楼步天君12覆掌掩波澜 怒剑震江山真神降临18.11.14靳铅华黑白郎君靳铅华13（无）全面启战18.11.21慕容宁苍越孤鸣天地不容客14乡途盈血泪 一箭泣魂归乡途血泪18.11.28丁凌霜步天君丁凌霜15心魔拳下收 真相险中求风中残刀18.12.05步天君枭岳风中捉刀16秀才行云帖 暗箭现踪影仇海孤沉18.12.12诸葛穷落拓子任孤沉17（无）剑神决18.12.19慕容烟雨任飘渺无双、斜阳18神笔点青萤 伞下现故人神笔赴天18.12.26梁皇无忌傅天行梁皇无忌19江湖飘血泪 一刀断生机血泪步天19.01.02地宿千雪孤鸣接天岚20烽烟修罗劫 渡世菩萨心摩罗再现19.01.09戮世摩罗任孤沉戮世摩罗21惊弦绽血红 追途一步终一箭绝命19.01.16祝武娘冷秋颜祝武娘22魔心寻物影 神旨法无穷妖魔摧神19.01.23公子开明梁皇无忌网中人23变局空遗恨 溯往觅前尘人狂胜天19.01.30网中人戮世摩罗黑白郎君24枪芒立争端 慕容傲骨寒慕容浩劫19.02.06接天岚慕容宁慕容宁25（无）剑神之怒19.02.13慕容胜雪慕容烟雨慕容烟雨26刀剑烽烟靖 风云恩仇泯心碎魂飞19.02.20向云飞凌风歌向云飞27儒丑迷风雨 剑雅莫离骚生死交易19.02.27元劫七丁凌霜俏如来28魔渡如来道 剑行天之韬仗义灭亲19.03.06司马魁宗莫离骚莫离骚29天允几烙名 无二九龙争天下第一19.03.13莫离骚俏如来天下风云碑30玄武非凡神 天下第一人真神现身19.03.20废苍生(齐天寿甲)废苍生31神降 天罚神净铅华19.03.27靳铅华靳铅华靳铅华32杀神三杰袭天19.04.03(无双 墨邪 笑藏刀)玄武真神靳铅华 战血天道金光御九界之战血天道集数标题预告时间01战血天道战血天道19.05.0202半生酆都 无常元帅杀神再临19.05.1603金刀寒雨 剑决仙舞金刀坠无常19.05.3004逆道违天 覆舟虚怀悲风凄雨19.06.1305剑行天道 八爻锁月剑行天道19.06.2706刀锋葬魂 无情葬月夜黑风高人葬月19.07.1107无常悲舞 浩星归流无常真身19.07.2508刀剑争耀 西风横笑剑绝刀亡19.08.0809剑现仙舞 难返蓬瀛星落云散19.08.2210雨落枫凋 云棋水镜凄风神啸19.09.0511紫微星降 一剑光寒逆天行道19.09.1912梦花浮萍 何处寄根鹰翼遮天19.10.0313星芒黯淡 无常胆寒颢星归天19.10.1714星河乱序 血神霸临（无）19.10.3115阴阳坠道 血染终途学海深仇19.11.1416镜遗天市 魂断太微风月无情19.11.2817毫无保留 醉生梦死血染尘嚣19.12.1218真假霸王 古今虞姬真假霸王19.12.2619星移物换 血染不绝血染不绝20.01.0920一语惊 现鬼谋一语惊 现鬼谋20.01.2321神君入戏 鬼帅登台霸王卸甲20.02.0622三足鼎立 两面受敌相星不灭20.02.2023血染终绝 黑龙现踪琴下祭雪20.03.0524还阳十九 胜天一筹黓龙策天20.03.1925一视同仁 弃子争先凄风寒雨20.04.0226四宗欲灭 泰玥皇锦浴火弑龙20.04.1627仙岛之谜 不速之客修罗入道20.04.3028手足无情 驰突孤燕手足无情20.05.1429路转峰回 天意难为墨剑穿燕20.05.2830孤燕之主 戏中人散（一）孤燕之主20.06.1131孤燕之主 戏中人散（二）冥海一琴20.06.2532九界沦陷苗疆浩劫20.07.09","tags":["剧集名称","金光"],"categories":["布袋戏"]},{"title":"清","path":"/p/e3e0261f/","content":"相见欢张惠言年年负却花期，过春时，只和安排愁绪送春归。梅花雪，梨花月，总相思。自是春来不觉去偏知。清 水调歌头·春日赋示杨生子掞张惠言长镵白木柄，劚破一庭寒。三枝两枝生绿，位置小窗前。要使花颜四面，和着草心千朵。向我十分妍。何必兰与菊，生意总欣然。晓来风，夜来雨，晚来烟。是他酿就春色，又断送流年。便欲诛茅江上，只恐空林衰草，憔悴不堪怜。歌罢且更酌，与子绕花间。清","tags":["清"],"categories":["唐宋元明清"]},{"title":"元","path":"/p/622d75cd/","content":"山高水长，物象万千。非有老笔，清壮何穷。 芦花被贯云石仆过梁山泊，有渔翁织芦花为被。仆尚其清，欲易之以绸者。翁曰：“君尚吴清，愿以诗输之。”遂赋，果却绸。采得芦花不涴尘，翠蓑聊复藉为茵。西风刮梦秋无际，夜月生香雪满身。毛骨已随天地老，声名不让古今贫。青绫莫为鸳鸯妒，欸乃声中别有春。元 蟾宫曲卢挚江城歌吹风流，雨过平山，月满西楼。几许年华，三生醉梦，六月清秋。按锦瑟佳人劝酒，卷珠帘齐按凉州。客去还留，云树萧萧，河汉悠悠。元曲","tags":["元"],"categories":["唐宋元明清"]},{"title":"唐","path":"/p/b54a1703/","content":"山高水长，物象万千。非有老笔，清壮何穷。 酬李穆见寄刘长卿孤舟相访至天涯，万转云山路更赊。欲扫柴门迎远客，青苔黄叶满贫家。唐诗 江楼夕望招客白居易海天东望夕茫茫，山势川形阔复长。灯火万家城四畔，星河一道水中央。风吹古木晴天雨，月照平沙夏夜霜。能就江楼消暑否？比君茅舍较清凉。唐诗 江亭夜月送别 · 其二王勃乱烟笼碧砌，飞月向南端。寂寞离亭掩，江山此夜寒。唐诗 田舍杜子美田舍清江曲，柴门古道旁。草深迷市井，地僻懒衣裳。榉柳枝枝弱，枇杷树树香。鸬鹚西日照，晒翅满鱼梁。唐诗 积雨辋川庄作王维积雨空林烟火迟，蒸黎炊黍饷东菑。漠漠水田飞白鹭，阴阴夏木啭黄鹂。山中习静观朝槿，松下清斋折露葵。野老与人争席罢，海鸥何事更相疑。唐诗 端居李商隐远书归梦两悠悠，只有空床敌素秋。阶下青苔与红树，雨中寥落月中愁。唐诗","tags":["唐"],"categories":["唐宋元明清"]},{"title":"宋","path":"/p/1a860096/","content":"山高水长，物象万千。非有老笔，清壮何穷。 诉衷情·七夕毛滂短疏萦绿象床低，玉鸭度香迟。微云淡暑河汉，凉过碧梧枝。秋韵起，月阴移，下帘时。人间天上，一样风光，我与君知。宋词 吉祥寺赏牡丹苏东坡人老簪花不自羞，花应羞上老人头。醉归扶路人应笑，十里珠帘半上钩。宋词 北陂杏花王安石一陂春水绕花身，花影妖娆各占春。纵被无情吹作雪，绝胜南陌碾作尘。宋词 赠刘景文苏子瞻荷叶已无擎雨盖，菊残犹有傲霜枝。一年好景君须记，正是橙黄橘绿时。宋词 虞美人陈与义扁舟三日秋塘路，平度荷花去。病夫因病得来游，更值满川微雨洗清秋。去年长恨拏舟晚，空见残荷满。今年何以报君恩，一路繁花相送过青墩。宋词 鄂州南楼書事黄庭坚四顾山光接水光，凭栏十里芰荷香。清风明月无人管，并作南楼一味凉。宋词 南歌子张先蝉抱高高柳，莲开浅浅波。倚風疏叶下庭柯。况是不寒不暖，正清和。浮世欢会少，劳生怨别多。相逢休惜醉颜酡。赖有西园明月，照笙歌。宋词 初秋俞桂火老金柔暑告残，乘凉正好望西山。秋声来处无寻觅，只作窗前竹叶间。宋 村居书喜陆游红桥梅市晓山横，白塔樊江春水生。花气袭人知骤暖，鹊声穿树喜新晴。坊厂酒贱贫犹醉，原野泥深老亦耕。最喜先期官赋足，经年无吏扣柴荆。宋 题画李唐云里烟村雨里滩，看之容易作之难。早知不入时人眼，多买胭脂画牡丹。宋诗 九日次韵王巩苏东坡我醉欲眠君罢休，已教从事到青州。鬓霜饶我三千丈，诗律输君一百筹。闻道郎君闭东阁，且容老子上南楼。相逢不用忙归去，明日黄花蝶也愁。宋诗 春游王令春城儿女纵春游，醉倚层台笑上楼。满眼落花多少意，若何无个解春愁？宋诗","tags":["宋"],"categories":["唐宋元明清"]},{"title":"明","path":"/p/e1b6db35/","content":"滚滚长江东逝水，浪花淘尽英雄。是非成败转头空，青山依旧在，几度夕阳红。 白发渔樵江渚上，惯看秋月春风。一壶浊酒喜相逢，古今多少事，都付笑谈中。","tags":["明"],"categories":["唐宋元明清"]},{"title":"Vsocde、Fleet配置备份","path":"/p/9e8f8686/","content":"自用的 VsCode（1.72~lasted） 配置备份，Plugin 部分需安装对应的插件才可生效。 VsCodesettings.json123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162&#123; // ########################### 编辑器配置 ############################ // 字体及字体大小，设置的字体本机需要安装才能生效 // 如果有空格或者中文，尽量使用 单引号 括住 &quot;editor.fontFamily&quot;: &quot;&#x27;Fira Code&#x27;, &#x27;文泉驿微米黑&#x27;&quot;, &quot;editor.fontSize&quot;: 16, // 启用连字 &quot;editor.fontLigatures&quot;: true, // 设置行高 &quot;editor.lineHeight&quot;: 23, // 字母间像素 &quot;editor.letterSpacing&quot;: 0.5, // tab 缩进大小 &quot;editor.tabSize&quot;: 4, // 保存时自动格式化内容 &quot;editor.formatOnSave&quot;: true, // 彩色括号对 &quot;editor.guides.bracketPairs&quot;: &quot;active&quot;, // ########################### 文件配置 ########################### // 1s 后自动保存文件内容 &quot;files.autoSave&quot;: &quot;afterDelay&quot;, // 要想 autoSaveDelay 生效，上面的设置必须为 afterDelay，否则不生效 &quot;files.autoSaveDelay&quot;: 1000, // ########################### 终端设置 ########################### // 光标样式 &quot;terminal.integrated.cursorStyle&quot;: &quot;line&quot;, &quot;terminal.integrated.cursorWidth&quot;: 2, &quot;terminal.integrated.cursorBlinking&quot;: true, // 鼠标右键：控制是否将在终端中选定的文本复制到剪贴板。 &quot;terminal.integrated.copyOnSelection&quot;: true, // 鼠标右键：控制终端如何回应右键单击操作。copyPaste: 当有选定内容时复制，否则粘贴。 &quot;terminal.integrated.rightClickBehavior&quot;: &quot;copyPaste&quot;, // 设置默认打开的终端类型，Linux ? zsh : PowerShell // &quot;terminal.integrated.defaultProfile.linux&quot;: &quot;zsh&quot;, // &quot;terminal.integrated.defaultProfile.windows&quot;: &quot;PowerShell&quot;, // 浪子喜欢在 Win 下使用 Git Bash &quot;terminal.integrated.profiles.windows&quot;: &#123; // 命名可自定义，在 terminal.integrated.defaultProfile.windows 处填写自定义名即可 &quot;Git-Bash&quot;: &#123; &quot;path&quot;: &quot;D:\\\\xxxx\\\\Git\\\\bin\\\\bash.exe&quot;, &quot;args&quot;: [], &quot;icon&quot;: &quot;terminal-bash&quot; &#125; &#125;, // 此处填写上面的自定义名称 Git-Bash &quot;terminal.integrated.defaultProfile.windows&quot;: &quot;Git-Bash&quot;, // ########################### JavaScript ########################### // 启用或禁用在 VS Code 中重命名或移动文件时自动更新导入路径的功能。always：一直自动更新 &quot;javascript.updateImportsOnFileMove.enabled&quot;: &quot;always&quot;, // ########################### md ########################### // 开启 markdown 的验证 无效链接将被警告或者错误 &quot;markdown.validate.enabled&quot;: true, // 开启 markdown 的用户代码片段，在 md 中也可以使用代码片段啦 &quot;[markdown]&quot;: &#123; &quot;editor.renderWhitespace&quot;: &quot;all&quot;, &quot;editor.quickSuggestions&quot;: &#123; &quot;comments&quot;: &quot;on&quot;, &quot;strings&quot;: &quot;on&quot;, &quot;other&quot;: &quot;on&quot; &#125;, &quot;editor.acceptSuggestionOnEnter&quot;: &quot;on&quot; &#125;, // ########################### 编辑器配置 end ######################## // ########################################################################## // ########################################################################## // ############################# Plugin start ############################### // ########################################################################## // ########################################################################## // vscode 主题设置 (Shades of Purple插件) &quot;workbench.colorTheme&quot;: &quot;Shades of Purple&quot;, // markdown-preview-enhanced 配置 (Markdown Preview Enhanced插件) &quot;markdown-preview-enhanced.codeBlockTheme&quot;: &quot;default.css&quot;, &quot;markdown-preview-enhanced.previewTheme&quot;: &quot;vue.css&quot;, &quot;markdown-preview-enhanced.printBackground&quot;: true, // Draw.io Integration 配置：添加自定义字体选项、设置默认主题（Draw.io Integration插件） &quot;hediet.vscode-drawio.customFonts&quot;: [ &quot;JetBrains Mono&quot;, &quot;Fira Code&quot;, &quot;文泉驿微米黑&quot; ], &quot;hediet.vscode-drawio.theme&quot;: &quot;Kennedy&quot;, // 安装 PicGo 软件，使用 PicGo 插件只需要配置一个 configPath // 本机安装了 PicGo 客户端第一次启动后会自动生成 json 文件 // &quot;picgo.configPath&quot;: &quot;C:\\\\Users\\\\你的用户名\\\\AppData\\\\Roaming\\\\picgo\\\\data.json&quot;, // 上面的选项如果配置了，下面的无须配置（前提是安装了客户端软件）。 // 只使用 VsCode PicGo 插件，需要配置以下信息 // 当前使用图床 可选：weibo, qiniu, tcyun, upyun, github, aliyun, imgur and SM.MS &quot;picgo.picBed.current&quot;: &quot;github|weibo|qiniu|tcyun|upyun|aliyun|imgur|SM.MS&quot;, &quot;picgo.picBed.uploader&quot;: &quot;github|weibo|qiniu|tcyun|upyun|aliyun|imgur|SM.MS&quot;, // 设定分支 &quot;picgo.picBed.github.branch&quot;: &quot;main&quot;, // 设定仓库 &quot;picgo.picBed.github.repo&quot;: &quot;&quot;, // token &quot;picgo.picBed.github.token&quot;: &quot;&quot;, // 自定义返回的链接 &quot;picgo.picBed.github.customUrl&quot;: &quot;&quot;, // 上传路径 &quot;picgo.picBed.github.path&quot;: &quot;&quot;, // Java 配置 Extension Pack for Java、Gradle for Java、Spring Boot Tools、Spring Initializr Java Support 插件 &quot;java.configuration.runtimes&quot;: [ &#123; // 名称，随便起，多个的话必须唯一 &quot;name&quot;: &quot;JavaSE-17&quot;, // jdk 路径，配置环境变量的路径 &quot;path&quot;: &quot;/usr/lib/jvm/java-17-openjdk&quot;, // 源码路径 &quot;sources&quot;: &quot;/usr/lib/jvm/java-17-openjdk/lib/src.zip&quot;, // VsCode 默认使用这个版本的 jdk &quot;default&quot;: true, &#125;, &#123; &quot;name&quot;: &quot;JavaSE-1.8&quot;, &quot;path&quot;: &quot;/usr/lib/jvm/java-8-openjdk&quot;, &quot;sources&quot;: &quot;/usr/lib/jvm/java-8-openjdk/src.zip&quot; &#125;, ], // java 文件自动组织导入的包 &quot;java.saveActions.organizeImports&quot;: true, // vscode 包结构展示效果 flat：平面；hierarchical：分层 &quot;java.dependency.packagePresentation&quot;: &quot;hierarchical&quot;, // 不使用 gradle-wrapper.properties 的 gradle &quot;java.import.gradle.wrapper.enabled&quot;: false, // 设置默认的 gradle 版本 &quot;java.import.gradle.version&quot;: &quot;7.6&quot;, // 本地 gradle 路径 &quot;java.import.gradle.home&quot;: &quot;/home/xxx/software/gradle-7.6&quot;, &quot;java.import.gradle.java.home&quot;: &quot;/usr/lib/jvm/java-17-openjdk&quot;, // GRADLE_USER_HOME 路径 &quot;java.import.gradle.user.home&quot;: &quot;/home/xxx/software/gradle-repo/&quot;, // ########################### Maven 配置 ########################### // settings.xml 路径 &quot;java.configuration.maven.globalSettings&quot;: &quot;/home/xxx/software/maven-3.9.0/conf/settings.xml&quot;, // maven 执行文件路径 &quot;maven.executable.path&quot;: &quot;/home/xxx/software/maven-3.9.0/bin/&quot;, // maven 命令默认选项：跳过测试 &quot;maven.executable.options&quot;: &quot;-o -DskipTests&quot;, // ########################################################################## // ########################################################################## // ############################# 插件配置 end ################################ // ########################################################################## // ##########################################################################&#125; Fleet配置参见官网：https://www.jetbrains.com/help/fleet/settings.html#user-settings settings.json12345678910111213141516171819202122232425262728293031323334353637&#123; // 主题 &quot;theme&quot;: &quot;dark_purple&quot;, // 字体大小 &quot;editor.fontSize&quot;: 16.0, // 保存时格式化文本 &quot;editor.formatOnSave&quot;: true, // 使用组合键键时显示所用组合键 &quot;showShortcuts&quot;: true, // 快捷键映射，这里采用了 vscode 的 &quot;keymap&quot;: &quot;pc-vscode&quot;, // ############# 终端配置 ############# &quot;terminal.profiles&quot;: [ &#123; &quot;program&quot;: &quot;D:\\\\software\\\\Git\\\\bin\\\\bash.exe&quot;, &quot;args&quot;: [], // optional &quot;name&quot;: &quot;git-bash&quot; // optional &#125; ], // 终端：复制选中文本 &quot;terminal.copyOnSelection&quot;: true, // 终端字体大小 &quot;terminal.fontSize&quot;: 15.0, // ############# Java ############## &quot;maven.user.settings&quot;: [ &#123; &quot;path&quot;: &quot;D:\\\\xxx\\\\Java\\\\maven-3.9.0\\\\conf\\\\settings.xml&quot; &#125; ], &quot;java.runtimes&quot;: [ &#123; &quot;path&quot;: &quot;D:\\\\xxx\\\\Java\\\\jdk1.8.0_361&quot; &#125; ],&#125;","categories":["配置备份"]},{"title":"VsCode代码片段备份","path":"/p/7fc7cf56/","content":"VsCode 代码片段备份。 Javacode-snippets1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// ###################### Hexo Stellar 主题标签代码片段 ##########################\t&quot;hexo-stellar-label&quot;: &#123; &quot;scope&quot;: &quot;markdown&quot;, &quot;prefix&quot;: &quot;label&quot;, &quot;body&quot;: [ &quot;&#123;% $&#123;1:label-name&#125; %&#125; $2&quot;, ], &quot;description&quot;: &quot;generator stellar theme label template&quot;\t&#125;,\t&quot;hexo-stellar-image&quot;: &#123; &quot;scope&quot;: &quot;markdown&quot;, &quot;prefix&quot;: &quot;md-img&quot;, &quot;body&quot;: [ &quot;&#123;% image $&#123;1:src&#125; $&#123;2:desc&#125; width:$&#123;3:宽度（可选）&#125; bg:$&#123;4:背景（可选）&#125; %&#125;&quot;, ], &quot;description&quot;: &quot;generator stellar theme image template&quot;\t&#125;,\t&quot;hexo-stellar-link&quot;: &#123; &quot;scope&quot;: &quot;markdown&quot;, &quot;prefix&quot;: &quot;md-link&quot;, &quot;body&quot;: [ &quot;&#123;% link $&#123;1:href&#125; $&#123;2:title&#125; %&#125;&quot;, ], &quot;description&quot;: &quot;generator stellar theme link template&quot;\t&#125;,\t&quot;hexo-stellar-copy&quot;: &#123; &quot;scope&quot;: &quot;markdown&quot;, &quot;prefix&quot;: &quot;md-cp&quot;, &quot;body&quot;: [ &quot;&#123;% copy $&#123;1:content&#125; %&#125;&quot;, ], &quot;description&quot;: &quot;generator stellar theme link template&quot;\t&#125;,\t&quot;hexo-stellar-mark&quot;: &#123; &quot;scope&quot;: &quot;markdown&quot;, &quot;prefix&quot;: &quot;md-mark&quot;, &quot;body&quot;: [ &quot;&#123;% mark $&#123;1:content&#125; color:$&#123;2:green&#125; %&#125;&quot;, ], &quot;description&quot;: &quot;generator stellar theme mark template, support red|orange|yellow|green|cyan青|blue蓝|purple|light|dark|warning|error&quot;\t&#125;,\t&quot;hexo-stellar-poetry&quot;: &#123; &quot;scope&quot;: &quot;markdown&quot;, &quot;prefix&quot;: &quot;md-poetry&quot;, &quot;body&quot;: [ &quot;&#123;% poetry $&#123;1:title&#125; author:$&#123;2:author&#125; footer:$&#123;3:页脚&#125; %&#125;&quot;, &quot;$4&quot;, &quot;&#123;% endpoetry %&#125;&quot; ], &quot;description&quot;: &quot;generator stellar theme poetry template&quot;\t&#125;// ########################################################// ######################### Java #########################// ########################################################&#123; &quot;log info&quot;: &#123; &quot;scope&quot;: &quot;java&quot;, &quot;prefix&quot;: &quot;logi&quot;, &quot;body&quot;: [ &quot;log.info(\\&quot;$1\\&quot;, $2)&quot; ], &quot;description&quot;: &quot;generator java log.info()&quot;\t&#125;,\t&quot;log error&quot;: &#123; &quot;scope&quot;: &quot;java&quot;, &quot;prefix&quot;: &quot;loge&quot;, &quot;body&quot;: [ &quot;log.error(\\&quot;$1\\&quot;, $2)&quot; ], &quot;description&quot;: &quot;generator java log.error()&quot;\t&#125;,\t&quot;log debug&quot;: &#123; &quot;scope&quot;: &quot;java&quot;, &quot;prefix&quot;: &quot;logd&quot;, &quot;body&quot;: [ &quot;log.debug(\\&quot;$1\\&quot;, $2)&quot; ], &quot;description&quot;: &quot;generator java log.debug()&quot;\t&#125;,\t&quot;java doc&quot;: &#123; &quot;scope&quot;: &quot;java&quot;, &quot;prefix&quot;: &quot;jdoc&quot;, &quot;body&quot;: [ &quot;/**&quot;, &quot; *&quot;, &quot; * @author $&#123;1:user&#125;&quot;, &quot; * @since 1.0.0&quot;, &quot; */&quot; ], &quot;description&quot;: &quot;generator java class basic info&quot;\t&#125;,&#125; 生成时间方式：@date $&#123;CURRENT_YEAR&#125;-$&#123;CURRENT_MONTH&#125;-$&#123;CURRENT_DATE&#125; $&#123;CURRENT_HOUR&#125;:$&#123;CURRENT_MINUTE&#125;:$&#123;CURRENT_SECOND&#125;","categories":["配置备份"]},{"title":"Hello World","path":"/p/4a17b156/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"Window问题集锦","path":"/p/f085fb33/","content":"Windows 使用小窍门，可以帮助你提高效率。 一、快捷方式 目标 操作 控制面板 win + r 输入 appwiz.cpl 回车 系统变量 win + r 输入 sysdm.cpl 回车 磁盘管理 win + r 输入 diskmgmt.msc 回车 服务 win + r 输入 services.msc 回车 电脑信息 win + r 输入 winver 回车 二、删除开机多余启动项Win + R，输入 `msconfig`，点击确定，选择 “引导” 标签，选择 **非当前OS** 记录，点击删除并应用，按照提示重启即可。 管理员方式进入 ps： 1234# 查看启动项efibootmgr# 删除对应的项efibootmgr -b 0001(序号) -B 三、PowerShell运行脚本管理员身份运行ps， 12# 输入以下命令，选择 Yset-executionpolicy RemoteSigned ps 有四种策略： 策略 说明 Restricted 禁止运行任何脚本配置文件（默认） AllSigned 可以运行发布签名的脚本和配置文件，包括本地计算机上编写的脚本 RemoteSigned 要求从网络上下载的脚本和配置文件由可信者发布签名，不要求本地计算机上编写的脚本进行签名 Unrestricted 可以运行未签名的脚本 Edge 快捷键Ctrl + Shift + 0","categories":["Window"]},{"title":"Stellar主题标签效果测试","path":"/p/f320e422/","content":"Stellar 主题标签的效果测试。此效果与写法格式为 Stellar 1.18.5 版本。 我很喜欢你 像风走过八百里地 不问归期 青梅煮酒论天下 一、Note标签测试（带标题与不带标题） 我这一辈子，苦没有真正苦过，爱没有用力爱过。每天受着信息大潮的冲击，三观未定又备受曲折。贫穷不再是正义，又妄图不让金钱成为唯一的追求。过早看到了更大的世界，勤奋却又不过三天。热血透不过键盘和屏幕，回忆止于游戏和高考。像一群没有根的孩子，在别人的经历和精神里吵闹 换行测试(实际采用换行写法，可以看到下面内容并没有换行)我这一辈子，苦没有真正苦过，爱没有用力爱过。 每天受着信息大潮的冲击，三观未定又备受曲折。 贫穷不再是正义，又妄图不让金钱成为唯一的追求。 过早看到了更大的世界，勤奋却又不过三天。 热血透不过键盘和屏幕，回忆止于游戏和高考。 像一群没有根的孩子，在别人的经历和精神里吵闹 苍云有人居庙堂，有人守边疆。 个人推荐使用 ablock 标签代替 note，如果很简单的情况：例如 md 文件的引用 &gt; 可以使用 note. 二、ablock标签测试 ablock 标签测试我这一辈子，苦没有真正苦过，爱没有用力爱过。每天受着信息大潮的冲击，三观未定又备受曲折。贫穷不再是正义，又妄图不让金钱成为唯一的追求。过早看到了更大的世界，勤奋却又不过三天。热血透不过键盘和屏幕，回忆止于游戏和高考。像一群没有根的孩子，在别人的经历和精神里吵闹。 三、ablock + tabs 嵌套标签测试 代码彩色代码块rust123456789struct User &#123; name: String, age: i32,&#125;impl User &#123; pub fn new(name: String, age: i32) -&gt; User &#123; ... &#125;&#125;123async function getResponse() &#123; ...&#125;1public static final ConcurrentHashMap map = null; 四、单独 codeblock 标签测试 color:red1public static final ConcurrentHashMap map = null; 五、grid 分侧普通标签 任凭世人笑我癫狂叹红尘游世间空悬北斗点将勺运筹群星指天枢 六、grid 分侧卡片标签 没有决断之心的舍弃过往，不过是故作姿态罢了神蛊温皇要毁，不但要毁掉过去，还有现在、未来。 七、folding 折叠块标签测试 隐藏起来的块你看到了嘛fn main { println!(“{}”, “Hello World”)} 五、timeline 时间线标签 2022 年 10 月 28 日在加班2022 年 10 月 29 日在加班2022 年 10 月 30 日在加班 六、swiper 轮播标签 七、单选、复选样式标签 没有勾选的单选框 已勾选的单选框 没有勾选的复选框 undefined 加号的绿色的已勾选的复选框 显示为减号的黄色的已勾选的复选框 显示为乘号的红色的已勾选的复选框 八、folders 折叠组 你最喜欢的食物辣椒你最喜欢的人女神你最喜欢的事coding","tags":["hexo","stellar主题效果"],"categories":["Hexo"]},{"title":"Window中使用VMware的一些常见问题","path":"/p/13fda3d/","content":"虽然 Win 下的 WSL 非常好用，但是浪子还是比较喜欢使用 Vmware 创建 Linux 环境，虽然它很吃内存。。。 Vmware 虚拟机配置双网卡VMWare虚拟机配置双网卡 使用 VMWare 时，推荐创建的虚拟机配置双网卡，默认的使用 NAT 模式，新添加一个使用 仅主机 模式，然后进行修改配置。这样就算以后连接无数个无线网，电脑依然能上网，但是使用 SSH 远程连接时依然不用修改 Linux 的网络配置文件。实现了一次配置，永久使用的效果。配置也很简单： 在 VMWare 里创建一个虚拟机后，打开改虚拟机的设置，硬件下方的”添加“，然后在弹出的列表里选择”网络适配器“，之后点击新添加的网络适配器，选择”仅主机“。 然后打开网络适配器修改 VMWare Network Adapter VMnet1 的 IP 为简单的地址，Linux 里的网络配置文件的 IP 地址不要和这个一样，因为 VM1 是本机和 Linux 虚拟机通信的 IP 地址，不能一样，推荐 VM1 10.0.0.1，Linux 配置为 10.0.0.2，简单好记。 注意： 如果是新建的虚拟机，在安装之前按照以上方法配置，安装后查看网络配置文件时或许会有两个不同的文件，比如：ens33，ens34。如果是之前已经安装过的单网卡想要配置双网卡，可以把已经存在网络配置文件复制一份，修改文件里面的内容即可。如果新建的虚拟机也是只有一个配置文件，也可以直接复制原有的文件进行修改。 另外，第一次安装后网络服务是正常的，之后换了一个无线网连接就出现了问题，可能是因为 NetworkManager 的问题，可以关闭此服务。然后重启网络。内网相通，但使用 xshell 等终端工具连不上虚拟机也连不上外网也可以尝试使用这个方法。 12345678# 关闭服务systemctl stop NetworkManager# 禁止开机启动systemctl disable NetworkManager# chkconfig NetworkManager off# 重启网络systemctl restart network 参考文章地址https://blog.csdn.net/weistin/article/details/80676955 虚拟机可以ping通本机，本机ping不通虚拟机如果使用的是 NAT 模式，不在同一个网段也可以 ping 通。因为当你的网络连接变了之后（从连 wifi 到使用网线），本机的 IP 网络也会随之更改，所以需要确认一边。设置完成记得重启。 使用其它SSH工具连接虚拟机如果是 22.04 版本的 ubuntu-server 版本，其内置了 ufw 工具（最小安装可能没有）。可以使用 sudo ufw disable 关闭防火墙，或者开放 22 端口：sudo ufw allow 22。 虚拟机centos7 问题描述：用的好好的虚拟机，之前内网都通，突然xshell连不上虚拟机了也连不上外网了，这时候怎么办呢？ 解决方法： 12345# 1.将networkmanager服务停掉systemctl stop NetworkManagersystemctl disable NetworkManager# 2.重启网卡systemctl restart network 原博客地址","categories":["Window"]},{"title":"Window 开发环境配置","path":"/p/a35e2b34/","content":"Window 开发环境配置整理。 环境配置Window 的环境变量配置非常简单。它分为用户变量和系统变量，配置系统变量使用任何用户登录系统都可以使用相关的命令；如果添加的是用户变量，那么只有添加变量的当前用户才能使用该命令，本文都以配置系统变量为例。 配置系统变量一般有两种方式： 直接在 Path 里配置（一般配置到 bin 目录）。 新建一个系统变量，设置 key-value，之后在 Path 中引用 %key% 。 1. JDKkey: JAVA_HOMEvalue: D:\\software\\javaPath: %JAVA_HOME%\\bin key: CLASSPATHvalue: .;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jarPath: %JAVA_HOME%\\binps 测试安装是否成功：java -version Tip： jdk1.5以后CLASSPATH可以不用再进行设置; 2. Mavenkey: M2_HOMEvalue: D:\\software\\maven-3.8.6Path: %M2_HOME%\\binps 测试安装是否成功：mvn -version 配置阿里源 .../maven-3.8.6/maven/conf/setting.xml123456&lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;阿里云公共仓库&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;&lt;/mirror&gt; 3. Gradlekey: GRADLE_HOMEvalue: D:\\software\\gradle-7.5Path: %GRADLE_HOME%\\binps 测试安装是否成功：gradle -version 配置下载源； .../gradle-7.6/init.d/init.gradle1234567891011allprojects &#123;\trepositories &#123; // 本地仓库 mavenLocal() // 镜像仓库 maven &#123; url &#x27;https://maven.aliyun.com/repository/public/&#x27; &#125; maven &#123; url &#x27;https://maven.aliyun.com/repository/spring/&#x27; &#125; // maven 中央仓库 mavenCentral() &#125;&#125; gradle加载顺序123456789101112# 排列顺序即加载顺序 * 代表可以为任意名称~/.gradle/init.gradle~/.gradle/init.d/*.gradleGRADLE_HOME/init.d/*.gradleGRADLE_USER_HOME/init.gradleGRADLE_USER_HOME/init.d/*.gradle# Gradle 查找依赖的顺序# M2_HOME 是 Maven 的配置~/.m2/settings.xmlM2_HOME/conf/settings.xml~/.m2/repository 由于 IDEA 中的 Gradle 经常自动下载，建议设置环境变量 GRADLE_USER_HOME，这样自动下载的 gradle 就会自动安装到这个目录。 4. MySQL使用安装文件（exe 或者 msi）安装一般没有什么问题，安装过程中会提示将安装路径加入环境变量。 这里只介绍使用 压缩包 的方式。 key: MYSQL_HOMEvalue: D:\\software\\MySQL8.0Path: %MYSQL_HOME%\\bin 管理员身份运行 cmd、ps、cmder 等工具： 1234567891011121314151617# service-name 自己命名，如果不写默认为 mysql，只安装一个版本的话推荐不指定# 在安装多个 MySQL 版本的时候很有用mysqld --install service-name# 移除 MySQL 服务mysqld --remove service-name# 使用不安全的初始化（即不生成初始密码）mysqld --initialize-insecure --user=mysql --console# 如果需要生成初始化密码，则使用以下命令。--console 选项把生成的密码打印到控制台mysqld --initialize --user=mysql --console# 启动 MySQL 服务net start service-name# 进入 MySQL bashmysql -u root -p# 修改密码alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;&#x27;; TIP：安装多个 MySQL 版本记得修改端口号再初始化（即生成 data 目录） 5. MariaDB依然使用 压缩包 安装。 key: MARIA_HOMEvalue: D:\\software\\mariadb-10.9.3Path: %MARIA_HOME%\\bin 管理员身份运行 cmd、shell 等命令行工具： D:\\software\\mariadb-10.9.3\\bin123456# 名称自己起mysqld.exe --install mariadb&lt;service-name&gt;# 初始化数据库，生成 data 文件夹以及配置信息mysql_install_db# 启动net start mariadb(上面安装时起的名称) 配置文件（如果本机安装之前还有 MySQL 数据库，推荐解压后先修改配置文件，更改默认端口）： mariadb-10.9.3/data/my.ini1234567891011121314151617181920212223242526[mysqld]datadir=D:/software/mariadb-10.9.3/dataport = 3333character-set-server = utf8mb4collation-server = utf8mb4_general_ciskip-character-set-client-handshake[client]plugin-dir=D:\\software\\mariadb-10.9.3/lib/plugin; 客户端连接端口port=3333[mariadb]feedback=off; 指定端口port = 3333; 默认创建数据库的类型default-storage-engine = InnoDB; 最大连接数max_connections = 100; 慢查询slow_query_log_file = slow.logslow_query_log = 0log_queries_not_using_indexes = 1long_query_time = 0.5min_examined_row_limit = 100 如果本机已经安装了 MySQL 数据库，那么使用这种方式安装在初始化数据库后，应该先修改 my.ini 文件，修改端口号，然后启动服务。FEEDBACK 启动成功但是连接失败官方说明：https://mariadb.com/kb/en/feedback-plugin/配置文档：https://mariadb.com/kb/en/configuring-mariadb-with-option-files/Unicode 排序规则：https://www.monolune.com/articles/mysql-utf8-charsets-and-collations-explained/ 6. PostgreSQL压缩包下载，这里选择了 15 版本。 Path：D:\\software\\pgsql\\bin 管理员身份运行 cmd、shell 等命令行工具： D:\\software\\pgsql\\bin1234567891011# 初始化 initdb --help 查看帮助信息# -D data 指定初始化的数据库目录(此处为当前目录的data文件夹)# -E utf8 数据库编码格式# -U postgres 超级管理员名称# -A 使用密码授权initdb.exe -D &quot;D:\\software\\pgsql\\data&quot; -E UTF8 -U postgres -W# 注册服务 -N 指定服务名称pg_ctl register -N &quot;postgresql&quot; -D &quot;D:\\software\\pgsql\\data&quot;# 启动pg_ctl -D &quot;D:\\software\\pgsql\\data&quot; -l logfile start 如果使用最新版本推荐使用官方提供的客户端 pgAdmin4，可在设置中调整为中文界面(缺点就是响应较慢)，Navicat 15.x 连接时报错 ”datlastsysoid“ 字段不存在，估计需要 Navicat 16 吧。pgsql 的配置文件在 data 文件夹中 pgAdmin4界面示例 7. TomcatTomcat 有安装版和压缩包两种，如果是安装版，需要先配置好jdk。 变量名：CATALINA_HOME变量值示例：D:\\software\\tomcat8.5Path：%CATALINA_HOME%\\bin。 Tomcat启动的日志输出的默认字符集编码是 utf-8，但是 window 的 shell 是 gbk 编码，所以如果想要在 window 下正常输出，就要修改 Tomcat 的日志打印编码。编辑tomcat安装路径下的 conf/logging.properties 文件,找到以下内容并修改为：java.util.logging.ConsoleHandler.encoding = GBK，保存重启即可。 8. NodeJs安装 NodeJs 后，Window 需要修改安装目录的权限，不然只有管理员才能对目录下的文件等进行操作，对于当前用户是非常不方便的。而且当你使用 npm 的时候会报错，提示没有权限。 在安装目录即 nodejs 文件夹，点击右键，选择属性，点击 “安全” 标签，选择 “User” 用户，点击编辑，把权限都勾上，保存退出。 12345678# 配置阿里镜像源npm config set registry https://registry.npmmirror.com# 设置全局安装目录（需要先手动创建）npm config set prefix &quot;D:\\software odejs ode_global&quot;# 设置全局缓存目录（需要先手动创建）npm config set cache &quot;D:\\software odejs ode_cache&quot;# 查看修改是否成功npm config ls -l 修改成功之后，在 path 中加入 D:\\software odejs ode_global 路径。这样，使用 全局安装 的工具（例如 yarn、pnpm 等）就可以在任何路径下使用了。 9. Jetty官方文档https://www.eclipse.org/jetty/documentation/jetty-11/operations-guide/index.html 下载后解压，之后进入 jetty 的安装目录。运行以下命令($JETTY_HOME 是安装目录)： 12345678910# 为当前基目录添加标准文件及文件夹java -jar $JETTY_HOME/start.jar --add-to-startd=http,deploy# 创建demo演示，不然启动后是404页面java -jar $JETTY_HOME/start.jar --add-module=demo# 启动jetty服务java -jar $JETTY_HOME/start.jar# 如果不想用8080，可以使用以下命令在启动时动态修改# 也可以修改配置文件，使其永久生效java -jar $JETTY_HOME/start.jar jetty.http.port=9999 之后就可以在浏览器使用 localhost:9999 进行访问了。 10. Gokey: GOROOT，value：D:\\software\\gokey:GOPATH，value:D:\\Projects\\GoProjects Path：%GOROOT%\\bin检验：go env 使用 Vscode 安装 Go 插件的话，速度感人，可以参考：https://goproxy.io/zh/ 11. RustRust 安装参考：https://course.rs/first-try/installation.html 替换下载依赖源： .../.cargo/config.toml12345[source.crates-io]replace-with = &#x27;ustc&#x27;[source.ustc]registry = &quot;https://mirrors.ustc.edu.cn/crates.io-index&quot; 插件1. 油猴插件 网盘链接检查：(自动识别并标记百度云、蓝奏云、腾讯微云和天翼云盘的链接状态) 网盘直链下载助手 链接助手 Github 增强 - 高速下载 CSDN&#x2F;知乎&#x2F;哔哩哔哩&#x2F;简书免登录去除弹窗广告 2. Edge 可可翻译 JSON Beautifier &amp; Editor AdGuard 广告拦截器 Greenhub绿墙—网络出海工具 文件蜈蚣（需要安装对应的软件） 图片下载 Replace Google CDN 细滚动条设置（默认长方形）：打开 Edge，URL地址输入 “edge:&#x2F;&#x2F;flags”，进入页面搜索 “Windows 11 fluent scrollbars.”，点击选择框选择 Enabled，重启浏览器（仅限 win 平台）。 3. 火狐 沉浸式翻译 可可翻译 Browse.live Circle 阅读助手基础版 火狐新版本默认在当前标签页中选择收藏夹的标签单击打开会覆盖当前页，浪子还是喜欢以前的打开新标签页，可以进行设置：地址栏输入 about:config 回车，查询 browser.search.openintab、browser.urlbar.openintab、browser.tabs.loadBookmarksInTabs 三个选项的值都设置为 true 即可。 4. IDEA Generate All Getter And Setter Log Support 2 MyBatisPlus Translation 推荐使用 2021.2.2 及以下版本。 5. Git-Bash 使用 tree 命令下载tree的二进制文件 后解压，把 bin 目录下的 tree.exe 文件复制到 Git 安装目录 xxx\\Git\\usr\\bin\\ 下即可。 如果想要在 git-bash 中使用 ll 命令，可以在 C:\\Users\\yourname 下创建新文件 .bashrc，有的话就不用创建了，在该文件中加入以下内容保存退出： .bashrc1alias ll=&#x27;ls -al&#x27;","tags":["win","环境配置"],"categories":["Window"]},{"title":"数据结构","path":"/p/79666db/","content":"对于数据结构的理解和学习，浪子建议扔掉自己掌握的语言的相关实现。所谓数据结构，是一种抽象化的存储数据的结构，它是一种抽象的概念，数据结构最最重要的是它的特性，特性决定了我们在开发中的选择，进而影响程序的运行效率和占用空间。学好数据结构的相关知识，开发中在合适的地方采用合适数据结构，能够让我们的程序更好的运行。 一、 线性表 顺序表 特点（随机存取） 顺序表优缺点 链表 特点（顺序存取） 链表优缺点 二、了解数据结构:链表 2.1 单链表 2.2 双链表 2.3 循环链表 三、栈 四、队列 五、字符串、数组、广义表 六、树 七、二叉树 7.1 二叉树性质 7.2 两种特殊的二叉树 （1） 满二叉树 （2） 完全二叉树 完全二叉树的性质 7.3 二叉树的存储结构 7.4 二叉树遍历方式 八、树和森林 8.1 树与二叉树的转换 将树转换成二叉树 将二叉树转换成树 8.2 森林与二叉树的转换 森林转为二叉树 二叉树转为森林 8.3 树的遍历 8.4 森林遍历 8.5 哈夫曼树（最优二叉树） 九、图 数据结构可以简单分为两大类：线性表，非线性表。 一、 线性表线性表是具有相同特性的数据元素的一个有限序列。($a_1$, $a_2$, $a_3$, $a_4$, …, $a_n$)n &#x3D; 0 时为空表。 同一线性表中的元素必定具有 相同特性（编程语言中可视为同种数据类型），数据元素间的关系是线性关系。 特征： 在非空的线性表中，有且仅有一个开始结点 $a_1$，它没有直接前驱，而是仅有一个直接后继 $a_2$； 有且仅有一个终端结点 $a_n$，他没有直接的后继，而仅有一个直接前驱 $a_{n-1}$； 其余的内部结点 $a_i$ $(2&lt;&#x3D;i&lt;&#x3D;n-1)$ 都有且仅有一个直接前驱 $a_{i+1}$ 和一个直接后继 $a_{i-1}$。 顺序表线性表采用 顺序存储 结构存储数据时称为 顺序表。 特点（随机存取）以 物理位置相邻 表示逻辑关系。 顺序表优缺点 优点：1. 存储密度大；2. 可以随机存取表中任一元素。 缺点：1. 插入、删除时，需要移动大量元素；2. 浪费存储空间；静态存储形式，数据元素的个数不能自由扩充。 链表线性表采用 链式存储 结构存储数据时称为 链表。链表分为单向链表，双链表，循环链表。 特点（顺序存取） 结点在存储器中是任意的，即逻辑上相邻的数据在物理上不一定相邻。 访问时只能通过头指针进入链表，并通过每个结点的指针域依次向后顺序扫描其余结点，所以寻找第一个和最后一个结点所花费的时间不等。 链表优缺点优点：逻辑上连续，物理上未必连续存储。有效利用碎片空间。插入、删除的效率高。缺点：随机查找元素时效率不高，需要从头遍历所有元素。 二、了解数据结构:链表 术语名称 含义 数据域 存储元素数值数据。 指针域 存储直接后继结点的存储位置。 结点 数据元素的存储映像，由数据域和指针域两部分组成。 首元结点 链表中存储第一个数据元素的结点 头指针 指向链表中第一个结点的指针 头结点 链表的首元结点之前 附设 的一个结点。（处理方便） 链表分为 带头结点 的链表和 不带头结点 的链表。 加了头结点有什么好处？ 如果加了头结点，便于首元结点的处理。首元结点的地址保存在头结点的指针域中，所以在链表的第一个位置上的操作和其它操作一致，无须进行特殊处理。 空表的表示和非空表也一样。 头结点的数据域内存储的什么？ 头结点的数据域可以为空，也可以存放线性表长度等附加信息，但此结点不能计入链表长度值。 比如给出一组线性表数据：（赵，钱，孙，李，周，吴，郑，王）顺序表表示(内存地址递增，连续空间)： 链表表示（每个结点出了数据还包括一个指向下一个结点指针域） 2.1 单链表单链表：结点只有一个指针域的链表；指针域指向后继结点。 2.2 双链表双链表：结点有两个指针域的链表，在单链表的每个结点再增加一个指向其前驱结点的指针域。 2.3 循环链表首尾相接的链表称之为循环链表。从表中任一结点出发都可以找到表中的其它结点。 单向循环链表：是一种首尾相连的链表，在单链表中的尾结点的指针域指向头结点，整个链表形成一个环。 双向循环链表：在双向链表的尾结点的尾指针域指向头结点的头指针。 三、栈只能在线性表的一端进行操作（添加&#x2F;删除等），一般是在栈顶（线性表尾部）。 四、队列在线性表的端点进行操作，一般是在队首删除，队尾插入。 五、字符串、数组、广义表前两种略过，只讲广义表。 广义表（又称为列表），是 $n &gt;&#x3D; 0$ 个元素 $a_0, a_1, a_2, …, a_n__1$ 的有限序列，其中每一个 $a_i$ 或者是原子，或者是一个广义表。广义表通常记作：$LS &#x3D; (a_1, a_2, …, a_n)$，习惯上，一般以 大写字母 表示广义表，小写字母 表示原子。 表头：若 LS 非空(n &gt;&#x3D; 1)，则其 第一个 元素就是表头，记作 head(LS) &#x3D; $a_1$。表尾：除表头以外的子表，记作 tail(LS) &#x3D; $(a_2, a_3, …, a_n)$。 注意：表头可以是原子，也可以是子表。表尾不是一个元素，而是一个子表。表尾一定是一个表。 表 举例 $A()$ 空表，长度为 0 $B(())$ 长度为 1，表头、表尾均为 () $C(a, (b, c))$ 长度为 2，由原子 a 和子表 (b, c) 构成，表头：a，表尾：((b, c))。 $D(x, y, z)$ 长度为 3，每一项都为原子，表头为 x，表尾为 (y, z) $E(C, D)$ 长度为 2，表头为 C，表尾为 (D) $F(a, F)$ 递归&#x2F;嵌套广义表，长度为 2，第一项为 a，第二项为它本身。表头为 a，表尾为 (F)。 $F &#x3D; (a, (a, (…)))$。 广义表的性质 广义表中的数据元素有相对次序，一个直接前驱和一个直接后继。 广义表的长度定义为最外层所包含的元素个数。如 $C&#x3D;(a, (b, c))$ 是长度为 2 的广义表。 广义表的深度定义为该广义表展开后所含括号的层数；$A &#x3D; (b, c)$ 的深度为 1，$B &#x3D; (A, d)$ 的深度为 2，$C &#x3D; (f, B, h)$ 的深度为 3。注意： 原子的深度为 0，“空表”的深度为 1。 广义表可以和其它广义表共享。比如 $A &#x3D; (b, c)$，$B &#x3D; (A, d)$，表 B 就共享了表 A。 广义表可以是一个递归的表，比如：$F &#x3D; (a, (a, (…)))$。递归表的深度是无穷的，但长度是有限的。 广义表是多层次的结构，广义表的元素可以是单元素，也可以是子表，而子表的元素还可以是子表，…。例：$D &#x3D; (E, F), E &#x3D; (a, (b, c)), F &#x3D; (d, (e))$图形表示(方框代表 原子，圆圈代表 子表)： 广义表可以看成是线性表的推广，线性表是广义表的特例。广义表的结构相当灵活，在某种前提下，它可以兼容线性表、数组、树和有向图等各种常用的数据结构。 当二维数组的每行（或每列）作为子表处理时，二维数组即为一个广义表。另外，树和有向图也可以用广义表来表示。由于广义表不仅集中了线性表、数组、树和有向图等常见的数据结构的特点，而且可以有效地利用存储空间，因此在计算机的许多应用领域都有成功使用广义表的案例。 广义表的基本运算：求表头、表尾 六、树树型结构是一种非线性的数据结构，结点有分支，具有一定的层次关系。 树是n(n&gt;&#x3D;0)个结点的有限集。n&#x3D;0时为空树；n&gt;0时，则它满足如下两个条件： 有且仅有一个特定的称为根的结点； 其余结点可分为 m(m&gt;&#x3D;0) 个互不相交的有限集 T1,T2…Tm，其中每一个集合本身又是一棵树，并称为根的子树（SubTree）。显然，树是一个 递归 的定义。 树的其它表示方式 名词术语 术语名称 解释 结点 数据元素以及指向子树的分支 根结点 非空树中无前驱结点的结点 结点的度 结点拥有的子树数（子树的个数&#x2F;分支数&#x2F;直接后继结点数） 数的度 树内各结点的度的最大值 叶子结点&#x2F;终端结点 度&#x3D;0 分支结点&#x2F;非终端结点 度 !&#x3D; 0 内部结点 不是根结点和叶子结点的其它结点 兄弟结点 拥有共同双亲结点的结点 树的深度&#x2F;高度 树中结点的最大层次 有序树：树中结点的各子树从左到右有次序（最左边的为第一个孩子）无序树：树中各结点无序。 森林：m（m&gt;&#x3D;0）棵互不相交的树的集合。一棵树可以看成一个特殊的森林：把根结点删除就变成了森林；给森林中的各子树加上一个双亲结点，森林就变成了树。 例如：把下面的根结点 A 删除就成了森林，把 B、C、D 三颗树加上双亲结点 A 就成了一棵树。 树一定是森林，森林不一定是树。 七、二叉树每个结点最多有两个孩子（二叉树中不存在度大于2的结点）子树有左右之分，其次序不能颠倒。二叉树可以是一个空集，根可以有空的左子树或空的右子树。 二叉树不是树的特殊情况，它们是两个概念。二叉树必须要区分左、右子树，即便只有一棵子树也要区分。树的结点只有一个孩子时，就无须区分它是左还是右的次序。这是二叉树和树的最主要的区别。虽然二叉树与树概念不同，但有关书的基本术语对二叉树都适用。 为何要重点研究二叉树（每个结点最多只有两个“叉”的树）？ 普通树如过不转为二叉树，则它的结构很复杂，运算很难实现。 二叉树结构最简单，规律性最强； 可以证明，所有的树都能转化为唯一对应的二叉树，不失一般性。 二叉树在树结构的应用中起着非常重要的作用，因为对二叉树的许多操作算法简单，而任何树都可以和二叉树相互转换，这样就解决了树的存储结构及其运算中存在的复杂性。 7.1 二叉树性质 在二叉树的第 i 层上至多有 $2^i^-^1$ 个结点（i &gt;&#x3D; 1）;第i层上至少有 1 的结点。 深度为 k 的二叉树至多有 $2^k$ - 1 个结点(k &gt;&#x3D; 1)。至少有 k 个结点。 对任何一颗二叉树 $T$，如果其叶子数为 $n_0$ ,度为2的节点数为 $n_2$，则 $n_0$ &#x3D; $n_2$ + 1 性质 4、5 需要先学习两种特殊的二叉树。 7.2 两种特殊的二叉树（1） 满二叉树定义：深度为k且有 $2^k$ - 1 个结点的二叉树（可以视为性质 2 特例）。 特点每层上的结点数都是最大结点数（每层都满）。叶子结点全部在最底层。对满二叉树结点位置进行编号，编号规则： 自根结点开始，自上而下，从左至右。 每一个结点位置都有元素。 满二叉树在同样深度的二叉树中 结点 个数最多满二叉树在同样深度的二叉树中 叶子结点 个数最多 （2） 完全二叉树定义：深度为 k 的具有 n 个结点的二叉树，当且仅当其每一个结点都与深度为 k 的满二叉树中编号为 1 ~ n 的结点一一对应时，称为完全二叉树。 从满二叉树中从最后一个结点开始，连续 的去掉任意个结点，即是一个完全二叉树。 满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树。 特点：叶子结点只可能分布在层次最大的两层上对任一结点，如果其右子树的最大层次为 i，则其左子树的最大层次必为 i 或 i+1。 完全二叉树 完全二叉树的性质 具有 n 个结点的完全二叉树的深度为 $log_2n + 1$。 如果对一棵树有 n 个结点的完全二叉树，深度为 $log_2n + 1$ 的结点按层序编号（从第一层到第 $log_2n + 1$ 层，每层从左到右），则对任一结点i（1&lt;&#x3D; i &lt;&#x3D;n），有：1）如果 i &#x3D; 1，则结点 i 是二叉树的根，无双亲；如果 i &gt; 1，则其双亲是结点 i&#x2F;2;2）如果 2i &gt; n，则结点 i 为叶子结点，无左孩子；否则，其左孩子是结点2i；3）如果 2i+1 &gt; n，则结点 i 无右孩子；否则，其右孩子是结点 2i+1。 性质 4 表明了完全二叉树 结点数 n 与完全二叉树 深度 k 之间的关系。性质 5 表明了完全二叉树中 双亲结点 编号与 孩子结点 编号之间的关系。 7.3 二叉树的存储结构二叉树的顺序存储：按满二叉树的结点层次编号，依次存放二叉树中的数据元素。（使用数组放在对应的下标位置） 存储结构 如果该二叉树不是一棵完全二叉树，那么还是按照这个方法，在没有元素的位置存储 空 或者 0。这样保证了数据能够恢复。 顺序存储的缺点：定长；如果空数据较多，浪费空间。顺序存储适于存储满二叉树和完全二叉树。 二叉树的链式存储：一个结点包括三个要素，一个数据域和两个指针域，一个指针指向左孩子，一个指针指向右孩子。 二叉树的链式存储结构 在结点数为 n 的二叉链表中，空指针域有 n+1 个。 三叉链表：在二叉链表的基础上增加一个指向双亲的指针域，由一个数据域和三个指针域构成。 7.4 二叉树遍历方式先序遍历DLR：访问根结点D，先序遍历左子树L，先序遍历右子树R中序遍历LDR：中序遍历左子树L，访问根D，中序遍历右子树R后序遍历LRD：后序遍历左子树L，后序遍历右子树R，访问根D二叉树的层次遍历：从根结点开始按从上到下、从左到右的顺序去遍历，每个结点仅访问一次。 如果同时确定了先序、中序序列或者同时确立了后序、中序序列，那么就可以 唯一的确定 这棵二叉树结构。 线索二叉树（基于链式二叉树）：如果某个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱；如果某个结点的右孩子为空，则将空的右孩子指针域改为指向其后继。这种改变指向的指针称为“线索”。加上了线索的二叉树称为线索二叉树。 在线索二叉树中，为了区分指针域是指向前驱还是后继，在结点中又添加了两个标记域 ltag、rtag，值为 1 代表指针域指向前驱；值为 0 代表指向后继。 八、树和森林树的双亲表示法，定义结构数组，存放树的结点，每个结点含两个域：数据域 存放结点本身信息，双亲域 指示本结点的双亲在数组中的位置。 特点：找双亲容易，找孩子难。 孩子链表：把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储。 孩子链表 特点：找孩子容易，找双亲难。 把两种方法结合，在数据的前面加入一个域存储双亲的位置下标。称为带双亲的孩子链表。 带双亲的孩子链表 孩子兄弟表示法（二叉树表示法，二叉链表表示法）实现：用二叉链表作树的存储结构，链表中的每个结点的两个指针域。分别指向其第一个孩子结点和下一个兄弟结点。 孩子兄弟表示法 特点：找孩子、兄弟容易，找双亲难。 8.1 树与二叉树的转换将树转换为二叉树：由于树和二叉树都可以用 二叉链表 作存储结构，则以二叉链表为媒介可以导出树与二叉树之间的一个对应关系。 给定一棵树，可以找到唯一的一棵二叉树与之对应。如下图（最右边为转换后的二叉树） 二叉树转换 将树转换成二叉树将树转换为二叉树 1、加线：在兄弟之间加一连线；2、抹线：对每个结点，除了其左孩子之外，去除其与其余孩子之间的关系；3、旋转：以树的根结点为轴心，将其整树顺时针旋转45°。 树变二叉树口诀：兄弟相连留长子。 将二叉树转换成树将二叉树转换为树 1、加线：若 p 结点是双亲孩子的左孩子，则将 p 的右孩子，右孩子的右孩子……沿分支找到的所有右孩子，都与 p 的双亲用线连起来；2、抹线：抹掉原二叉树中双亲与右孩子之间的连线；3、调整：将结点按层次排列，形成树结构。二叉树变树口诀：左孩右右连双亲，去掉原来右孩线。 8.2 森林与二叉树的转换森林转为二叉树森林转换为二叉树 1、将各棵树分别转换成二叉树；2、将每棵树的根结点用线相连；3、以第一棵树根结点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构。 森林变二叉树口诀：树变二叉根相连。 二叉树转为森林二叉树转为森林 1、抹线：将二叉树中根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树；2、还原：将孤立的二叉树还原成树。 二叉树变森林口诀：去掉全部右孩线，孤立二叉再还原。 8.3 树的遍历先根遍历：先访问根结点，然后依次先跟遍历各子树。后根遍历：先依次后根遍历各棵子树，然后访问根结点。层次遍历：自上而下自左至右访问树中每个结点。 8.4 森林遍历将森林看作由三部分构成：1、森林中第一棵树的根结点；2、森林中第一棵树的子树森林；3、森林中其它树构成的森林。 先序遍历：1、访问森林中的第一棵树的根结点；2、先序遍历森林中的第一棵树的子树森林；3、先序遍历森林中（除第一棵树外）其余树构成的树林。即：依次从左至右对森林中的每一棵树进行先根遍历。 中序遍历：1、中序遍历森林中的第一棵树的子树森林；2、访问森林中的第一棵树的根结点；3、中序遍历森林中（除第一棵树外）其余树构成的树林。即：依次从左至右对森林中的每一棵树进行后根遍历。 后序遍历： 8.5 哈夫曼树（最优二叉树）路径：从树种一个结点到另一个结点之间的分支构成两个结点间的路径。结点的路径长度：两个结点间路径上的分支数。树的路径长度：从树根到每一个结点的路径长度之和。记作 TL。权：将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度：从根结点到该结点之间的 路径长度 与该结点的权的乘积。树的带权路径长度：树中所有叶子结点的带权路径长度之和。 哈夫曼树：最优树 就是带权路径长度最短的树。注意：带权路径长度最短是在 “度相同” 的树中比较而得的结果，因此有最优二叉树、最优三叉树之称等等。 哈夫曼树：最优二叉树，带权路径长度最短的二叉树 相应的算法（构造哈夫曼树的方法）称为哈夫曼算法。 满二叉树不一定是哈夫曼树；具有相同带权路径长度的哈夫曼树不唯一。哈夫曼树中权越大的叶子离根越远。 哈夫曼树的结点的度数为0或2，没有度为1的结点。包含n个叶子结点的哈夫曼树中共有 2n-1 个结点。包含 n 棵树的森林要经过 n-1 次合并才能形成哈夫曼树，共产生 n-1 个新结点。 哈夫曼树中共有 2n-1 个结点，且其所有分支结点的度都不为1。 结点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树。 九、图G&#x3D;(V,E)V：顶点的有穷非空集合E：边的又穷集合 有向图：每条边都有方向无向图：每条边都没有方向完全图：任意连个点都有一条边相连。n 个顶点，n(n-1)&#x2F;2 条边。稀疏图：有很少边或弧的图（e &lt; nlogn)稠密图：有很多边或弧的图网：边&#x2F;弧带权的图邻接：有边&#x2F;弧相连的两个顶点之间的关系关联（依附）：边&#x2F;弧与顶点之间的关系顶点的度：与该顶点相关联的边的数目在有向图中，顶点的度等于该顶点的入度和出度 路径：接续的边构成的顶点序列路径长度：路径上边&#x2F;弧的数目&#x2F;权值之和环：第一个顶点和最后一个顶点相同的路径简单路径：除路径的起点和终点相同，其余顶点都不相同的路径 连通图（强连通图）在无（有）向图 G&#x3D;(V, {E}) 中，若对任意两个顶点v、u都存在从 v 到 u 的路径，则称 G 是连通图（强连通图）。 权与网图中边或弧所具有的相关数称为权。表明一个顶点到另一个顶点的距离或耗费。带权的图称为网子图：设有两个图 G&#x3D;(V, {E}), G1&#x3D;(V1, {E1})，若 V1 V, E1 E，则 G1 是 G 的子图。连通分量：无向图G的极大连通子图称为G的连通分量 极大连通图的意思是：该子图是 G 连通子图，将 G 的任何不在该子图中的顶点加入，子图不在连通。 有向图G的极大连通子图称为G的强连通分量 极小连通子图：该子图是G的连通子图，在该子图中删除任何一条边，子图不再连通。生成树：包含无向图G所有顶点的极小连通子图生成森林：对非连通图，由各个连通分量的生成树的集合 本笔记只记录了一些图的术语，没有其他讲解。图的应用是非常多的，尤其是在关系模型中，体现尤为明显。注：本文截图来源于 B 站视频《数据结构与算法基础（青岛大学-王卓）》视频中的内容，由 87师兄 分享。视频地址：https://www.bilibili.com/video/BV1nJ411V7bd","tags":["数据结构","概念"],"categories":["Skill","数据结构和算法"]},{"title":"设计模式之单例模式","path":"/p/1a4b62fe/","content":"单例是需要在内存中永远只能创建一个类的实例。 介绍优点：节约内存和保证共享计算的结果正确，以及方便管理。 应用： 全局信息类：例如任务管理器对象，或者需要一个对象记录整个网站的在线流量等信息。 无状态工具类：类似于整个系统的日志对象，我们只需要一个单例日志对象负责记录，管理系统日志信息。 写法单例模式有 8 种，很多时候存在 饿汉式单例 以及 懒汉式单例 的概念。 饿汉式单例： 在获取单例对象之前对象已经创建完成了。懒汉式单例： 在真正需要单例对象的时候才创建出该对象。 写法很多，给出一种推荐写法，推荐面试使用： 12345678910111213141516171819202122/*** 双重检查，延迟加载*/public class Singleton01 &#123; // volatile 保证指令不会重排序和可见性 private volatile static Singleton01 INSTANCE = null; private Singleton01() &#123; &#125; public static Singleton01 getInstance() &#123; if (INSTANCE == null) &#123; synchronized (Singleton01.class) &#123; if (INSTANCE == null) &#123; INSTANCE = new Singleton01(); &#125; &#125; &#125; return INSTANCE; &#125;&#125; 为什么静态成员变量要加上 volatile 关键字呢？ 解释该问题之前，我们需要知道 Java 创建对象的步骤：a.分配内存空间b.调用构造器，初始化实例c.返回地址给引用 在这几步中，底层可能进行对象创建的重排序操作，b、c 步骤在执行的过程中会互换：a.分配内存空间b.返回地址给引用（此时静态变量已经不为null了，对象还没有初始化）c.调用构造器，初始化实例 如果不使用 volatile 关键字，可能会发生指令重排序。下面使用 A、B 线程举例。 线程A：1.分配内存空间2.返回地址给引用3.调用构造器，初始化实例 线程B：认为静态变量不为null，直接得到对象的内存地址。但是该对象还没有初始化完成，如果线程B使用该对象去操作，会出现部分值缺失（NPE）。 所以为了确保线程安全，我们需要加上该关键字。 静态内部类单例模式基于类的初始化实现延迟加载和线程安全的单例设计。 JVM 在类的初始化阶段（即在Class被加载后，且线程使用之前），会执行类的初始化。在执行类的初始化期间，JVM 会获得一个锁，这个锁可以同步多个线程对同一个类的初始化。基于这个特性，可以实现另一种线程安全的延迟初始化方案。 123456789101112131415161718public class Singleton02 &#123; private Singleton02() &#123; &#125; // 静态内部类 private static class InnerClass &#123; // JVM 在类的初始化阶段（即在Class被加载后，且线程使用之前），会执行类的初始化。 // 在执行类的初始化期间，JVM 会获得一个锁，这个锁可以同步多个线程对同一个类的初始化。 // 基于这个特性，可以实现另一种线程安全的延迟初始化方案。 private static final Singleton02 INSTANCE = new Singleton02(); &#125; public static Singleton02 getInstance() &#123; return InnerClass.INSTANCE; &#125;&#125; 静态内部类是在被调用时才会被加载，这种方案实现了懒汉单例的一种思想，需要用到的时候才去创建单例，加上JVM的特性，这种方式又实现了线程安全的创建单例对象。通过对比基于 volatile 的双重检查锁定方案和基于类的初始化方案的对比，我们会发现基于类的初始化的方案的实现代码更为简洁。但是基于 volatile 的双重检查方案有一个额外的优势： 除了可以对静态字段实现延迟加载初始化，还可以对实例字段实现延迟初始化。 枚举实现单例枚举实际上是一种多例的模式，如果我们只定义一个实例就是单例了。 123456public enum Singleon03 &#123; INSTANCE; public void whatever() &#123; ... &#125;&#125; 枚举是 Java 提供的一种特性，已经实现了线程安全机制。 枚举实现单例只是一种实现策略，或者面试的回答方案，实际开发中通常不使用该方式。通常被用来作为信息的标志和分类。","tags":["设计模式","单例模式"],"categories":["Skill"]},{"title":"设计模式之策略模式","path":"/p/99c8c8b1/","content":"策略模式也是非常常用的一种模式，使用策略模式可以轻松扩展第三方服务，非常适合 if 比较多的情况。为什么这么说呢？主要是它和模板模式比较像，这样说区别比较明显。 策略模式顾名思义，策略模式使用时至少有两种不同的策略（简单理解为两个 if），所以当根据多个不同的条件走不同的分支时非常灵活，而且方便扩展。策略模式是符合开闭原则的。 模式举例以快递举例吧，比如我国有很多的快递公司：京东、韵达、圆通、中通、申通等等。当你的系统集成这些服务时，在用户下单的时候，需要根据条件去选择不同的快递，每家快递的收费情况、运输质量等也是不同的。如果使用 if-else-if 会有大段大段的代码块，后期根据快递公司的业务变动维护自己的系统要改一些地方，这时候就比较头疼了。 这个时候就可以考虑使用策略模式，定义通用的方法在一个接口中，然后为每家快递公司创建一个类去实现这个接口，为每家快递公司编写自己的实现就可以了。 说到这里，你可能觉得它和模板模式很类似。所以接下来说说区别。 模板方法通常是抽象模板，里面通常包含两部分：通用的算法实现；留给子类实现的抽象方法。 策略模式一般使用接口提供，由具体的实现类编写处理逻辑，提供算法。 可以看到，模板方法模式一般只针对一套算法，对同一套算法的不同实现细节进行抽象；而策略模式对多种算法进行不同的实现，所以策略模式相比模板模式更加灵活，算法与算法之间一般没有冗余代码。策略模式的关注点更广，模板模式的关注点更深。它们不能相互替换，但可以组合使用。","tags":["设计模式","策略模式"],"categories":["Skill"]},{"title":"基础排序算法","path":"/p/14098bfe/","content":"基础算法说明，不涉及算法的书写实现，只整理算法的操作思想，以及复杂度比较。 排序排序的稳定性只对 结构类型数据 的排序有意义。 1. 插入排序基本思想：每步将一个待排序的对象，按其有关键码大小，插入到前面已经排好序的一组对象的适当位置上，知道对象全部插入为止。 基本操作：有序插入。在有序序列中插入一个元素，保持序列有序，有序长度不断增加。 1.1 直接插入排序：采用顺序查找法查找插入位置。直接插入排序，可以使用 “哨兵”。 原始数据越接近有序，排序速度越快。最坏情况下（数据逆序排序）。 实现排序的基本操作有两个，“比较” 序列中两个关键字的大小， “移动”。如果要提高查找速度，减少元素的比较次数和移动次数。 1.2 折半插入排序：二分法减少了比较次数，不能减少移动次数。平均性能优于直接插入。 1.3 希尔排序：缩小增量，多遍插入排序特点： - 一次移动，移动位置较大，跳跃式的接近排序后的最终位置。 - 最后一次只需要少量移动。 - 增量序列必须是递减的，最后一个必须是1. - 增量序列必须是互质的。 如何选择最佳 d 序列，目前尚未解决；最后一个增量必须是1，无除了1之外的公因子；不宜在链式存储结构上实现。 2. 交换排序基于交换思想的排序。 2.1 冒泡排序冒泡排序比较简单，但是效率较低。n 个记录，总共需要 n-1 趟。第 m 趟需要比较 n-m 次。 2.2 快速排序基本思想：通过一趟排序，将待排序记录分割成独立的两部分，其中的部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录进行排序，以达到整个序列有序。 具体实现：选定一个中间数作为参考，所有元素与之比较，小的调到其左边，大的调到其右边。中间数（枢轴） 可以是第一个数、最后一个数、最中间一个数、任选一个数等。 快速排序不是原地排序。由于程序中使用了递归，需要递归调用栈的支持，而栈的长度取决于递归调用的深度（即使不用递归，也需要使用用户栈）。在平均情况下：需要 O(logn) 的栈空间。最坏情况下：栈空间可达 O(n)。 快速排序是一种不稳定的排序。快排不适用于对基本有序或原本有序的记录序列进行排序（越乱越快）。 3. 选择排序3.1 简单选择排序基本思想：在待排序的数据中选出最大（小）的元素放在其最终的位置。 基本实现 首先通过 n-1 次关键字比较，从 n 个记录中找出关键字 最小 的记录，将它与第一个记录交换。 再通过 n-2 次比较，从剩余的 n-1 个记录中找出关键字 次小 的记录，将它与第二个记录交换。 重复以上操作，共进行 n-1 趟排序后，排序结束。 时间复杂度 移动次数 最好情况：已经排好序，移动次数为 0 最坏情况：逆序，每次都需要交换，移动次数为 3(n-1) 比较次数：无论待排序序列是什么状态，选择排序所需进行的 “比较” 次数都相同。 算法稳定性：简单选择排序是不稳定排序。 3.2 堆排序堆的定义：若 n 个元素的序列 {${a_1, a_2, …, a_n}$} 满足 $a_i &lt;&#x3D; a_{2i}$， $a_i &lt;&#x3D; a_{2i+1}$ 或者 $a_i &gt;&#x3D; a_{2i}$， $a_i &gt;&#x3D; a_{2i+1}$。则分别称该序列 {${a_1, a_2, …, a_n}$} 为 小根堆 和 大根堆。 从堆的定义可以看出，堆实质是满足如下性质的 完全二叉树 ：二叉树任一非叶子结点均小于（大于）它的孩子结点。 堆排序：若在输出 堆顶 的最小值（最大值）后，使得剩余 n-1 个元素的序列重又建成一个堆，则得到 n 个元素的次小值（次大值）……如此反复，便得到一个有序序列，这个过程称之为 堆排序。 实现堆排序需解决两个问题： 如何由一个无序序列建成一个堆？ 单节点的二叉树是堆。 如何在输出堆顶元素后，调整剩余元素为一个新的堆？ 对一个无序序列反复 “筛选” 就可以得到一个堆，即：从一个无序序列建堆的过程就是一个反复 “筛选” 的过程。 初始化所需时间不超过O(n)排序阶段（不含初始化） - 一次重新堆化所需时间不超过O(logn) - n-1 次循环所需时间不超过O(nlogn) 堆排序的时间主要耗费在建初始堆和调整建新堆时进行的反复 “筛选” 上。堆排序在最坏情况下，其时间复杂度也为 $O(nlog_2n)$，这是堆排序的最大优点。无论待排序列中的记录是正序还是逆序排列，都不会使堆排序处于 “最好” 或 “最坏” 的状态。 4. 归并排序基本思想：将两个或两个以上的有序子序列 “归并” 为一个有序序列。 4.1 2-路归并排序在内部排序中，通常采用的是 2-路归并排序。即：将两个位置相邻的有序子序列 R[l..m] 和 R[m+1..n] 归并为一个有序序列 R[l..n]。 时间效率：O(nlog2n)空间效率：O(n) 因为需要一个与原始序列同样大小的辅助空间。 归并排序是一个 稳定 的算法。 5. 基数排序基本思想：分配+收集 也叫 桶排序 或 箱排序，设置若干个箱子，将关键字为 k 的记录放入第 k 个箱子，然后再按序号将非空的连接。 基数排序：数字是有范围的，均有 0-9 这十个数字组成，则只需设置十个箱子，相继按个、十、百…进行排序。 例如 {614, 738, 921, 485, 637, 101, 215, 530, 790, 306} 6. 外部排序7. 各种排序方法比较 排序方法 最好时间复杂度 最坏时间复杂度 平均时间复杂度 空间复杂度 稳定性 直接插入排序 O($n$) O($n^2$) O($n^2$) O(1) 稳定 直接插入排序 O($n^2$) O($n^2$) O($n^2$) O(1) 稳定 希尔排序 O($n$) O($n^2$) ~O($n^{1.3}$) O(1) 不稳定 冒泡排序 O($n$) O($n^2$) O($n^2$) O(1) 不稳定 快速排序 O($nlogn$) O($n^2$) O($nlogn$) O($nlogn$) 不稳定 直接选择排序 O($n^2$) O($n^2$) O($n^2$) O(1) 不稳定 堆排序 O($nlogn$) O($logn$) O($nlogn$) O($n^2$) 不稳定 归并排序 O($nlogn$) O($nlogn$) O($nlogn$) O(n) 稳定 基数排序 O($n+m$) O($k*(n+m)$) O($k*(n+m)$) O(n+m) 稳定 7.1 时间性能 按平均的时间性能来分，有三类排序方法 时间复杂度为 O(nlogn) 的方法有： 快速排序、堆排序和归并排序，其中以快速排序为最好。 时间复杂度为 O(n^2) 的有： 直接插入排序、冒泡排序和简单选择排序，其中以直接插入为最好，特别是对那些对关键字近似有序的记录序列尤其如此。 时间复杂度为 O(n) 的排序方法只有：基数排序 当待排记录序列按关键字顺序有序时，直接插入排序和冒泡排序能达到O(n)的时间复杂度；而对于快速排序而言，这是最不好的情况，此时的时间性能退化为 $O(n^2)$，因此是应该尽量避免的情况。 简单选择排序、堆排序、归并排序的时间性能不随记录序列中关键字的分布而改变。 7.2 空间性能指的是排序过程中所需的辅助空间大小 所有的简单排序方法（包括：直接插入、冒泡和简单选择）和堆排序的空间复杂度为 $O(1)$。 快速排序为 $O(logn)$，为栈所需的辅助空间。 归并排序所需辅助空间最多，其空间复杂度为 $O(n)$。 链式基数排序需附设队列首尾指针，则空间复杂度为 $O(rd)$。 7.3 稳定性稳定的排序方法是指：对于两个关键字相等的记录，它们在序列中的相对位置，在排序之前和经过排序之后，没有改变。 当对多关键字的记录序列进行 LSD 方法排序时，必须采用稳定的排序算法。 对于不稳定的排序方法，只要能举出一个实例说明即可。 快速排序和堆排序是不稳定的排序方法。 关于排序方法的时间复杂度的下限以上的几种排序方法，除基数排序外，其它方法都是基于 “比较关键字” 进行排序的排序方法，可以证明，这类排序法可能达到的最快的时间复杂度为 $O(nlogn)$。基数排序不是基于 “比较关键字” 的排序方法，所以它不受这个限制。 可以用一棵判定树来描述这类基于 “比较关键字” 进行排序的排序方法。","tags":["基础算法"],"categories":["Skill","数据结构和算法"]},{"title":"数据结构-堆","path":"/p/7299117d/","content":"堆的数据结构 大根堆根节点是最大值，下面的左右节点不需要比较大小。 小根堆根节点是最小值，下面的左右节点不需要比较大小。 上滤、下滤调整堆序型实际应用中，可能出现不满足堆序型的情况。 添加时上滤 实际存堆的还是数组结构，逻辑结构是堆，实际结构是数组 时间复杂度高（堆元素数量很大） Netty HashWheelTimerNetty自己设计的一个定时任务（延迟队列）解决方案海量的定时任务 效率比 Timer 高 时间轮算法（TimeingWheel）Netty HashWheelTimerDubboAkkaKafkaQuartz 没有排序过程：想像一下又一个圆，圆上均分 20 块，每块使用 双向链表 存储定时任务列表，到哪一块按顺序执行便可。 超时的解决方法 加入圈数 圈数太多，效率低 分层时间轮（Kafka） 时间轮算法在 Netty 中的体现","tags":["数据结构","概念","堆"],"categories":["Skill","数据结构和算法"]},{"title":"散列表","path":"/p/916e10bc/","content":"Java 散列表（其它语言中的 HashMap 不太了解） 一、Hash 冲突可以避免？Hash 冲突是肯定存在的，但是可以 尽量 避免 散列均匀：元素远小于存储空间的时候，避免冲突，要有好的 hash 算法。 二、散列冲突的解决方法 为什么 Java 的 Map 使用了 16 个 Entry？$2^n$ 可以使用 位运算 替换 模运算，速度比较快。 java 中 Hash 冲突（碰撞）的解决方法链表的方式（1.7）红黑树（1.8）线性探测（ThreadLocalMap） 1. 开放定址法（开地址法）1.1 线性探测法1.2 二次探测法散列函数：$$H_i &#x3D; (Hash(key) + d_i) \\mod m$$ 其中，m 为散列表长度，m 要求是某个 4k+3 的质数；$d_i$ 为增量序列：$$1^2, -1^2, 2^2, -2^2, …, q^2$$ 1.3 伪随机探测法$H_i &#x3D; (Hash(key)+d_i) \\mod m (1 &#x3D;&lt; i &lt; m)$其中，mod 为散列长度，$d_i$ 为伪随机数。 2. 链地址法（拉链法）基本思想：相同散列地址的记录链成一个单链表。 m 个散列地址就设 m 个单链表，然后用一个数组将 m 个单链表的表头指针存储起来，形成一个动态的结构。 散列表的装填因子 $a$：$$a &#x3D; \\frac{表中填入的数据}{哈希表的长度}$$ 散列表技术具有很好的平均性能，优于一些传统的技术；链地址法优于开地址法；除留取余法作散列函数优于其它类型函数（取小于等于表长的一个质数）。","tags":["数据结构","散列表"],"categories":["Skill","数据结构和算法"]},{"title":"初识 Podman","path":"/p/b800dc19/","content":"Podman 和 Docker 一样，也是一个容器化技术的一种实现。它是全开源的。但是它们的底层架构是不同的，Podman 不需要使用 root 用户创建容器，也没有 deamon 进程，所以 Podman 不支持--restart 策略。但是为了迁移方便，Podman 团队采用了和 Docker 类似的命令。 一、安装撰写本文的时候 Podman 已更新到 4.4.0 版本，本文所有涉及 Podman 的命令全部都是在此版本的基础上进行的。 1234567891011121314151617# 1. 安装yay -S podman podman-compose# 2. 查看当前用户名称whoami# 3. 把用户名称加入到 `/etc/subuid、/etc/subgid` 两个文件中usermod --add-subuids 100000-165535 --add-subgids 100000-165535 username# 执行命令并测试podman system migratepodman -v# 使用搜索命令，会发现没有任何结果。这是因为需要配置一下podman search nginx# 编辑配置文件 /etc/containers/registries.conf# 备份文件sudo cp /etc/containers/registries.conf /etc/containers/registries.conf.baksudo vim /etc/containers/registries.conf 进入文本查看时，会发现所有的内容都是被注释掉的，找到以下内容去掉注释并修改，保存退出。 /etc/containers/registries.conf12345unqualified-search-registries = [&quot;docker.io&quot;] [[registry]]prefix = &quot;docker.io&quot;location = &quot;registry.docker-cn.com&quot; unqualified-search-registries 可以配置多个源，镜像的搜索会从这些源中去寻找。registry##prefix、location 是镜像拉取时的配置。 举个栗子，用以上配置举例： 123456789# 搜索 unqualified-search-registries 配置的所有源中所有符合条件的镜像# 如果你配置了多个，那么你就会在结果中看到有的镜像带有不同的前缀podman search nginx# 拉取镜像podman pull nginx# 虽然自己写的是上面的命令，但是 Podman 会自动加入配置# 我们配置了 prefix，实际命令是这样：podman pull docker.io/nginx# 如果还配置了 location，就会是这样：podman pull registry.docker-cn.com/nginx 二、命令命令大多和 Docker 命令一样，只是开头变成了 podman，如果不习惯可以配置 docker 别名（前提是只安装了 podman）。 命令就不详细说了，可以参阅官方文档：https://docs.podman.io/en/latest/Commands.html","tags":["skill","podman"],"categories":["Skill"]},{"title":"二叉树","path":"/p/e85d694a/","content":"二叉排序树二叉排序树（Binary sort tree）又称为二叉查找树、二叉搜索树。 二叉排序树可以是空树，或是满足以下性质的二叉树： 若其 左子树 非空，则左子树上的结点都 小于 根结点的值； 若其 右子树 非空，则右子树上的结点都 大于等于 根结点的值； 其左右子树本身也各是一棵二叉排序树。 含有 n 个结点的二叉排序树的平均查找长度和树的形态有关。 一个无序序列可以通过二叉排序树变成一个有序序列，构造树的过程就是对无序序列进行排序的过程。 平衡二叉树Q: 如何提高形态不均衡的二叉排序树的查找效率？A: 做 “平衡化” 处理，尽量让二叉树的形状均衡。 定义：又称 AVL 树（Adelson-Velskii and Landis）一棵平衡二叉树或者是子树，或者是具有下列性质的二叉排序树：1.左子树与右子树的高度之差的绝对值小于等于1；2.左子树和右子树也是平衡二叉排序树。 为了方便起见，给每个结点附加一个数字，给出该结点左子树与右子树的高度差。这个数字称为结点的平衡因子（BF）平衡因子 &#x3D; 结点左子树的的高度 - 结点右子树的高度根据二叉平衡树的定义，平衡二叉树上所有结点的平衡因子只能是-1、0 或 1。 对于一棵有 n 个结点的 AVL 树，其高度保持在 $O(log_2n)$ 数量级，ASL 也保持在 $O(log_2n)$ 量级。 失衡二叉树平衡调整的四种类型： 二叉树平衡调整 红黑树红黑树是一种 自平衡 的排序二叉树。 五个性质： 每个节点非红即黑； 根节点总是黑色的； 每个叶子节点都是黑色的空节点（NIL节点）； 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）； 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。 为什么要用红黑树？简单来说红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。","tags":["数据结构","二叉树"],"categories":["Skill","数据结构和算法"]},{"title":"Docker入门","path":"/p/89826705/","content":"写写 Docker 入门操作。 一、Docker入门 二、准备 镜像源配置 1. 命令行设置国内镜像源 2. 编辑配置文件设置镜像加速 三、常用命令 四、Docker进阶 1. Docker为什么提供网络功能？ 2. docker数据卷（volume） 五、Dockerfile 六、docker-compose 1. 常用命令 2. docker-compose.yml示例 3. 使用portainer可视化工具 4. 卸载 Docker 一、Docker入门镜像与容器概念？ 用重装系统来解释的话，镜像（images）就是我们要装的系统（win7、win10、manjaro 等 iso 文件），容器好比是 U 盘。我们可以把系统放进各种容量足够的 U 盘里，那么这个 U 盘就是一个容器，当我们需要重装系统的时候，就使用（启动）这个 U 盘（容器）。 因此，一个镜像可以去创建多个容器，各个容器之间互不干扰。 Q：docker 拉取的镜像为什么比我们直接下载的文件体积大？A：一个镜像不仅仅是原来的软件包，它还包含了软件包运行所需的操作系统依赖、软件自身依赖等。所以随着我们的使用，使用的镜像越多，新的镜像下载会越来越快，因为有些依赖已经存在，后续的镜像如果对存在的依赖有使用的话，它会复用已经存在的依赖，而不会去再次下载。 二、准备为了避免使用普通用户运行 docker 的相关命令时出现报错，我们可以在docker命令前加上sudo去运行，但是每次都加显然很麻烦。那么在安装完docker后，可以使用以下命令： 12345678# 创建 docker 用户组sudo groupadd docker# 将当前普通用户加入 docker 组中sudo gpasswd -a $USER docker# 更新 docker 组newgrp docker# 测试命令docker ps 镜像源配置有两种方法修改镜像源，一种是命令行命令，另一种是修改相关文件。 1. 命令行设置国内镜像源1dockerd --registry-mirror=https://registry.docker-cn.com 2. 编辑配置文件设置镜像加速/etc/docker/daemon.json1234567891011121314&#123; &quot;registry-mirrors&quot; : [ &quot;https://mirror.ccs.tencentyun.com&quot;, &quot;http://registry.docker-cn.com&quot;, &quot;http://docker.mirrors.ustc.edu.cn&quot;, &quot;http://hub-mirror.c.163.com&quot; ], &quot;insecure-registries&quot; : [ &quot;registry.docker-cn.com&quot;, &quot;docker.mirrors.ustc.edu.cn&quot; ], &quot;debug&quot; : true, &quot;experimental&quot; : true&#125; 设置完毕重启 docker 服务。 加速源 url 是否需要注册 Docker官方的中国镜像加速地址 https://registry.docker-cn.com 需要 中科大的镜像加速器 https://docker.mirrors.ustc.edu.cn/ 不用注册（推荐) 阿里云的镜像加速器 登录阿里云的容器hub服务，镜像加速器那一栏里会为你独立分配一个加速器地址 需要注册 DaoCloud的镜像加速器 登录DaoCloud的加速器获取脚本，该脚本可以将加速器添加到守护进程的配置文件中。 需要注册 三、常用命令1234567891011121314151617181920212223242526272829303132333435# 镜像操作docker search name # 根据镜像名称查找镜像docker pull 镜像名称:版本号 # 拉取镜像，注意对应的版本号docker images -a # 列出本地所有的镜像docker images --digests # 显示镜像的摘要信息docker images --no-trunc # 显示完整的镜像信息docker rmi name/id # 删除镜像，-f 选项强制删除docker info # docker详细信息# 容器操作docker ps # 列出当前正在运行的容器docker ps -a # 列出所有的容器docker ps -q # 列出所有的容器IDdocker inspect name/id # 查看容器内部信息docker stop name/id # 停止容器运行docker start name/id # 启动容器docker restart name/id # 重启容器docker rm name/id # 删除容器，-f 选项强制删除docker logs name/id # 查看容器服务运行日志docker logs -f name/id # 实时监听服务运行日志docker logs -t name/id # 为服务运行日志加入时间戳# 复制容器内部的配置文件到宿主机# docker cp name/id:源文件source 宿主机目录targetdocker cp nginx:/etc/nginx/nginx.conf /data/docker-service/nginx/nginx.conf# 进入容器docker exec -it name/id bash# 将容器打包成一个新的镜像docker commit -m &quot;描述信息&quot; -a &quot;作者信息&quot; 容器名称或者ID tarName:tag# 将镜像备份,备份为 .tar 文件docker save 镜像名称:标签 -o fileName 以上的 name&#x2F;id 均指容器创建时指定的名称或者容器的标识id（docker ps可以查看）. 接下来以MySQL为例来体会一下docker，使用之前确定网络连接良好。 12345678910111213141516171819202122232425262728293031323334353637383940414243# 查找docker hub中是否有MySQL镜像，可以去 [docker hub](https://hub.docker.com/) 的官网搜索版本docker search mysql# 拉取MySQL8.0.20版本docker pull mysql:8.0.20# 查看拉取的镜像docker images# 创建并运行容器 MYSQL_ROOT_PASSWORD 该项在启动时必须指定，不然容器启动失败# mysql:8.0.20 就是使用刚刚下载的镜像创建容器；如果不写会自动下载最新版本的镜像docker run -d -p 9999:3306 --name mysql8 -v /docker-data/mysql/data:/var/lib/mysql -v /docker-data/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 --restart=always mysql:8.0.20# 查看 mysql8 容器是否运行docker ps# 查看容器信息docker inspect mysql8# 进入容器docker exec -it mysql8 bash# 进入 mysql 命令行，登录 mysqlmysql -u root -p# 退出 bash，退出容器exit# 停止容器docker stop mysql8# 再次查看正在运行的容器docker ps# 查看本地所有的容器（启动成功和启动失败的都会显示）docker ps -a# 删除容器docker rm mysql8# 再次查看本地所有的容器docker ps -a# 删除下载的 mysql8.0.20 镜像docker rmi mysql:8.0.20# 查看已下载的镜像docker images 选项 说明 run 运行一个docker容器 –name 生成的容器的名字 mysql8 -p 9999:3306 设置端口映射：宿主机映射端口:容器运行端口；客户端工具(例如navicat)连接时可以通过 9999 端口进行连接 -e 代表添加环境变量 MYSQL_ROOT_PASSWORD&#x3D;123456 初始化root用户的密码为 123456 -d 表示使用守护进程运行，即服务挂在后台运行 -v 数据卷映射，前面的是本地目录，后面的为容器内目录。删除容器映射的本地目录内容仍然存在 –restart&#x3D;always 在 docker 容器已经启动后，自动运行该容器服务 如果已经运行的服务想要设置跟随 docker 服务启动，使用下面的命令docker update –restart&#x3D;always name&#x2F;id 四、Docker进阶1. Docker为什么提供网络功能？Docker允许通过外部访问容器或容器互联的方式来提供网络服务，方便了不同容器间进行通信。一般在使用docker网桥(bridge)实现容器与容器通信时，都是站在一个应用角度进行容器通信。 12345678910# 查看网桥配置docker network ls# 创建网桥docker network create 自定义网桥名称# 删除网桥docker network rm 网桥名称或ID# 查看网桥详情docker inspect 网桥名称或ID# 运行容器时使用 --network 网桥名称 指定该容器在那个网桥段docker run -d --name mysql -p 3306:3306 --network ems mysql:8.0 网桥不会自动创建，如果要使用网桥，必须 先创建，再使用； 运行容器时指定的网桥不存在，那么会导致这个容器运行失败。在容器启动时指定了网桥后，在这个网桥中的所有容器，可以直接使用容器名称与其它容器通信。类似于同一局域网进行联机对战。 1234docker run -d --name tomcat01 -p 8081:8080 --network ems tomcat:8.0-jre8docker run -d --name tomcat02 -p 8082:8080 --network ems tomcat:8.0-jre8# 之后可以通过名称去访问tomcat02的主页信息curl http://tomcat02:8082 2. docker数据卷（volume） 数据卷的修改会立即影响到容器； 对数据的更新修改，不会影响镜像； 数据卷默认一直存在，即使容器被删除 实现容器与宿主机之间数据共享。数据卷就是上面创建mysql时的 -v 指定的映射目录，可以把容器内的数据持久化，这样删除容器时我们不必担心数据丢失。但是注意，这样做外部的改变和容器内部的改变会互相影响。 如果我们希望外部影响内部，但是内部操作不影响外部的话，在创建容器时我们可以这样指定： -v /usr/mysql/data:/var/lib/mysql:ro，其中 ro 代表只读(read only)。前面的映射目录我们也可以使用数据卷简称，这个简称可以随便起名，例如：-v aa:/var/lib/mysql，这样docker会自动帮我们创建 aa 存储目录，可以使用 docker volume inspect aa查看它的路径。 12345678910# 查看数据卷docker volume ls# 查看数据卷信息docker volume inspect 卷名# 创建数据卷docker volume create 卷名# 删除数据卷docker volume rm 卷名# 删除没有使用的数据卷，删除前需要我们手动确认docker volume prune 五、Dockerfile如果不清楚 Dockerfile 的相关指令含义，可以查阅官方文档，有清晰的介绍。Dockerfile 文件中的命令必须使用大写，通常以 FROM 指令开始。 官方文档https://docs.docker.com/engine/reference/builder/ 下面使用 Dockerfile 创建 Java 镜像在容器运行作为一个简单的 Demo，其实，它也是很简单的。首先创建一个空的文件夹，在空文件夹中创建 DockerFile 文件，编辑： 123456789101112# 以 openjdk:8-jre 为基础FROM openjdk:8-jre# 指定目录后，下面的命令都是基于此目录进行的WORKDIR /application# 基于 WORKDIR 的路径,/application/aaWORKDIR aa# 该文件上传后，直接改名为 app.jarADD app-0.0.1-SNAPSHOT.jar app.jar# 暴露的端口EXPOSE 8081# 运行时执行的命令ENTRYPOINT java -jar app.jar 构建自定义镜像：docker build -t demo:1.0 .，注意最后的 . 不要漏掉。用自定义镜像启动容器：docker run -d -p 8081:8081 --name demo demo:1.0 六、docker-composedocker-compose 和 Dockerfile 很相似，都是需要我们写一个文件，文件中按照特定的格式去写一些内容和指令，再使用命令去运行这个文件。一个 docker-compose 对应一个 stack。 和 docker 的不同：docker是面向容器的，而 docker-compose 是面向服务的，这也是两者本质区别。 另外，如果是 Window 系统，安装 Docker for Window 后就包括了 dcoker-compose 工具；如果是 Linux 系统，那么额外需要安装 docker-compose 插件。没错，docker-compose 是 docker 的一个插件。 docker-compose官网安装说明https://docs.docker.com/compose/install/ 1. 常用命令123456789101112131415161718192021222324252627282930313233343536# 查看帮助docker-compose --help# 启动服务的命令,默认前台启动；如果文件名称是 `docker-compose.yml` 可以省略，其它名称不可省略。docker-compose up docker-compose.yml 或者直接 docker-compose updocker-compose up docker-test.yml# 后台启动docker-compose up -d# 停止所有 up 启动的服务,并移除网络docker-compose down# 进入指定的容器，注意写的是服务名称docker-compose exec# 列出当前 docker-compose 运行的所有容器docker-compose ps# 重启项目中服务，后面不写服务名代表重启所有服务。还有 start stop 指令，与之类似，略过。docker-compose restart# 强制删除（-f）并删除数据卷（-v，慎用-v选项）docker-compose rm -f -v# 查看每个服务容器内的进程docker-compose top# 唤醒服务docker-compose unpause# 暂停服务docker-compose pause# 查看服务日志docker-compose 服务 logs 2. docker-compose.yml示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071version: &quot;3.8&quot; # 4.0以下services: tomcat: # 唯一服务名称 image: tomcat:8.0-jre8 # 使用哪个镜像创建 # 用来指定 dockerfile 所在目录。 # 和 image 的不同：先根据该文件构建镜像，之后再运行容器 build: # dockerfile 文件所在的目录 context: demo dockerfile: Dockerfile container_name: tomcat # 指定容器名称 ports: # 宿主机与容器的的端口映射 - &quot;8080:8081&quot; volumes: # 宿主机与容器的目录映射 #- /root/data:/usr/local/tomcat/ # 自定义映射 - tomcatwebapps:/usr/local/tomcat/webapps networks: # 指定容器启动后使用的哪个网桥 - hello mysql: image: mysql:8.0 container_name: mysql ports: - &quot;3306:3306&quot; volumes: - /root/mysql/data:/var/lib/mysql - /root/mysql/config:/etc/mysql enviroment: - MYSQL_ROOT_PASSWORD=root # 可以把 environment 的内容写到配置文件中 env_file: # 配置文件必须以 .env 结束 - mysql.env # 代表这个容器启动时依赖哪些模块，服务名称,不是容器名称 depends_on: - tomcat - redis # 用来修改容器内部参数；因为如果不修改的话容器可能无法启动 sysctls: - net.core.somaxconn=1024 - net.ipv4.tcp.syncookies=0 # 修改容器中系统内部进程数限制；根据当前容器运行服务要求更改 ulimits: nproc: 65535 nofile: soft: 20000 hard: 40000 redis: image: redis:6.2.5 container_name: redis ports: - &quot;6379:6379&quot; volumes: - redisdata:/data # 启动时覆盖容器的默认命令 command: &quot;redis-server --appendonly yes&quot;volumes: tomcatwebapps: # 自定义映射卷标需要显式声明 # 是否确定使用指定卷标 # false 会使用 项目名 + 卷标名 external: true redisdata: networks: # 定义上面服务用到的网桥名称，默认就是 bridge hello: # 是否确定使用指定名称的网桥 # false 会使用 项目名 + 网桥名称 external: true 同一网络中的服务可以使用服务名称进行通信 3. 使用portainer可视化工具 下载可视化工具：docker pull portainer/portainer 启动 portanier，需要开放两个端口，8000 为监听服务的端口，9000 为向外部提供服务的端口。 docker -d -p 8000:8000 -p 9000:9000 --name portanier --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer 浏览器访问 http://localhost:9000 4. 卸载 Docker1234sudo apt-get purge docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce-rootless-extrassudo rm -rf /var/lib/dockersudo rm -rf /var/lib/containerd","tags":["docker"],"categories":["Skill","Docker"]},{"title":"Docker启动常用服务","path":"/p/1ca431ad/","content":"Docker Hub 上可以搜索并查看镜像以及版本，选择合适的进行拉取&#x2F;下载。相应的镜像里都有官方的的启动说明可以参考，本文只是水文。 1. MySQL 2. Redis 3. Nginx 4. RabbitMQ 5. ElasticSeach And Kibana Docker Hub 上的镜像有三种标签是可以信任的： DOCKER OFFICIAL IMAG：Docker 官方镜像，是一组精心策划的 Docker 开源和即插即用解决方案存储库。 Verified Publisher：Docker验证镜像，来自 Docker 验证的出版商的高质量镜像。这些产品由商业实体直接发布和维护。这些镜像不受速率限制。 Sponsored OSS：Docker 赞助的开源软件镜像。这些镜像由 Docker 通过开源计划赞助的开源项目发布和维护。 1. MySQL123456789101112131415# 创建所需目录mkdir -p /data/docker-service/mysql/conf.dmkdir -p /data/docker-service/mysql/datacd /data/docker-service/mysql# 拉取镜像docker pull mysql:8.0.30# 启动一个简单的基础镜像（只是用来复制配置文件，用完就删除）docker run --name mysql-test -e MYSQL_ROOT_PASSWORD=root -d mysql:8.0.30docker cp mysql-test:/etc/my.cnf conf.d/# 删除镜像docker rm mysql-test# 使用自定义的配置文件启动MySQL并且在启动时创建一个数据库docker run -d -p 3306:3306 --name mysql -v /data/docker-service/mysql/conf:/etc/mysql/conf.d -v /data/docker-service/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root -v MYSQL_DATABASE=要创建的数据库名称 --restart=always mysql:8.0.30 启动完成后，进入 MySQL 的 bash 环境: docker exec -it mysql bash，执行下面几个条命令开启远程连接： 123456789101112use mysql;# MySQL8.0 之前授权远程连接# password 根据自身情况修改GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;password&#x27; WITH GRANT OPTION;# 刷新权限FLUSH PRIVILEGES;# MySQL8.0 之后授权远程连接create user root@&#x27;%&#x27; identified by &#x27;password&#x27;;grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; with grant option;flush privileges; 如果需要导入之前的数据库备份文件到此容器中，可以使用 docker cp /data/docker-service/mysql/data/备份文件.sql mysql:/var/lib/mysql，然后使用 source 备份文件.sql; 加载数据到容器。 如果本机使用可视化工具（dbeaver、navicat）连接出现以下错误：Can’t connect to local MySQL server through socket ‘&#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.sock’，请使用 127.0.0.1 连接，不要使用 localhost。 2. RedisRedis默认开启的是快照模式(RDB)，可以开启AOF持久化(最多丢1s内数据) 123456789# 创建所需目录mkdir -p /data/docker-service/redis/confmkdir -p /data/docker-service/redis/datacd /data/docker-service/redis# 此处如果使用自定义配置文件，在 conf 文件中建立 redis.conf 文件添加内容即可# 指定配置文件并开启AOF持久化后台启动docker run -p 6379:6379 --name redis -v /data/docker-service/redis/conf:/usr/local/etc/redis -v /data/docker-service/redis/data:/data -d redis:6 redis-server /usr/local/etc/redis/redis.conf --appendonly yes Redis6.2 配置文件：https://raw.githubusercontent.com/redis/redis/6.2/redis.confhttps://redis.io/docs/management/config/ 3. Nginx12345678910111213141516171819# 创建所需目录mkdir -p /data/docker-service/nginx/conf.dmkdir -p /data/docker-service/nginx/htmlmkdir -p /data/docker-service/nginx/logcd /data/docker-service/nginx# 拉取镜像docker pull nginx:1.22.1# 启动一个简单的基础镜像（只是用来复制配置文件，用完就删除）# 如果自己复制文件内容，此步可以跳过docker run --name nginx-test -d nginx:1.22.1docker cp nginx-test:/etc/nginx/nginx.conf ./docker cp nginx-test:/etc/nginx/conf.d/default.conf conf.d/# 删除镜像docker stop nginx-test &amp;&amp; docker rm nginx-test# 启动docker run --name nginx -p 80:80 -v /data/docker-service/nginx/nginx.conf:/etc/nginx/nginx.conf:ro -v /data/docker-service/nginx/html:/usr/share/nginx/html -v /data/docker-service/nginx/log:/var/log/nginx -v /data/docker-service/nginx/conf.d:/etc/nginx/conf.d -d nginx:1.22.1 注意：nginx的配置文件必须和版本一致。ro 代表只读(read only): 外部的改变能够影响内部，内部的改变不会影响外部。 4. RabbitMQ12# 使用自定义配置信息启动docker run -d --name RabbitMQ -p 15672:15672 -p 5672:5672 -v /data/docker-service/rabbitmq/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf rabbitmq:3.8-management 5672 端口是与程序进行通信的，比如Java。rabbitmq:3.8-management 连带服务和管理界面的插件一并启动(默认的账号密码：guest&#x2F;guest)，而 rabbitmq:3.8 是没有管理界面的。 如果在启动时指定用户名、密码可以加上以下内容。 123-e RABBITMQ_DEFAULT_VHOST=/ems-e RABBITMQ_DEFAULT_USER=root-e RABBITMQ_DEFAULT_PASS=root 5. ElasticSeach And KibanaElasticSeach 官方指导教程：https://www.elastic.co/guide/en/elasticsearch/reference/7.5/docker.htmlKibana 官方教程传送：https://www.elastic.co/guide/en/kibana/current/docker.html 直接启动 ES 容器会报错，解决方案：1.编辑宿主机 vim &#x2F;etc&#x2F;sysctl.conf 加入 vm.max_map_count=262144，保存退出2.sysctl -p","tags":["docker"],"categories":["Skill","Docker"]},{"title":"Docker安装Oracle11g","path":"/p/6e4c8a2f/","content":"使用 Docker 安装 Oracle 数据库，注意拉取的镜像，以下操作都是在拉取的镜像的基础上进行的。 镜像获取1234567# 拉取镜像，推荐使用这一个，不然后续无法进行docker pull registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g# 运行oracle 11g镜像docker run -d -p 1521:1521 --name oracle11g registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g# 进入容器docker exec -it oracle11g bash 导入环境变量12# 切换到root用户 密码：helowinsu - root 编辑 vim /etc/profile /etc/profile123export ORACLE_HOME=/home/oracle/app/oracle/product/11.2.0/dbhome_2export ORACLE_SID=helowinexport PATH=$ORACLE_HOME/bin:$PATH Oracle配置123456789101112131415# 切换到oracle用户su - oracle# 进入oracle目录cd $ORACLE_HOME# 启动$ORACLE_HOME/bin/sqlplus /nolog# 连接conn /as sysdba# 修改system的密码并设置密码的有效时间为无限alter user system identified by oracle;ALTER PROFILE DEFAULT LIMIT PASSWORD_LIFE_TIME UNLIMITED;# 创建 test 用户create user test identified by test;# 授权grant connect,resource,dba to test; 创建表空间表空间需要如下设置后才能创建，否则会创建失败。 123show parameter db_create_file; ALTER SYSTEM SET db_create_file_dest = &quot;/home/oracle/app/oracle/oradata&quot;","tags":["docker"],"categories":["Skill","Docker"]},{"title":"Rust入门","path":"/p/dba35a1e/","content":"Rust 是一颗新星，世界各地的开发人员都在注视着，这款以安全著称的语言你不试试吗？ 一、了解Rust由于 Rust 提出的概念太过优秀，许多企业都有相关的文档，甚至编程的先行前辈也有开放的文档，各种资料浩如星海，不乏优秀的文档，所以浪子直接放链接。 官网学习Rust链接 什么是 Rust？https://learn.microsoft.com/zh-cn/training/modules/rust-introduction/2-rust-overview Rust 的独特功能https://learn.microsoft.com/zh-cn/training/modules/rust-introduction/3-rust-features Rust 以及 IDE 安装，你可以使用 Vscode 也可以使用 IDEA,安装 rust 插件即可。https://course.rs/first-try/installation.html Rust 代码组织结构https://learn.microsoft.com/zh-cn/training/modules/rust-modules-packages-crates/1-concepts-code-organization 上面的链接过一遍，环境和编辑器应该都有了，那么你对 rust 的代码编写有一定的认识？推荐看看官网的文档，你会对语法有进一步的了解。","tags":["rust"],"categories":["Skill","Rust"]},{"title":"ZooKeeper 总结","path":"/p/6fff97ea/","content":"Zookeeoer 总结 1 Zookeeper的结构认识 1.1 节点 1. 特点 2. 节点监听机制 2 ZK的配置文件 3 客户端基本指令 4 ZK伪集群搭建示例 Zookeeper 简称 ZK，是基于 Java 语言编写的开放源码的分布式应用程序协调服务，可以使用 jps 命令查询相关进程。 ZooKeeper主要服务于分布式系统：统一配置管理、统一命名服务、分布式锁、集群管理。 dubbo、springcloud 框架使用 ZK 作为注册中心； Hadoop、Hbase组件使用 ZK 作为集群管理者； redis 可以使用 ZK 实现分布式锁。 1 Zookeeper的结构认识ZK 的内存结构和 Linux 文件系统非常相似。 ZK中的节点称为 ZNode，节点模型的特点： 每个子目录都被称为一个节点，这个节点是它所在路径的唯一标识。 节点可以有子节点目录，每个子节点都可以存储数据。 节点是有版本的，每个子节点中的数据都可以有多个版本，也就是一个访问路径可以存储多份数据。 节点可以被监控，包括这个目录节点中存储的数据的修改，节点目录的变化等，一旦变化可以通知监听的客户端。 1.1 节点ZK 节点分类： 持久性节点：PERSISTENT 持久性顺序节点：PERSISTENT_SEQUENTIAL 临时节点：EPHEMERAL 临时顺序节点：EPHEMERAL_SEQUENTIAL 1. 特点 临时&#x2F;临时顺序节点上不可以包含任何的子节点。 ZK 默认在根路径中有一个 zookeeper 节点，zookeeper 节点下有一个 quota 子节点。 2. 节点监听机制一个 Watch 事件是一个一次性的触发器，当被设置了 Watch 的数据和目录发生了改变的时候，则服务器将这个改变发送给设置了 Watch 的客户端以便通知他们。节点的监听是一次性的，监听一次就会失效。 12345# 监听路径变化ls /node true# 监听数据变化get /node true 2 ZK的配置文件12345678910# 集群节点之间的心跳时间tickTime=2000# 初始化集群时集群节点的同步超时时间，10代表 10 个滴答声，20秒initLimit=10# 同步时间限制 5 个滴答声syncLimit=5# 持久化数据存放目录dataDir=/tmp/zookeeper# ZK 服务监听端口号clientPort=2181 3 客户端基本指令指定配置文件启动：./bin/zkServer.sh start ./conf/zoo.cfg客户端连接：./bin/zkCli.sh -server localhost:2181 1234567891011121314151617181920212223242526272829303132# 查看路径节点ls /node# 创建一个持久顺序节点：create -s /node jhlz# 创建一个临时数据节点create -e /node jhlz# 创建一个临时顺序节点create -e -s /node jhlz# 查看节点的状态stat /node# 查看节点数据和状态get /node# 设置节点的值set /node xiaoming# 组合 相当于 ls / + stat /ls2 /node# 删除节点，只能删除没有子节点的节点delete /node# 递归删除节点rmr /node# 退出当前会话quit 创建节点时，默认创建的是持久化节点。create &#x2F;node jhlz，这样就创建了一个 jhlz 的持久化节点 4 ZK伪集群搭建示例集群的搭建和其它集群的搭建都是一样的，非常简单：创建不同的配置文件，在服务启动时指明需要的配置文件即可。 首先建立三个文件夹： zk1 zk2 zk3在每一个数据目录中创建一个 myid 文件。并在每一个 myid 文件中添加标号。 1234567mkdir zk1 zk2 zk3touch zk1/myid /zk2/myid zk3/myidecho &quot;1&quot; &gt; zk1/myidecho &quot;2&quot; &gt; zk2/myidecho &quot;3&quot; &gt; zk3/myid 修改各自的配置 123456789101112131415161718192021222324252627282930# 编辑第一个vim zk1/zoo.cfgtickTime=2000initLimit=10syncLimit=5dataDir=/tmp/zk1clientPort=3001server.1=localhost:3002:3003server.2=localhost:4002:4003server.3=localhost:5002:5003# 编辑第二个vim zk1/zoo.cfgtickTime=2000initLimit=10syncLimit=5dataDir=/tmp/zk1clientPort=4001server.1=localhost:3002:3003server.2=localhost:4002:4003server.3=localhost:5002:5003# 编辑第三个vim zk3/zoo.cfgtickTime=2000initLimit=10syncLimit=5dataDir=/tmp/zk1clientPort=5001server.1=localhost:3002:3003server.2=localhost:4002:4003server.3=localhost:5002:5003 其中，server.1 的区分就是上面创建的 myid 文件的编号，ZK 会自动根据 myid 的编号去识别，但是我们在集群配置中需要写明。3002: 数据同步使用的端口号。3003： leader 选举使用的端口号。 指定配置文件启动服务 12345./bin/zkServer.sh start zk1/zoo.cfg./bin/zkServer.sh start zk2/zoo.cfg./bin/zkServer.sh start zk3/zoo.cfg","tags":["zookeeper"],"categories":["Skill"]},{"title":"Hexo博客配置整理","path":"/p/9b42c073/","content":"使用 Hexo + Github&#x2F;其他平台提供的 Pages 服务打造自己简单的博客的话，还是需要安装一些插件来辅助的，不仅可以美化排版，还能提升用户体验。一起看看有哪些用着不错的插件吧~ 一、插件hexo官网部署插件https://hexo.io/docs/one-command-deployment 其它推荐：https://loafing.cn/posts/hexo-tags.html 1. hexo d使用该命令需要安装插件： 2. 使用永久链接插件解决中文转义如果我们写的文章标题是中文的话，那么在进行链接的分享时是会进行转义的（**不是乱码**），至于为什么要转义，请自行百度。如果忍受不了可以使用插件去解决，生成一个永久性的链接。它会让你的博客链接变成类似这样：https://xxx.xxx.com/posts/8ddf18fb.html。注意：这款插件并不会让你的中文正常显示，而是生成一串简短的字符串，毕竟中文url在转义后特别长。 安装插件： 在 blog/_config.yml 中找到对应 permalink 标签，进行修改即可： blog/_config.yml123456789# permalink: :year/:month/:day/:title/permalink: p/:abbrlink/abbrlink: alg: crc32 #算法： crc16(default) and crc32rep: hex #进制： dec(default) and hexpermalink_defaults:pretty_urls:trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinkstrailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks 不同算法、进制生成的链接格式如下： 算法 进制 生成链接示例 crc16 hex https://yourname.github.io/p/66c8.html crc16 dec https://yourname.github.io/p/65535.html crc32 hex https://yourname.github.io/p/8ddf18fb.html crc32 dec https://yourname.github.io/p/1690090958.html 3. 生成RSS页面 配置示例： blog/_config.yml12345678910111213141516171819# In the front-matter of your post,# you can optionally add a description, intro or excerpt setting to write a summary for the post.# Otherwise the summary will default to the excerpt or the first 140 characters of the post.feed: enable: true type: - atom - rss2 path: - atom.xml - rss2.xml limit: 20 hub: content: false content_limit: 140 content_limit_delim: &#x27; &#x27; order_by: -date icon: icon.png autodiscovery: true 配置完成执行 hexo cl &amp;&amp; hexo g &amp;&amp; hexo d，然后访问 https://yourname.github.io/rss2.xml 或者 https://yourname.github.io/atom.xml 查看。 4. 引入Mermaid流程图Hexo 默认的 markdown 不支持 Mermaid 流程图，需要安装依赖来支持： 在 _config.yml 文件中加入以下内容： blog/_config.yml123456# mermaid chartmermaid: ## mermaid url https://github.com/knsv/mermaid enable: true # default true version: &quot;7.1.2&quot; # default v7.1.2 options: # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js #startOnload: true // default true 之后，还需要在主题文件中加入一些代码，具体的配置可以参考 官网。如果嫌弃配置麻烦或者实在不想配置，可以使用下面的方法。 另一种解决方案：hexo-filter-kroki，安装完成后，默认情况下，不需要进行任何配置，插件会将您的文本发送到 Kroki.io 进行渲染，并将 base64 编码的图像内联在 html 中。在插件作者的仓库中也有高级配置，可以自行查看配置。 12# 懒人推荐npm install --save hexo-filter-kroki 5. 集成Github Action自动化部署时，文章的创建、更新时间都变为自动部署的时间问题 安装插件： 确保所有的 md 文件名称中不含空格 Github Action 的脚本中加入 fetch-depth: 0： .github/workflows/xxx.yml123456# Fetch all history for all tags and branchessteps:- name: Checkout uses: actions/checkout@v3 with: fetch-depth: 0 二、相关问题1. 关于配置文件blog/_config.yml 是使用 hexo init 创建项目时，文件夹中的 _config.yml 文件。它是整个博客的配置文件，部署仓库的地址、分支等信息在这里配置。theme/_config.yml 是使用 hexo init 创建项目时，文件夹中的 _config.主题名称.yml 文件（默认的主题名称为 lan）。主题名称为博客文件夹中 theme/主题文件夹 的名称。它是博客主题的配置文件，主题支持的渲染模型、文章使用的标签排版等都通过这里配置。 2. 在yourname.github.io的其它分支部署在设置这一项之前确保在 blog/_config.yml 中已设置部署的目标分支，然后在 Github 仓库中进行设置。步骤：进入仓库 -&gt; 选择 Settings -&gt; 找到 Pages，如下图： 设置完成后保存，重新部署即可发布到指定的分支。 3. 部署之后页面白屏部署之后，打开网址页面白屏，F12 打开控制台如果有页面异常的消息，代表配置（比如主题配置文件加载博客配置等等多种原因）有问题，执行命令 hexo g --debug 查看报错信息，修改对应的配置项，修改完之后继续执行 hexo g --debug，直到没有报错信息，然后进行部署，等待部署完成访问网站就 OK 啦~","tags":["hexo","配置"],"categories":["Hexo"]},{"title":"IDEA 插件 EasyCode 配置","path":"/p/50f4489/","content":"EasyCodeEasyCode 是 IDEA 中的一款自动代码生成插件，非常的好用，本文放置浪子的配置文件 spring-data-jpa 作为备份。json 格式文件，可以导入配置。 EasyCodeConfig.json12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&#123; &quot;author&quot; : &quot;jhlz&quot;, &quot;version&quot; : &quot;1.2.7&quot;, &quot;userSecure&quot; : &quot;&quot;, &quot;currTypeMapperGroupName&quot; : &quot;Default&quot;, &quot;currTemplateGroupName&quot; : &quot;spring-data-jpa&quot;, &quot;currColumnConfigGroupName&quot; : &quot;Default&quot;, &quot;currGlobalConfigGroupName&quot; : &quot;Default&quot;, &quot;typeMapper&quot; : &#123; &quot;Default&quot; : &#123; &quot;name&quot; : &quot;Default&quot;, &quot;elementList&quot; : [ &#123; &quot;matchType&quot; : &quot;REGEX&quot;, &quot;columnType&quot; : &quot;varchar(\\\\(\\\\d+\\\\))?&quot;, &quot;javaType&quot; : &quot;java.lang.String&quot; &#125;, &#123; &quot;matchType&quot; : &quot;REGEX&quot;, &quot;columnType&quot; : &quot;char(\\\\(\\\\d+\\\\))?&quot;, &quot;javaType&quot; : &quot;java.lang.String&quot; &#125;, &#123; &quot;matchType&quot; : &quot;REGEX&quot;, &quot;columnType&quot; : &quot;(tiny|medium|long)*text&quot;, &quot;javaType&quot; : &quot;java.lang.String&quot; &#125;, &#123; &quot;matchType&quot; : &quot;REGEX&quot;, &quot;columnType&quot; : &quot;decimal(\\\\(\\\\d+,\\\\d+\\\\))?&quot;, &quot;javaType&quot; : &quot;java.lang.Double&quot; &#125;, &#123; &quot;matchType&quot; : &quot;ORDINARY&quot;, &quot;columnType&quot; : &quot;integer&quot;, &quot;javaType&quot; : &quot;java.lang.Integer&quot; &#125;, &#123; &quot;matchType&quot; : &quot;REGEX&quot;, &quot;columnType&quot; : &quot;(tiny|small|medium)*int(\\\\(\\\\d+\\\\))?&quot;, &quot;javaType&quot; : &quot;java.lang.Integer&quot; &#125;, &#123; &quot;matchType&quot; : &quot;ORDINARY&quot;, &quot;columnType&quot; : &quot;int4&quot;, &quot;javaType&quot; : &quot;java.lang.Integer&quot; &#125;, &#123; &quot;matchType&quot; : &quot;ORDINARY&quot;, &quot;columnType&quot; : &quot;int8&quot;, &quot;javaType&quot; : &quot;java.lang.Long&quot; &#125;, &#123; &quot;matchType&quot; : &quot;REGEX&quot;, &quot;columnType&quot; : &quot;bigint(\\\\(\\\\d+\\\\))?&quot;, &quot;javaType&quot; : &quot;java.lang.Long&quot; &#125;, &#123; &quot;matchType&quot; : &quot;ORDINARY&quot;, &quot;columnType&quot; : &quot;date&quot;, &quot;javaType&quot; : &quot;java.time.LocalDate&quot; &#125;, &#123; &quot;matchType&quot; : &quot;ORDINARY&quot;, &quot;columnType&quot; : &quot;datetime&quot;, &quot;javaType&quot; : &quot;java.time.LocalDateTime&quot; &#125;, &#123; &quot;matchType&quot; : &quot;ORDINARY&quot;, &quot;columnType&quot; : &quot;timestamp&quot;, &quot;javaType&quot; : &quot;java.time.LocalDateTime&quot; &#125;, &#123; &quot;matchType&quot; : &quot;ORDINARY&quot;, &quot;columnType&quot; : &quot;time&quot;, &quot;javaType&quot; : &quot;java.time.LocalTime&quot; &#125;, &#123; &quot;matchType&quot; : &quot;ORDINARY&quot;, &quot;columnType&quot; : &quot;boolean&quot;, &quot;javaType&quot; : &quot;java.lang.Boolean&quot; &#125; ] &#125; &#125;, &quot;template&quot; : &#123; &quot;spring-data-jpa&quot; : &#123; &quot;name&quot; : &quot;spring-data-jpa&quot;, &quot;elementList&quot; : [ &#123; &quot;name&quot; : &quot;controller.java.vm&quot;, &quot;code&quot; : &quot;##导入宏定义、设置包名、类名、文件名##导入宏定义 $!&#123;define.vm&#125; #setPackageSuffix(\\&quot;controller\\&quot;) #setTableSuffix(\\&quot;Controller\\&quot;) #save(\\&quot;/controller\\&quot;, \\&quot;Controller.java\\&quot;) ##拿到主键 #if(!$tableInfo.pkColumn.isEmpty()) #set($pk = $tableInfo.pkColumn.get(0)) #end ##定义服务名 #set($serviceSortType = $!tool.append($!tableInfo.name, \\&quot;Service\\&quot;)) #set($serviceType = $!tool.append($!tableInfo.savePackageName, \\&quot;.service.\\&quot;, $serviceSortType)) #set($serviceVarName = $!tool.firstLowerCase($serviceSortType)) #set($entityShortType = $!tableInfo.name) ## set($entityType = $!tableInfo.psiClassObj.getQualifiedName()) #set($entityType = $!tool.append($!tableInfo.savePackageName, \\&quot;.entity.\\&quot;, $!tableInfo.name)) #set($entityVarName = $!tool.firstLowerCase($!tableInfo.name)) #set($pkType = $!pk.type) import $pkType; import $entityType; import $serviceType; import org.springframework.data.domain.Page; import org.springframework.data.domain.Pageable; import org.springframework.data.web.PageableDefault; import org.springframework.web.bind.annotation.*; import java.util.List; /** * $!&#123;tableInfo.comment&#125;控制层 * * @author $!author * @since $!time.currTime() */ @RestController @RequestMapping(\\&quot;/$!tool.firstLowerCase($!tableInfo.name)\\&quot;) public class $!&#123;tableName&#125; &#123; \\t/** \\t * 获取$!&#123;tableInfo.comment&#125;列表(分页) \\t */ \\t@GetMapping \\tpublic Page&lt;$entityShortType&gt; listPage(@RequestBody $entityShortType $entityVarName, \\t @PageableDefault(page = 0, size = 20) Pageable page) &#123; \\t\\treturn null; \\t&#125; \\t/** \\t * 获取$!&#123;tableInfo.comment&#125; \\t */ \\t@GetMapping(\\&quot;/&#123;id&#125;\\&quot;) \\tpublic $entityShortType queryById(@PathVariable $!pk.shortType id) &#123; \\t\\treturn $&#123;serviceVarName&#125;.findById(id); \\t&#125; \\t/** \\t * 添加$!&#123;tableInfo.comment&#125; \\t */ \\t@PostMapping \\tpublic void add(@RequestBody $entityShortType $entityVarName) &#123; \\t\\t$&#123;serviceVarName&#125;.save($entityVarName); \\t&#125; \\t/** \\t * 修改$!&#123;tableInfo.comment&#125; \\t */ \\t@PutMapping \\tpublic void edit(@RequestBody $entityShortType $entityVarName) &#123; \\t\\t$&#123;serviceVarName&#125;.update($entityVarName); \\t&#125; \\t/** \\t * 删除$!&#123;tableInfo.comment&#125; \\t */ \\t@DeleteMapping(\\&quot;/&#123;ids&#125;\\&quot;) \\tpublic void delete(@PathVariable List&lt;$!pk.shortType&gt; ids) &#123; \\t\\t$&#123;serviceVarName&#125;.remove(ids); \\t&#125; \\tprivate final $serviceSortType $serviceVarName; public $!&#123;tableName&#125; ($serviceSortType $serviceVarName) &#123; this.$serviceVarName = $serviceVarName; &#125; &#125; &quot; &#125;, &#123; &quot;name&quot; : &quot;entity.java.vm&quot;, &quot;code&quot; : &quot;##引入宏定义 $!&#123;define.vm&#125; ##使用宏定义设置回调（保存位置与文件后缀） #save(\\&quot;/entity\\&quot;, \\&quot;.java\\&quot;) ##使用宏定义设置包后缀 #setPackageSuffix(\\&quot;entity\\&quot;) import jakarta.persistence.Entity; import jakarta.persistence.GeneratedValue; import jakarta.persistence.GenerationType; import jakarta.persistence.Id; import org.hibernate.annotations.DynamicInsert; import org.hibernate.annotations.DynamicUpdate; ##使用全局变量实现默认包导入 $!&#123;autoImport.vm&#125; import java.io.Serial; import java.io.Serializable; #set($entityShortType = $!tableInfo.name) #set($entityType = $!tool.append($!tableInfo.savePackageName, \\&quot;.entity.\\&quot;, $!tableInfo.name)) #set($entityVarName = $!tool.firstLowerCase($!tableInfo.name)) #set($pkType = $!pk.type) ##使用宏定义实现类注释信息 #tableComment(\\&quot;实体类\\&quot;) @Entity(name = \\&quot;$!tool.hump2Underline($!&#123;tableInfo.name&#125;)\\&quot;) @DynamicInsert @DynamicUpdate public class $!&#123;tableInfo.name&#125; implements Serializable &#123; @Serial private static final long serialVersionUID = $!tool.serial(); #foreach($column in $tableInfo.fullColumn) #if($&#123;column.comment&#125;)/** * $&#123;column.comment&#125; */#end #if($&#123;column.name&#125; == \\&quot;id\\&quot;) @Id @GeneratedValue(strategy = GenerationType.IDENTITY) #end private $!&#123;tool.getClsNameByFullName($column.type)&#125; $!&#123;column.name&#125;; #end #foreach($column in $tableInfo.fullColumn) ##使用宏定义实现get,set方法 #getSetMethod($column) #end @Override public String toString() &#123; return \\&quot;$!&#123;tableInfo.name&#125;&#123;\\&quot; + #foreach($column in $tableInfo.fullColumn) #if(!$foreach.hasNext) $tool.append(&#x27;\\&quot;&#x27;, \\&quot;$column.name=\\&quot;, &#x27;\\&quot; + &#x27;, $column.name, &#x27; + &#x27;) $tool.append(&#x27;\\&quot;&#x27;, &#x27;&#125;&#x27;, &#x27;\\&quot;;&#x27;) #else $tool.append(&#x27;\\&quot;&#x27;, \\&quot;$column.name=\\&quot;, &#x27;\\&quot; + &#x27;, $column.name, &#x27; + \\&quot;&#x27; , &#x27;,&#x27;, &#x27;\\&quot;&#x27;, &#x27; +&#x27;) #end #end &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; $entityShortType $entityVarName = ($entityShortType) o; return #foreach($column in $tableInfo.fullColumn) #if(!$foreach.hasNext) Objects.equals($column.name, $entityVarName.$column.name); #else Objects.equals($column.name, $entityVarName.$column.name) &amp;&amp; #end #end &#125; @Override public int hashCode() &#123; return Objects.hash(#foreach($column in $tableInfo.fullColumn) #if(!$foreach.hasNext)$tool.append($column.name)#else$tool.append($column.name,\\&quot;,\\&quot;) #end #end ); &#125; &#125; &quot; &#125;, &#123; &quot;name&quot; : &quot;repository.java.vm&quot;, &quot;code&quot; : &quot;##导入宏定义、设置包名、类名、文件名##导入宏定义 $!&#123;define.vm&#125; #setPackageSuffix(\\&quot;repository\\&quot;) #setTableSuffix(\\&quot;Repository\\&quot;) #save(\\&quot;/repository\\&quot;, \\&quot;Repository.java\\&quot;) ##拿到主键 #if(!$tableInfo.pkColumn.isEmpty()) #set($pk = $tableInfo.pkColumn.get(0)) #end ##实体类名、主键类名 #set($entityShortType = $!tableInfo.name) #set($entityType = $!tool.append($!tableInfo.savePackageName, \\&quot;.entity.\\&quot;, $!tableInfo.name)) #set($pkShortType = $!pk.shortType) #set($pkType = $!pk.type) import $pkType; import $entityType; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.stereotype.Repository; /** * $!&#123;tableInfo.comment&#125;持久层 * * @author $!author * @since $!time.currTime() */ @Repository public interface $!&#123;tableName&#125; extends JpaRepository&lt;$entityShortType, $pkShortType&gt; &#123; &#125; &quot; &#125;, &#123; &quot;name&quot; : &quot;service.java.vm&quot;, &quot;code&quot; : &quot;##导入宏定义、设置包名、类名、文件名##导入宏定义 $!&#123;define.vm&#125; #setPackageSuffix(\\&quot;service\\&quot;) #setTableSuffix(\\&quot;Service\\&quot;) #save(\\&quot;/service\\&quot;, \\&quot;Service.java\\&quot;) ##拿到主键 #if(!$tableInfo.pkColumn.isEmpty()) #set($pk = $tableInfo.pkColumn.get(0)) #end ##实体类名、主键类名 #set($entityShortType = $!tableInfo.name) #set($entityType = $!tool.append($!tableInfo.savePackageName, \\&quot;.entity.\\&quot;, $!tableInfo.name)) #set($entityVarName = $!tool.firstLowerCase($!tableInfo.name)) #set($pkShortType = $!pk.shortType) #set($pkType = $!pk.type) import $pkType; import $entityType; import org.springframework.data.domain.Page; import org.springframework.data.domain.Pageable; import java.util.Collection; import java.util.List; /** * $!&#123;tableInfo.comment&#125;业务层 * * @author $!author * @since $!time.currTime() */ public interface $!&#123;tableName&#125; &#123; /** * 分页列表 * * @param user 条件参数 * @param page 分页参数 * @return 符合条件的分页数据 */ Page&lt;$entityShortType&gt; listPage($entityShortType $entityVarName, Pageable page); /** * 根据 ID 获取详情 * * @param id id * @return 详情对象 */ $entityShortType findById($pkShortType id); /** * 添加数据 * * @param $entityVarName 添加数据内容 */ void save($entityShortType $entityVarName); /** * 更新数据 * * @param $entityVarName 更新的数据内容 */ void update($entityShortType $entityVarName); /** * 删除数据 * * @param ids 删除数据的 id 集合 */ void remove(List&lt;$pkShortType&gt; ids); &#125; &quot; &#125;, &#123; &quot;name&quot; : &quot;serviceImpl.java.vm&quot;, &quot;code&quot; : &quot;##导入宏定义、设置包名、类名、文件名 $!&#123;define.vm&#125; #setPackageSuffix(\\&quot;service.impl\\&quot;) #setTableSuffix(\\&quot;ServiceImpl\\&quot;) #save(\\&quot;/service/impl\\&quot;, \\&quot;ServiceImpl.java\\&quot;) ##拿到主键 #if(!$tableInfo.pkColumn.isEmpty()) #set($pk = $tableInfo.pkColumn.get(0)) #end ##业务层类名、持久层类名、实体名 #set($serviceSortType = $!tool.append($!tableInfo.name, \\&quot;Service\\&quot;)) #set($serviceType = $!tool.append($!tableInfo.savePackageName, \\&quot;.service.\\&quot;, $serviceSortType)) #set($repositorySortType = $!tool.append($!tableInfo.name, \\&quot;Repository\\&quot;)) #set($repositoryType = $!tool.append($!tableInfo.savePackageName, \\&quot;.repository.\\&quot;, $repositorySortType)) #set($repositoryVarName = $!tool.firstLowerCase($!repositorySortType)) #set($entityShortType = $!tableInfo.name) #set($entityType = $!tool.append($!tableInfo.savePackageName, \\&quot;.entity.\\&quot;, $!tableInfo.name)) #set($entityVarName = $!tool.firstLowerCase($!tableInfo.name)) #set($pkShortType = $!pk.shortType) #set($pkType = $!pk.type) import $pkType; import $entityType; import $serviceType; import $repositoryType; import org.springframework.stereotype.Service; import javax.annotation.Resource; import org.springframework.data.domain.Page; import org.springframework.data.domain.Pageable; import org.springframework.transaction.annotation.Transactional; import java.util.Collection; import java.util.List; import java.util.stream.Collectors; import java.util.stream.StreamSupport; /** * $!&#123;tableInfo.comment&#125;业务层 * * @author $!author * @since $!time.currTime() */ @Service public class $!&#123;tableName&#125; implements $!serviceSortType &#123; @Override public Page&lt;$entityShortType&gt; listPage($entityShortType $entityVarName, Pageable page) &#123; return $!&#123;repositoryVarName&#125;.findAll(page); &#125; @Override public $entityShortType findById($pkShortType id) &#123; return $!&#123;repositoryVarName&#125;.findById(id).orElseThrow(); &#125; @Override @Transactional(rollbackFor = Exception.class) public $entityShortType save($entityShortType $entityVarName) &#123; $!&#123;repositoryVarName&#125;.save($entityVarName); &#125; @Override @Transactional(rollbackFor = Exception.class) public void update($entityShortType $entityVarName) &#123; $!&#123;repositoryVarName&#125;.save($entityVarName); &#125; @Override @Transactional(rollbackFor = Exception.class) public void remove(List&lt;$pkShortType&gt; ids) &#123; $!&#123;repositoryVarName&#125;.deleteAllById(ids); &#125; private final $repositorySortType $repositoryVarName; public $!&#123;tableName&#125; ($repositorySortType $repositoryVarName) &#123; this.$repositoryVarName = $repositoryVarName; &#125; &#125; &quot; &#125;, &#123; &quot;name&quot; : &quot;record.java.vm&quot;, &quot;code&quot; : &quot;##引入宏定义 $!&#123;define.vm&#125; ##使用宏定义设置回调（保存位置与文件后缀） #save(\\&quot;/entity\\&quot;, \\&quot;.java\\&quot;) ##使用宏定义设置包后缀 #setPackageSuffix(\\&quot;entity\\&quot;) import jakarta.persistence.Entity; import jakarta.persistence.GeneratedValue; import jakarta.persistence.GenerationType; import jakarta.persistence.Id; ##使用全局变量实现默认包导入 $!&#123;autoImport.vm&#125; import java.io.Serial; import java.io.Serializable; #set($entityShortType = $!tableInfo.name) #set($entityType = $!tool.append($!tableInfo.savePackageName, \\&quot;.entity.\\&quot;, $!tableInfo.name)) #set($entityVarName = $!tool.firstLowerCase($!tableInfo.name)) #set($pkType = $!pk.type) ##使用宏定义实现类注释信息 #tableComment(\\&quot;实体类\\&quot;) @Entity(name = \\&quot;$!tool.hump2Underline($!&#123;tableInfo.name&#125;)\\&quot;) public record $!&#123;tableInfo.name&#125;( #foreach($column in $tableInfo.fullColumn) #if($&#123;column.comment&#125;)/** * $&#123;column.comment&#125; */#end #if($&#123;column.name&#125; == \\&quot;id\\&quot;) @Id @GeneratedValue(strategy = GenerationType.IDENTITY) #end #if(!$foreach.hasNext) $!&#123;tool.getClsNameByFullName($column.type)&#125; $!&#123;column.name&#125; #else $!&#123;tool.getClsNameByFullName($column.type)&#125; $!&#123;column.name&#125;, #end #end ) implements Serializable &#123; &#125; &quot; &#125; ] &#125; &#125;, &quot;columnConfig&quot; : &#123; &#125;, &quot;globalConfig&quot; : &#123; &#125;&#125;","tags":["idea plugin","easycode"],"categories":["IDEA"]},{"title":"NodeJs","path":"/p/a630c4b5/","content":"NodeJs Node文档http://nodejs.cn/learn/ 一、常用命令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# node versionnode -v# 后台启动 推荐使用 pm2nohup 脚本命令 &amp;# 查看npm版本npm -v# 全局安装npm install &lt;package-name&gt; -g# 所在项目安装npm install &lt;package-name&gt;# 更新单个指定包npm update &lt;package-name&gt;# 更新所有可以更新的包npm update# 卸载npm uninstall &lt;package-name&gt;# 搜索npm search &lt;package-name&gt;# 查看全局安装模块信息，不带 -g 代表查询安装的所有模块信息npm list -gnpm ls# 列出全局安装的模块 带上 --depth 0 不深入到包的支点 更简洁npm list -g --depth 0# 查看 npm 配置npm config list# 检查可更新依赖npm outdated# 设置全局包依赖镜像地址npm config set registry https://registry.npmmirror.com# 回退npm到指定版本npm install npm@6.14 -g# 升级npm到最新版本npm install npm -g# 显示 npm install -g 全局安装的位置npm root -g # 移除项目未使用的模块npm prune npm install 可简写为 npm inpm run 相关：除了 npm run start 和 npm run test，其它的命令都不能省略 run。 二、Yarnnpm 是 Node 自带的包管理工具，使用起来很方便。也可以使用 yarn，yarn 是 facebook 发布的一款取代npm的包管理工具，详情请戳 yarn官网介绍 12345678910# 安装 yarn 包管理工具npm install -g yarn# 查看 yarn 版本yarn --version# 查询源yarn config get registry# 更换国内源yarn config set registry https://registry.npm.taobao.org --globalyarn config set disturl https://npm.taobao.org/dist --global 三、pnpmpnpm 是微软发布的一款 Node 平台的包管理工具，用的人数也挺多的。默认使用 npm 的安装源。 官方文档https://pnpm.io/ 四、Node 版本过高package.json 里在运行命令中加入以下内容再运行就可以了 12345...&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;set NODE_OPTIONS=--openssl-legacy-provider &amp;&amp; vue-cli-service serve&quot;, &#125;,...","tags":["nodejs","npm"],"categories":["Skill","Node"]},{"title":"Nginx的安装与简单使用","path":"/p/14259ba7/","content":"Nginx的安装与简单使用。 一、安装官网下载所需要的版本，解压。 Nginx 有几个模块，实际中非常实用，但在编译安装的时候默认是不安装的，需要加入命令选项。当然，如果之前没有安装，后续也是可以再次编译替换的。具体配置可以参阅：http://nginx.org/en/docs/configure.html 123456789101112# 支持 ssl 即 HTTPS--with-http_ssl_module# HTTP2--with-http_v2_module# 修改替换相应的字符串--with-http_sub_module# gunzip 压缩--with-http_gunzip_module# gzip--with-http_gzip_static_module# 提供获得基本状况的信息--with-http_stub_status_module 以上几个模块默认都是不安装的，如果目前已经存在线上服务的版本，那么再次下载和线上版本一致的 Nginx,然后重新编译（不要安装），把需要用到的模块编译进去，然后替换源文件即可。（如果线上版本较低，可以直接编译安装，覆盖原来的也可以，注意配置备份）。 那么这里就以更新为主喽，新安装的比较简单，编译完成后直接安装（make install）。 123456789101112# 安装依赖包sudo apt-get install libpcre3 libpcre3-dev zlib1g-dev libssl-dev build-essential# 下载新的源文件wget https://nginx.org/download/nginx-1.22.1.tar.gz# 解压后进入解压目录tar -xzvf nginx-1.22.1.tar.gzcd nginx-1.22.1# 配置./configure --prefix=/usr/local/nginx --with-http_sub_module --with-http_stub_status_module --with-http_ssl_module --with-http_gunzip_module --with-http_gzip_static_module# 编译make 经过以上步骤后，在该目录下会多出来一个 objs 的目录，该目录下有一个 nginx 文件，这个就是新编译可执行文件。现在有两种选择：备份目前正在使用的 .../sbin/nginx 文件，然后拷贝这个新的到该目录下；或者直接替换旧的（最好版本一致时这样做）。 二、命令12345# 停止./nginx -s stop# 重启./nginx -s reload 三、配置附一份 Nginx 默认的配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; # &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; # &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&#x27;s document root # concurs with nginx&#x27;s one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; 修改配置文件再次启动报错：[emerg]: bind() to 0.0.0.0:80 failed (80: Address already in use)，执行命令：sudo fuser -k 80&#x2F;tcp，然后 .&#x2F;nginx 1. 基础配置conf/nginx.conf12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server &#123; listen 80; server_name localhost; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; location / &#123; # 配置反向代理 proxy_pass http://127.0.0.1:8080; &#125; # 配置静态资源服务器 location ~ .*\\.(css|gif|ico|jpg|js|png|ttf|woff)$ &#123; expires 24h; # 指定图片存放路径 root D:/image/; proxy_store on; proxy_store_access user:rw group:rw all:rw; # 图片路径 proxy_temp_path D:/image/; proxy_redirect off; proxy_set_header Host 127.0.0.1; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 10m; client_body_buffer_size 1280k; proxy_connect_timeout 900; proxy_send_timeout 900; proxy_read_timeout 900; proxy_buffer_size 40k; proxy_buffers 40 320k; proxy_busy_buffers_size 640k; proxy_temp_file_write_size 640k; if ( !-e $request_filename) &#123; proxy_pass http://127.0.0.1:80; #代理访问地址 &#125; &#125; &#125;\t&#125; 重新启动Nginx，./nginx -s reload，然后用浏览器输入：localhost，回车。 2. 配置负载均衡conf/nginx.conf123456789101112131415161718192021222324252627http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; upstream server_name &#123; server localhost:8080; server localhost:8081; server localhost:8082; &#125; server &#123; listen 80; server_name localhost; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; location / &#123; proxy_pass http://server_name; &#125; &#125;&#125; 地址栏输入 localhost 刷新观察每个网页的标题，看是否不同。 经过测试，三台服务器出现的概率各为33.3333333%，交替显示。 如果其中一台服务器性能比较好，想让其承担更多的压力，可以设置权重。 比如想让 8080 出现次数是其它服务器的2倍，则修改配置如下： 1234567891011121314151617181920212223242526http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; upstream server_name &#123; server localhost:8080; server localhost:8081 weight=2; server localhost:8082; &#125; server &#123; listen 80; server_name localhost; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; location / &#123; proxy_pass http://server_name; &#125; &#125;&#125; 3. 映射资源文件目录我们可以在服务器上使用Nginx映射出一个目录作为共享的目录，然后访问该可以进行下载。有许多网站使用了该技术。 1234567891011121314151617181920212223server &#123; listen 8181; server_name localhost; #配置跨域 #add_header Access-Control-Allow-Origin *; #add_header Access-Control-Allow-Headers X-Requested-With; #add_header Access-Control-Allow-Methods GET,POST,OPTIONS; #charset koi8-r; #access_log logs/host.access.log main; location /share &#123; # /share 的上级全目录 root /data; # 如果使用 alias，最后一定要加 /，而且只能用于 location 块 # alias /data/share/ # 显示索引，nginx内部的简单索引 autoindex on; # 显示文件的时间 autoindex_localtime on; &#125;&#125; 在配置映射目录的时候，容易出现问题。因为在 location 块中可以使用两种目录配置方式。一种是 root，一种是 alias。如果使用的是 root（不是root用户），那么 location 后面应该填写 URL 访问的路径，而 root 后跟上级路径。如果使用的 alias，那么后面直接写共享的绝对路径即可，注意在绝对路径最后面加上 ”&#x2F;“，而 location 后依然只写 URL 访问路径即可。以这里的配置为例。那么我访问的地址应该是 xxx.com:8181/share，我的共享目录是 /root/share。 4. 使用不同的端口号部署多个项目12345678910111213141516171819202122232425262728server &#123; listen 80; server_name localhost; location / &#123; root html; index index.html index.htm; &#125; location /wasd &#123; alias /usr/local/nginx/test/; index index.html index.htm; &#125; &#125;\tserver &#123; listen 8081; server_name localhost; location /qwer &#123; root /usr/local/nginx/test; index index.html index.htm; &#125; location /prod-api&#123; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://localhost:8080/; &#125;\t&#125;","tags":["nginx"],"categories":["Skill","Nginx"]},{"title":"RabbitMQ","path":"/p/b543ced0/","content":"RabbitMQ是轻量级的，在AMQP（Advanced Message Queuing Protocol ）基础上实现的，易于在本地和云中部署。它支持多种消息传递协议。RabbitMQ 可以部署在分布式和联合配置中，以满足高规模、高可用性的需求。 一、介绍 1. RabbitMQ的几种模型 二、操作 RabbitMQ的常用命令 镜像队列：（使用最多） 、 一、介绍RabbitMQ 在许多操作系统和云环境上运行，并为大多数流行语言提供了广泛的开发人员工具。比如提供了 Java、Spring Framework、.NET、Ruby、Python、PHP、JS、GO等语言的客户端、适配器和工具。 官方学习教程https://www.rabbitmq.com/getstarted.html 1. RabbitMQ的几种模型 二、操作RabbitMQ的常用命令1234567891011121314rabbitmqctl list_users # 查看用户列表rabbitmqctl add_user admin 123456 #添加用户名和密码rabbitmqctl set_permissions -p /admin&quot;.*&quot; &quot;.*&quot; &quot;.*&quot; #修改权限rabbitmqctl set_user_tags admin administrator #添加用户角色#守护模式启动（后台运行）rabbitmq-server -detached# 停止服务rabbitmqctl stop# 查看状态rabbitmqctl status # 重启 rabbitmq 服务rabbitmq-server restart 启用插件的同时并启动服务：rabbitmq-plugins enable rabbitmq_management，这个插件是 RabbitMQ 自带的，便于我们查看系统的状态数据，启用这个插件之后才可以使用 http://IP地址:15672 访问网页管理页面，查看具体信息。默认登录的初始账号密码为 guest。 注意： 在较新的版本中，默认的账号只能以本地 localhost 的方式访问，如果服务在远程启动，本地进行远程访问操作时登录可能会出现 User can only log in via localhost 的情况，解决办法就是新添加一个超级管理员账户，使用这个新添加的账户登录。5672 用于客户端使用，15672 用于网页控制。 镜像队列：（使用最多）123456# 策略说明rabbitmqctl set_policy [-p &lt;vhost&gt;] [--priority &lt;priority&gt;] [--apply-to &lt;apply-to&gt;] &lt;name&gt; &lt;pattern&gt; &lt;definition&gt;# 查看当前策略：rabbitmqctl list_policies# 删除队列：rabbitmqctl clear_policy ha-all -p vhost 可选参数，针对指定 vhost 下的 queue 进行设置 name: policy 的名称 pattern: queue 的匹配模式（正则表达式） definition: 镜像定义，包括三个部分ha-mode、ha-params、ha-sync-mode ha-mode 指明镜像队列的模式，有效值 all&#x2F;exactly&#x2F;nodesall 表示在集群所有的节点上进行镜像exactly 表示在指定个数的节点上进行镜像，节点的个数由 ha-params 指定nodes 表示在指定的节点上进行镜像，节点名通过 ha-params 指定 ha-params: ha-mode 模式需要用到的参数ha-sync-mode: 进行队列中消息的同步方式，有效值为 automatic 和 manualpriority: 可选参数，policy 的优先级。","tags":["rabbitmq"],"categories":["Skill","MQ"]},{"title":"Ubuntu安装Hadoop+Hive","path":"/p/6d9315fe/","content":"Ubuntu 搭建 Hadoop + Hive 环境实例。 一、官网集群配置文档关于安装版本官方文档https://cwiki.apache.org/confluence/display/HADOOP/Hadoop+Java+Versions 二、版本说明推荐使用新版本（3.x），浪子因为所在公司使用的 2.x 版本，所以采用的 2.x 的最高版本。 java-8hadoop-2.10.xhive-2.3.9 三、安装 安装 jdk 12345678910111213141516$ sudo apt install openjdk-8-jdk# 查看路径（虽然使用 apt 安装不需要配置环境变量，但是 hadoop 无法识别，依然需要手动导入）# /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java 就是安装的路径# 如果你的 jdk 是自己上传压缩包配置的可以跳过此步骤$ which java /usr/bin/java$ file /usr/bin/java /usr/bin/java: symbolic link to /etc/alternatives/java$ file /etc/alternatives/java /etc/alternatives/java: symbolic link to /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java$ file /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=0d167f96ccfa5695cabf1b40056a77dc9bb8ab1a, for GNU/Linux 3.2.0, stripped# 下载 oracle 驱动cd hivepath/libwget https://download.oracle.com/otn-pub/otn_software/jdbc/217/ojdbc8.jar 配置环境变量： /etc/profile1234export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64export HADOOP_HOME=hadooppathexport HIVE_HOME=hivepathexport PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$HIVE_HOME/bin 检验 Hadoop 是否安装成功： 12source /etc/profilehadoop version 修改 Hive 配置文件cd …&#x2F;hivepath&#x2F;confcp hive-env.sh.template hive-env.sh hive-env.sh12# 配置一下 Hadoop 的安装路径HADOOP_HOME=hadooppath 添加 hive-site.xml 文件 新建 hive-site.xml 文件，添加以下内容。 hive-site.xml1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot;?&gt;&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;&lt;configuration&gt;&lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt; &lt;value&gt;jdbc:oracle:thin:@*********:1521:fangweidbt&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt; &lt;value&gt;oracle.jdbc.OracleDriver&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt; &lt;value&gt;******&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt; &lt;value&gt;******&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt; 初始化 1schematool -dbType oracle -initSchema 然后就可以使用了。 12hiveshow databases; 三、Hadoop集群搭建一般在生产环境中使用 Hadoop 都是集群部署（毕竟是大数据，数据集比较大），如果采用一台服务器存储，万一需要维护或者宕机就不能对外提供服务了。官网集群配置文档 1. 前置准备 jdk(注意配置环境变量)：安装版本官方文档https://cwiki.apache.org/confluence/display/HADOOP/Hadoop+Java+Versions ssh 2. 开始 创建服务器地址映射 /etc/hosts1234...# ip hostname 域名192.168.10.1 node1 test.com SSH 配置 123# 密钥生成省略，使用 ssh-key# 复制公钥到目标主机ssh-copy-id hostname 集群时间同步 12sudo apt install ntpdatentpdate cn.pool.ntp.org ntp 常用服务器：https://dns.icoa.cn/ntp/ 安装 Hadoop 123# 官网下载安装包并解压# 复制到多台机器scp -r /sourcepath/ root@hostname:/targetpath/ 修改配置文件配置文件都在 Hadoop 安装目录的 etc&#x2F;hadoop&#x2F; 下。 hadoop-3.3.4/etc/hadoop/hadoop-env.sh123456export JAVA_HOME=/pathexport HDFS_NAMENODE_USER=export HDFS_DATANODE_USER=export HDFS_SECONDARYNAMENODE_USER=export HDFS_RESOURCEMANAGER_USER=export HDFS_NODEMANAGER_USER= core-site.xml123456789101112131415161718192021222324252627282930313233&lt;!-- 默认使用的文件系统，支持 file、HDFS、GFS、Amazon等 --&gt;&lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://ip/name:port&lt;/value&gt;&lt;/property&gt;&lt;!-- Hadoop 本地保存数据路径 --&gt;&lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/path&lt;/value&gt;&lt;/property&gt;&lt;!-- 设置 HDFS Web UI 用户身份 --&gt;&lt;property&gt; &lt;name&gt;hadoop.http.staticuser.user&lt;/name&gt; &lt;value&gt;user&lt;/value&gt;&lt;/property&gt;&lt;!-- hive 用户代理 --&gt;&lt;property&gt; &lt;name&gt;hadoop.proxyuser.root.hosts&lt;/name&gt; &lt;value&gt;*&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hadoop.proxyuser.root.groups&lt;/name&gt; &lt;value&gt;*&lt;/value&gt;&lt;/property&gt;&lt;!-- 文件系统垃圾桶保存时间 --&gt;&lt;property&gt; &lt;name&gt;fs.trash.interval&lt;/name&gt; &lt;value&gt;1440&lt;/value&gt;&lt;/property&gt; hdfs-site.xml12345&lt;!-- SNN 进程运行机器位置信息 --&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt; &lt;value&gt;ip/hostname:port&lt;/value&gt; &lt;/property&gt; mapred-site.xml1234567891011121314151617181920212223242526272829303132&lt;!-- MR 程序默认运行模式，yarn：集群模式 local：本地模式 --&gt;&lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt;&lt;/property&gt;&lt;!-- MR 程序历史服务器地址 --&gt;&lt;property&gt; &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt; &lt;value&gt;ip/hostname:port&lt;/value&gt;&lt;/property&gt;&lt;!-- MR 程序历史服务器 web 地址 --&gt;&lt;property&gt; &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt; &lt;value&gt;ip/hostname:port&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;yarn.app.mapreduce.am.env&lt;/name&gt; &lt;value&gt;HADOOP_MAPRED_HOME=$&#123;HADOOP_HOME&#125;&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;mapreduce.map.env&lt;/name&gt; &lt;value&gt;HADOOP_MAPRED_HOME=$&#123;HADOOP_HOME&#125;&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;mapreduce.reduce.env&lt;/name&gt; &lt;value&gt;HADOOP_MAPRED_HOME=$&#123;HADOOP_HOME&#125;&lt;/value&gt;&lt;/property&gt; yarn-site.xml12345678910111213141516171819202122232425262728293031323334353637383940&lt;!-- yarn 集群主角色运行机器位置 --&gt;&lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;ip/hostname&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt;&lt;/property&gt;&lt;!-- 是否对容器实施物理内存限制 --&gt;&lt;property&gt; &lt;name&gt;yarn.nodemanager.pmem-check-enabled&lt;/name&gt; &lt;value&gt;false&lt;/value&gt;&lt;/property&gt;&lt;!-- 是否对容器实施虚拟内存限制 --&gt;&lt;property&gt; &lt;name&gt;yarn.nodemanager.vmem-check-enabled&lt;/name&gt; &lt;value&gt;false&lt;/value&gt;&lt;/property&gt;&lt;!-- 开启日志 --&gt;&lt;property&gt; &lt;name&gt;yarn.log.aggregation-enabled&lt;/name&gt; &lt;value&gt;true&lt;/value&gt;&lt;/property&gt;&lt;!-- yarn 历史服务器地址 --&gt;&lt;property&gt; &lt;name&gt;yarn.log.server.url&lt;/name&gt; &lt;value&gt;http://ip|name/jobhistory/logs&lt;/value&gt;&lt;/property&gt;&lt;!-- 历史日志保存时间 7 天 --&gt;&lt;property&gt; &lt;name&gt;yarn.log-aggregation.retain-seconds&lt;/name&gt; &lt;value&gt;604800&lt;/value&gt;&lt;/property&gt; workers1域名 集群启动 首次运行初始化：hdfs namenode -format","tags":["linux","ubuntu","hadoop","hive"],"categories":["Linux","Ubuntu"]},{"title":"Ubuntu 服务器配置","path":"/p/af7fa1dd/","content":"Ubuntu Server 22.04 配置，桌面版应该也能用，如果你喜欢使用命令行的话，应该都没问题。 一、Ubuntu常用命令1. apt-get123456789101112# 查看所有的安装软件dpkg --list# 安装已经下载好的 deb 安装包dpkg -i 安装包# 更新所有可更新的软件包sudo apt update &amp;&amp; sudo apt upgrade# 卸载指定软件并删除配置文件sudo apt --purge remove 包名# 清理不再使用的依赖和库文件sudo apt autoremove 二、基本配置1. 时区设置Ubuntu 可以使用内置的 timedatectl 设置系统的时区。 1234567891011# 查看当前的时区timedatectl# 查看支持的时区列表timedatectl list-timezones# 是否含有中国时区timedatectl list-timezones | grep Asia/Shanghai# 设置中国时区timedatectl set-timezone Asia/Shanghai# 无需重启，再次查看timedatectl 2. 语言设置1234567891011121314151617181920212223# 查看当前系统的语言配置locale# 如果使用的 Ubuntu 22.04 以上使用这个命令将更加简单容易，选择完成之后注销重启sudo dpkg-reconfigure locales# 再次查看配置locale# 下面的适用旧版本# 列出所有启用的区域设置locale -a# 编辑 locale.gen 文件vim /etc/locale.gen# 取消 zh_CN.UTF-8 UTF-8 en_US.UTF-8 UTF-8 两行的注释# 编辑保存后，执行以下命令locale-gen# 显示正在使用的 Locale 和相关的环境变量locale# 设置整个系统使用的区域设置localectl set-locale LANG=zh_CN.UTF-8# 立即生效unset LANG 如果使用上面的立即生效命令仍然有问题，没有生效，请重启计算机。 3. 下载工具Linux 下载工具有很多，比如 Motrix、文件蜈蚣等跨平台的免费开源下载器，而且还有许多命令行下载器，如果喜欢命令行可以使用 wget 或者 curl。 如果你想了解一下 wget VS curl 的区别：可以访问这篇文章：https://www.geeksforgeeks.org/difference-between-wget-vs-curl/ 1234# 查看本机基础信息curl ipinfo.io# 本机公网curl cip.cc 4. Vim 配置如果 Vim 配置的好，那么日常编辑文件是非常流畅的。很多大佬用 Vim 写代码，当然，浪子做不到 QAQ。 Vim 的全局配置文件在 /etc/vim/vimrc 或者 /etc/vimrc，对所有用户生效；用户的配置文件一般在 ~/.vimrc 中。 我们修改全局的配置，编辑 /etc/vim/vimrc 文件，没有的话可以手动创建一个。下面给了一些简单实用的配置。 .vimrc12345678910111213141516171819202122232425262728293031&quot; 自动缩进set autoindent&quot; 语法高亮set syntax=on&quot; Tab键的宽度set tabstop=4&quot; 突出显示当前行set cursorline&quot; 搜索忽略大小写set ignorecase&quot; 去掉输入错误的提示声音set noeb&quot; 高亮显示匹配的括号set showmatch&quot; 总是显示行号set nu&quot; 侦测文件类型filetype on&quot; 打开文件类型检测, 加了这句才可以用智能补全set completeopt=longest,menu&quot;代码补全 set completeopt=preview,menu&quot; 增强模式中的命令行自动完成操作set wildmenu&quot; 状态行显示的内容（包括文件类型和解码）set statusline=%F%m%r%h%w\\ [FORMAT=%&#123;&amp;ff&#125;]\\ [TYPE=%Y]\\ [POS=%l,%v][%p%%]\\ %&#123;strftime(\\&quot;%d/%m/%y\\ -\\ %H:%M\\&quot;)&#125;set statusline=[%F]%y%r%m%*%=[Line:%l/%L,Column:%c][%p%%]&quot; 总是显示状态行set laststatus=2 三、常用软件1. Redis12345wget https://download.redis.io/redis-stable.tar.gztar -xzvf redis-stable.tar.gzcd redis-stablemake &amp;&amp; make installredis-server &amp; 2. MySQLapt-get安装：https://blog.lanluo.cn/8662 3. Docker12345678910111213141516171819202122232425262728293031# 卸载旧版本sudo apt-get remove docker docker-engine docker.io containerd runcsudo apt-get updatesudo apt-get install \\ ca-certificates \\ curl \\ gnupg \\ lsb-release# Add Docker’s official GPG key:sudo mkdir -p /etc/apt/keyringscurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg# 设置稳定版仓库echo \\&quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\$(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null# 更新包索引sudo apt-get update####################### 下面二选一 ############################## 1. 安装最新版本的 Docker Engine-Community 和 containerd ，或者转到下一步安装特定版本：sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin# 2.# 查看版本apt-cache madison docker-ce# 选择指定的版本安装sudo apt-get install docker-ce=&lt;VERSION_STRING&gt; docker-ce-cli=&lt;VERSION_STRING&gt; containerd.io docker-compose-plugin 4. btop++1234567# 下载解压安装wget https://github.com/aristocratos/btop/releases/download/v1.2.8/btop-x86_64-linux-musl.tbzmkdir btop &amp;&amp; tar xvf btop-x86_64-linux-musl.tbz -C btopcd btop./install.sh# 运行btop 5. Nodejs123# Using Ubuntucurl -fsSL https://deb.nodesource.com/setup_16.x | sudo -E bash -sudo apt-get install -y nodejs 6. open-jdk1sudo apt-get install openjdk-8-jdk 四、其它1. 查找apt安装的软件的路径这里以jdk为例 123which java# 多次执行，直到最后打印出一些系统信息file 上一条命令打印的路径 2. 开放指定端口随着 Ubuntu 的更新，它的各种软件也在更新，以前用 firewall，新版本（22.04）已经默认使用 ufw，相比较而言，UFW command more easily，不过具体使用这里就不详细写了，可以参考官网的说明，很简单。 1234567891011121314151617181920212223# 启动防火墙systemctl start firewalld# --zone 作用域 --add-port 格式 端口/通讯协议 --permanent 永久生效firewall-cmd --zone=public --add-port=1935/tcp --permanent# 重启firewall-cmd --reload# 查看当前所有tcp端口netstat -ntlp# 查看所有1935端口使用情况 netstat -ntulp | grep 1935# 启用 ufwufw enable# 禁用 ufwufw disable# 查看状态ufw status verbose# 放行端口ufw allow port/协议（TCP|UDP）# 关闭端口ufw deny port/协议# 允许特定 IP 访问ufw allow from IP 3. ftp服务搭建下载 完成后上传至服务器，执行以下命令安装 1dpkg -i xxx.deb 安装完成后编辑 /etc/vsftpd.conf 文件： 123456789101112131415161718192021listen=NOlisten_ipv6=YESanonymous_enable=NOlocal_enable=YESwrite_enable=YESlocal_umask=022dirmessage_enable=YESuse_localtime=YESxferlog_enable=YESconnect_from_port_20=YESchroot_local_user=YESsecure_chroot_dir=/var/run/vsftpd/emptypam_service_name=vsftpdrsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pemrsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.keyssl_enable=NO# 新增pasv_enable=Yespasv_min_port=10000pasv_max_port=10100allow_writeable_chroot=YES 更新防火墙：sudo ufw allow from any to any port 20,21,10000:10100 proto tcp 重启服务：sudo systemctl restart vsftpd 创建新用户并设置密码： 123456789101112131415sudo useradd -m ftptestsudo passwd ftptestNew password: Retype new password: passwd: password updated successfully # 出于安全考虑，限定用户ftpuser不能登录，只能ftpusermod -s /sbin/nologin ftpuser# 出于安全考虑，我们将禁用此用户的 ssh 权限。输入sudo vim /etc/ssh/sshd_config# 在此文件中添加以下行，然后重启 SSH sudo systemctl restart sshdDenyUsers ftpuser 添加文件(连接 ftp 时展示的目录为登录的用户的主目录，所以为了安全我们使用新建的用户)： sudo echo &quot;this is a simple file&quot; &gt; /home/ftptest/test.txt 然后就可以连接测试了：ftp://ip 五、一些问题1. DockerUbuntu version 22.04Docker version 23.0.1Docker Compose version v2.16.0安装 Docker 工具：snap错误原因： 1Cannot Connect to the Docker Daemon at ‘unix:///var/run/docker.sock’ 解决参考：https://appuals.com/cannot-connect-to-the-docker-daemon-at-unix-var-run-docker-sock/ 如果不能解决，尝试下面的方法： 1234567891011# 停止 dockersystemctl stop docker.socketsystemctl stop docker# 查看 snap 管理的 docker 状态snap services# 停止服务snap stop docker# 然后重启systemctl start docker","tags":["linux","ubuntu"],"categories":["Linux","Ubuntu"]},{"title":"Manjaro安装脚本","path":"/p/5b9e7c7c/","content":"每次重装 manjaro 后都需要安装一些环境，刚开始还好，后面就变得懒了，写一个简单脚本帮助完成安装。 安装脚本下面的安装脚本是针对 Manjaro-KDE 版本，如果各位少侠是使用的 Gnome 的话，输入法不推荐 fcitx5，推荐使用 Ibus。下面的安装工具可以在我的另一篇文章中找到： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#!/bin/bash# yay，下面的所有命令都使用 yay 安装echo &quot;install yay&quot;yes yes | sudo pacman -S yayecho &quot;update system...&quot;yes yes | yay -Syuecho &quot;install yay and update system done!&quot;# fcitx5 输入法echo &quot;install fcitx5...&quot;yes yes | yay -S fcitx5-im fcitx5-rime fcitx5-chinese-addonsecho &quot;install fcitx5 done!&quot;# 输入法写入配置sudo echo -e &quot;GTK_IM_MODULE=fcitx QT_IM_MODULE=fcitx XMODIFIERS=@im=fcitx SDL_IM_MODULE=fcitx GLFW_IM_MODULE=ibus&quot; &gt;&gt; /etc/environmentecho &quot;print /etc/environment content&quot;sudo cat /etc/environmentecho &quot;print /etc/environment content done!&quot;# 字体echo &quot;install fonts...&quot;yes yes | yay -S wqy-bitmapfont wqy-microhei wqy-zenhei wqy-microhei-lite ttf-fira-code woff2-fira-code woff-fira-code ttf-jetbrains-monoecho &quot;install fonts done!&quot;# linux 下好用的工具echo &quot;install utils...&quot;yes yes | yay -S vim flameshot simplescreenrecorderecho &quot;install utils done!&quot;# window 下常用的工具echo &quot;install window some utils...&quot;yes yes | yay -S wemeet-bin electronic-wechat-uos-binecho &quot;install window some utils done!&quot;############################### 开发环境 #################################echo &quot;devlopment environment begin...&quot;# 开发相关软件 vscode、termius、edge、goole 浏览器echo &quot;install some IDE...&quot;yes yes | yay -S visual-studio-code-bin microsoft-edge-stable-bin termius google-chromeecho &quot;install IDE done!&quot;# jdkecho &quot;install jdk...&quot;yes yes | yay -S jdk8-openjdk jdk17-openjdk# 如果有多个版本，设置某个 JDK 版本为默认版本sudo archlinux-java set java-8-openjdkjava -versionecho &quot;install jdk done!&quot;# dockerecho &quot;install docker...&quot;yes yes | yay -S docker docker-compose# 创建 docker 用户组sudo groupadd docker# 将普通用户加入 docker 组中sudo gpasswd -a $USER docker# 更新 docker 组newgrp docker# 测试命令docker psecho &quot;install docker done!&quot;# 配置 git，需要修改为自己的信息echo &quot;git config...&quot;git config --global user.name &quot;username&quot;git config --global user.email &quot;email&quot;echo &quot;git config setting done!&quot;echo &quot;devlopment environment end!&quot; 上面的脚本中 Git 的信息配置需要手动修改为自己的信息。 运行创建 install.sh 文件，复制并修改上面的内容，然后在 bash 中运行以下命令： 1sh install.sh 2&gt;&amp;1 | tee install.log 如果中途有安装失败的情况，可以查看 install.log 文件定位错误信息。","tags":["linux","manjaro脚本"],"categories":["Linux"]},{"title":"ArchLinux/Manjaro安装一些常用软件","path":"/p/ae78c405/","content":"整理一些 ArchLinux&#x2F;Manjaro 中常用的软件。浪子更加推荐去 Arch Wiki 寻找安装方法进行安装，包括在使用中的一些问题也可以在此找到解决办法。 1. yay如果是新安装的系统，请先执行 sudo pacman -Syu 进行更新。 不管你是使用 Arch 还是 Manjaro，浪子都推荐少侠使用该命令，无须加入 sudo 前缀，重要的是，yay 可以安装 AUR 的安装包，pacman 支持的命令 yay 都支持，并且更为丰富。 详细了解https://zhuanlan.zhihu.com/p/363666022 yay 常用命令： 12345678910111213141516171819202122# 安装 yaysudo pacman -S yay# 一些常用的命令# 更新软件库（全部更新）yay -Syu# 安装yay -S &lt;package-name&gt;# 更新指定包软件yay -u &lt;package-name&gt;# 卸载该软件和没有被使用的依赖yay -Rs &lt;package-name&gt;# 若要删除当前未安装的所有缓存包和未使用的同步数据库yay -Sc# 查找符合条件的安装包yay -Ss &lt;package-name&gt;# 查看安装的软件 yay 信息yay -Ps# 查看 yay 默认配置yay -Pd# 查看 yay 当前设置yay -Pg 2. 中文输入法2.1 kde、xfce推荐 fcitx5+rime1yay -S fcitx5-im fcitx5-rime fcitx5-chinese-addons 编辑 /etc/environment 文件，没有这个文件的话可以手动创建，然后添加以下内容，之后重启电脑： /etc/environment12345GTK_IM_MODULE=fcitxQT_IM_MODULE=fcitxXMODIFIERS=@im=fcitxSDL_IM_MODULE=fcitxGLFW_IM_MODULE=ibus fictx5 是一个框架，Rime 是一个输入法，非常推荐使用。 2.2 Gnome桌面推荐 ibus1yay -S ibus ibus-libpinyin GNOME 默认使用 IBus， 所以你只需要安装你需要的输入法引擎（但是 ibus 必须安装），并打开设置界面，通过“键盘”中的“输入源”添加。在你添加至少两个输入源后，GNOME 会在托盘中显示输入选择图标。如果如此操作之后你没有成功，很可能你没有完成 locale-gen。默认切换输入法的快捷键是 Super+Space; 请忽视 ibus-setup 中的添加方法，这不会真的添加新的输入法，且 ibus-setup 中的配置不会对输入法生效。 /home/user/.xprofile1234export GTK_IM_MODULE=ibusexport XMODIFIERS=@im=ibusexport QT_IM_MODULE=ibusibus-daemon -x -d 其它问题请参考Arch Wiki：https://wiki.archlinux.org/title/IBus_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#GNOME 3. 字体安装好了输入法，当然也要有一些字体来辅助，下面有四款开源的字体，其中，文泉驿和思源黑体支持中文，其他两款只支持英文。 1234567891011# 文泉驿字体yay -S wqy-bitmapfont wqy-microhei wqy-zenhei wqy-microhei-lite# 思源字体yay -S noto-fonts-cjk adobe-source-han-sans-cn-fonts adobe-source-han-serif-cn-fonts# Fira Codeyay -S ttf-fira-code woff2-fira-code woff-fira-code# JetBrains Monoyay -S ttf-jetbrains-mono 4. Window的一些软件Window 下的常用的工具软件，一锅炖了，节省篇幅给主要内容。 123456789101112131415161718192021222324# 网易云音乐yay -S netease-cloud-music# linux 3.0版qq已经开始公测（基于 Electron 开发），推荐使用# 浪子不推荐 wine 版，如果机器硬件特别好，使用虚拟机也没问题！# 顺带说一下，新版 linuxqq 已经支持 qq 频道的功能啦！yay -S linuxqq# 微信yay -S deepin-wine-wechat# 如果上面的安装失败，可以安装 wechat-uos 试试yay -S wechat-uos# 腾讯会议yay -S wemeet-bin# 安装 WPS、WPS缺失字体、WPS中文语言包yay -S wps-office-cn ttf-wps-fonts wps-office-mui-zh-cn# 安装向日葵yay -S sunloginclient# 启动向日葵（两个命令都要执行）systemctl start runsunloginclient.servicesunloginclient 浪子还是推荐直接使用浏览器解决所有影音需求，看个人喜好喽～Tim、QQ、微信 看你的系统可不可以运行吧，因为机器有差异，能否运行看运气。使用虚拟机安装体验较好（但是我使用 Linux 为什么还要安装虚拟机跑？）。 5. 一些小工具1yay -S flameshot simplescreenrecorder peek 安装包 说明 flameshot 火焰截图 simplescreenrecorder 录屏软件 peek 动图录制工具 6. 开发工具termius：和 Xshell、SecureCRT 属于同一类产品。有 Android、Linux、Win 多端，分为免费版和付费版。 1234567891011# vscode、edge、termius、googleyay -S visual-studio-code-binyay -S microsoft-edge-stable-binyay -S termiusyay -S google-chrome# jdk 以及源码（如果不安装 src 是没有 .java 源码文件的）yay -S jdk8-openjdk jdk17-openjdk openjdk8-src openjdk17-src# 如果有多个版本，设置某个 JDK 版本为默认版本sudo archlinux-java set java-11-openjdk# dockeryay -S docker docker-compose java 的源码下载后，需要在使用的 IDE 中添加 src.zip 所在的目录，一般都在 &#x2F;usr&#x2F;jvm&#x2F;jdk-version&#x2F;lib&#x2F; 路径下 docker 安装完成后普通用户不能使用相关命令，需要进行一些修改： 12345678# 创建 docker 用户组sudo groupadd docker# 将普通用户加入 docker 组中sudo gpasswd -a $USER docker# 更新 docker 组newgrp docker# 测试命令docker ps 7. nodejs1234# 安装yay -S nodejs npm# 设置淘宝源npm config set registry https://registry.npmmirror.com 如果使用的是普通用户，无法直接使用 npm install -g xxx 进行全局安装（&#x2F;usr&#x2F;lib、&#x2F;usr&#x2F;bin普通用户没有写入权限）。不建议修改相关目录的权限，全局安装建议使用 sudo npm install -g xxx，安装后普通用户也可以直接使用相关命令. 8. VirtualBox安装 virtualbox 之前需要先确定自己 Linux 系统的内核版本，打开系统设置，系统信息；或者直接输入 uname -a 查看系统的内核版本号，在安装的时候选择和自己系统内核版本相同的 module 即可。 1yay -S virtualbox 9. 终端使用zsh或者git-shell 新版本的 xfce 现在也是默认使用 zsh 了，所以此项一般可以忽略。 12345678910111213# 检查是否安装zsh# 如果没有安装那就安装yay -S zsh zsh-completions# 使用 git 终端# 查看可设置终端列表chsh -l# 设置终端路径chsh -s &lt;full-path-to-shell&gt;# 如果您使用的是 systemd-homed，请运行homectl update --shell=&lt;full-path-to-shell&gt; user 其中，full-path-to-shell 是 chsh -l 给出的完整路径。提示：chsh 用作参考。如果列表中不存在最近安装的 shell，则可以手动将其添加到此文件中:/etc/shells如果您要卸载 zsh，那么请您先更改默认的 shell 之后再进行卸载程序安装包。Arch Wiki：https://wiki.archlinux.org/title/Command-line_shell#Changing_your_default_shell 10. snaphttps://snapcraft.io/docs/installing-snapd 数据库MySQL 的话，直接使用 docker 吧，这么大众化的产品，对吧，自己随便玩玩就行。 1. MariaDB1yay -S mariadb 普通用户在 kde 桌面的 zsh 终端中执行启动命令可能会弹出验证特殊身份的面板，该密码不是 root 用户的密码。如果验证失败（失败三次会锁定10分钟），此时切换到 root（su - root） 用户下执行。安装后不要直接启动，先执行以下命令：mariadb-install-db –user&#x3D;mysql –basedir&#x3D;&#x2F;usr –datadir&#x3D;&#x2F;var&#x2F;lib&#x2F;mysqlsystemctl start mariadb.servicemysql -u root -p (默认无密码，直接回车即可)具体细节参考 MariaDB Wiki 2. PostgreSQL1yay -S postgresql 安装完成后，root 用户直接输入 su - postgres，普通用户输入 sudo -i -u postgres，以 [postgres@xxxxxx]$作为前置符号，然后启动服务：systemctl start postgresql.service即可。 提示： 如果创建一个与你的 Arch 用户 ($USER) 同名的数据库用户，并允许其访问 PostgreSQL 数据库的 shell，那么在使用 PostgreSQL 数据库 shell 的时候无需指定用户登录（这样做会比较方便）。以 postgres 用户身份, 添加一个新的数据库用户使用 createuser 命令 1createuser --interactive 输入要增加的角色名称: 登录 Arch 的用户名。以具备读写权限的用户身份，创建一个新的数据库,使用createdb 命令。从你的 shell (不是 以 postrgres 用户的身份) 1createdb myDatabaseName 附：一些问题1. 中文环境改变的问题ArchWikihttps://wiki.archlinux.org/title/Locale_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87) 如果是 KDE Plasma 桌面环境，默认你使用了 UTF-8 的编码，通过以下几步后重启就可以看到更改过来了： 12345678# 删除文件rm -rf ~/.config/plasma-localerc# 编辑 /etc/profile 文件，加入以下内容export LC_ALL=&#x27;zh_CN-UTF8&#x27;# 添加完成保存退出，并更新设置使其生效source /etc/profile# 显示正在使用的 Locale 和相关的环境变量locale 这里只说了 KDE 桌面环境的解决办法，其它的环境在上面的链接里也是有的。如果各位少侠发现自己系统路径下没有 /etc/locale.conf 和 /etc/locale.gen 文件也不用慌，使用 locale-gen 命令后会自动生成，我们只需要编辑这些文件去修改为需要的语言环境就OK。 2. 查看系统版本1lsb_release -a","tags":["linux","arch","manjaro","配置"],"categories":["Linux","Arch"]},{"title":"Linux 入门","path":"/p/509e306a/","content":"Linux 简单入门，这是一个 Linux 的命令学习网站：https://www.linuxshelltips.com/，类似于菜鸟学习网站，只是这个多了一些其它的东西。 一、目录 二、命令 三、VIM常用命令 四、权限 五、Shell 六、用户、用户组命令 七、tar包常用命令 八、任务计划(Crontab)命令 一、目录 目录名称 介绍 &#x2F;home 用户主目录，子目录名称默认以该用户名命名。 &#x2F;root root用户主目录。 &#x2F;bin 常用的命令文件。 &#x2F;sbin 包含系统管理员和root用户所使用的命令文件。 &#x2F;boot Linux系统的内核文件和引导装载程序文件。 &#x2F;opt 第三方应用程序的安装文件。 &#x2F;etc Linux上的大部分配置文件，建议修改之前先备份。 &#x2F;usr 包含可以供所有用户使用的程序和数据。 &#x2F;media 系统自动为某些设置(比如u盘等)挂载提供挂载目录。 &#x2F;mnt 手动为某些设备(比如硬盘)挂载提供挂载目录。 &#x2F;dev 大部分设备文件。 一般编译安装的可执行文件默认路径为 /usr/local/ 二、命令命令部分不会写很详细，网上已经有很多教程参考了。 普通用户是 $ 标识，root 用户是 # 标识， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 查看系统用户名称hostname# 查看当前系统版本lsb_release -a# 显示计算机内核及操作系统的所有信息uname -a | cat /proc/version# 查看当前用户whoami# 查看活动用户w# 查看用户登录日志last# 查看系统所有用户cut -d: -f1 /etc/passwd# 查看系统所有组cut -d: -f1 /etc/group# 查看磁盘空间大小# 查看磁盘空间，不写路径为主要分区空间df -h &lt;path&gt;# 查看目录文件大小，不写路径默认为当前路径du -h &lt;path&gt;# 创建链接文件# -s 创建软链接，相当于 win 下的快捷方式，不加 -s 选项为硬链接。ln -s 源文件 新的链接文件名# 查看内存信息,-g 以G为单位，-m 以MB为单位free# 查看进程ps -efps -aux# 挂载、卸载设备mount 设备 挂载目录umount 设备 挂载目录########################### 安装工具使用 ########################## # 查看所有监听端口 netstat -lntp# 查看所有已经建立的连接netstat -antp# 查看网络统计信息进程netstat -s su root 和 su - root 的区别：个人感觉前者像是临时拥有 root 权限，类似于普通用户使用 sudo apt install xxx；而 su - root 是切切实实的使用 root 用户执行命令。 三、VIM常用命令 命令 说明 yy 复制光标所在行； nyy 复制光标所在行开始的 n 行,n 代表数字； p 粘贴复制的内容 dd 删除光标所在行； ndd 删除光标所在行开始的 n 行，n代表数字； i 在当前光标所在处后进行编辑 o 在当前光标所在行的下一行新开一行进行编辑 O 在光标当前所在行的上一行新开一行插入 gg 让光标移动到文件首(第一行的第一个非空白字符处) G 使光标移动到文件尾(最后一行的第一个非空白字符) u undo，取消上一步操作 Ctrl + r redo，回到 undo 之前 set nu&#x2F;nonu 显示&#x2F;不显示行号 ggdG 清空所有内容 :wq 保存并退出，:x、Shift+zz具有同样效果 :q! 强制退出 VI 和 Vim 的键盘输入略有不同，推荐使用 Vim，服务器等一些最小安装的版本一般需要手动安装。 推荐一个浪子的 VIM 配置，这里修改的全局配置，也可以只为某个用户配置（文件在 ~/.vimrc）： /etc/vim/vimrc12345678910111213141516171819202122232425262728293031&quot; 自动缩进set autoindent&quot; 语法高亮set syntax=on&quot; Tab键的宽度set tabstop=4&quot; 突出显示当前行set cursorline&quot; 搜索忽略大小写set ignorecase&quot; 去掉输入错误的提示声音set noeb&quot; 高亮显示匹配的括号set showmatch&quot; 总是显示行号set nu&quot; 侦测文件类型filetype on&quot; 打开文件类型检测, 加了这句才可以用智能补全set completeopt=longest,menu&quot;代码补全 set completeopt=preview,menu&quot; 增强模式中的命令行自动完成操作set wildmenu&quot; 状态行显示的内容（包括文件类型和解码）set statusline=%F%m%r%h%w\\ [FORMAT=%&#123;&amp;ff&#125;]\\ [TYPE=%Y]\\ [POS=%l,%v][%p%%]\\ %&#123;strftime(\\&quot;%d/%m/%y\\ -\\ %H:%M\\&quot;)&#125;set statusline=[%F]%y%r%m%*%=[Line:%l/%L,Column:%c][%p%%]&quot; 总是显示状态行set laststatus=2 四、权限 可选项 意义 u 用户所有者 g 用户组群 o 其他用户 a 所有用户，系统默认值 + 添加某个权限 -(减号) 取消某个权限 &#x3D;(等号) 赋予给定权限并取消原有权限(如果有的话) r 读取权限 w 写入权限 x 可执行权限 数字表示权限：r&#x3D;4,w&#x3D;2,x&#x3D;1 linux文件权限信息图 给指定的文件添加某个权限： 1234# 数字法chmod 777 file.sh# 字母法chmod u+x,g+wx file.sh 更改文件和目录所有者(二选一)： 12chown -R 用户.组群 文件/目录chown -R 用户:组群 文件/目录 -R 选项是递归操作，把目录下的所有文件全部修改为当前的权限。 只修改所属用户(即用户所有者) 1chown newGroup file 只修改所属用户组(二选一) 12chown .newGroup filechown :newGroup file 五、ShellShell 参见：https://www.geeksforgeeks.org/conditional-statements-shell-script 六、用户、用户组命令12345678910111213141516171819202122232425262728293031323334# 创建用户（如果创建用户的时候没有指定组名，默认会自动创建一个和用户名相同的组名）： useradd -d 设置用户主目录 -g 设置用户组群 username# 修改用户：# 如果添加了 -m 选项，用户旧目录会移动到新的目录中；如果不存在，就新建usermod -l 修改账户名称 -d 设置用户主目录 -m 移动主目录内容到新的位置# 删除用户# 使用这个命令时记得做好备份，会将用户主目录和用户一并删除，所以主目录下的东西最好备份。userdel -rf# 添加组群：groupadd# 修改组群名：groupmod -n newName oldName# 删除组群：groupdel# 给指定的用户设置密码（如果新创建的用户没有密码，那么该用户是无法使用的，类似未激活）passwd 用户名# 添加用户到组群gpasswd -a 用户名 组群名# 删除组群的指定用户gpasswd -d 用户名 组群名# 查看用户属于那些群组groups 用户名# 让属于该群组的当前用户以指定的组群身份登录newgrp 组群名 用户名 七、tar包常用命令12345678910111213141516171819202122# 打包tar -cvf /usr/local/ xxx.tar.xx# 查看包内容tar -tvf xxx.tar# 解包内容tar -xvf xxx.tar# 以下格式的包只需要在选项中加入以下字母即可# 例如 tar -zxvf xxx.tar.gz# gzip(.tar.gz结尾的包)-z# bzip2(.tar.bz2结尾的包)-j# xz(以.tar.xz结尾的包)-J# -C 可以在解压的时候指定解压路径tar -C 指定路径 -zvxf 目标包文件 参数：-v 显示详细处理信息-f 指定归档包文件，后面必须跟 tar 包相关文件 xxx.tar.gz 八、任务计划(Crontab)命令12# 查看当前用户的计划任务服务crontab -l 定时任务说明 在以上各个字段中，还可以使用以下特殊字符： 符号 含义 * 代表所有的取值范围内的数字，如月份字段为*，则表示1到12个月； &#x2F; 代表每一定时间间隔的意思，如分钟字段为 *&#x2F;10，表示每10分钟执行1次。 - 代表从某个区间范围，是闭区间。如“2-5”表示“2,3,4,5”，小时字段中0-23&#x2F;2表示在0~23点范围内每2个小时执行一次。 , 分散的数字（不一定连续），如1,2,3,4,7,9。 crontab注意点:由于各个地方每周第一天不一样，因此Sunday&#x3D;0（第一天）或Sunday&#x3D;7（最后1天）。crontab 有2种编辑方式：直接编辑 /etc/crontab 文件与 crontab –e，其中 /etc/crontab 里的计划任务是系统中的计划任务，而用户的计划任务需要通过 crontab –e 来编辑；每次编辑完某个用户的cron设置后，cron自动在 /var/spool/cron 下生成一个与此用户同名的文件，此用户的cron信息都记录在这个文件中，这个文件是不可以直接编辑的，只可以用 crontab -e 来编辑。crontab 中的 command 尽量使用绝对路径，否则会经常因为路径错误导致任务无法执行。新创建的cron job 不会马上执行，至少要等2分钟才能执行，可重启cron来立即执行。% 在 crontab 文件中表示“换行”，因此假如脚本或命令含有%,需要使用 \\\\% 来进行转义。 Crontab配置实例: 1234567891011121314151617181920#每一分钟执行一次command（因cron默认每1分钟扫描一次，因此全为*即可）* * * * * command#每小时的第3和第15分钟执行command3,15 * * * * command# 每天上午8-11点的第3和15分钟执行command：3,15 8-11 * * * command# 每隔2天的上午8-11点的第3和15分钟执行command：3,15 8-11 */2 * * command# 每个星期一的上午8点到11点的第3和第15分钟执行command3,15 8-11 * * 1 command# 每晚的21:30重启smb30 21 * * * /etc/init.d/smb restart# 每月1、10、22日的4 : 45重启smb45 4 1,10,22 * * /etc/init.d/smb restart","tags":["linux"],"categories":["Linux"]},{"title":"ArchLinux安装教程","path":"/p/a5e4683b/","content":"ArchLinux，很不错的一款 Linux 发行版，不过的它的安装可能让很多人望而却步，不过还有背靠 Arch 的另一个子系统，Manjaro，它的安装就和 Window 一样，简单容易。本篇文章仅作参考。 官方文档https://wiki.archlinux.org/title/Installation_guide#Boot_the_live_environment 一、国内镜像列表 二、前言 三、准备工作 四、开始安装 1. 分区 2. 格式化分区 3. 挂载分区 4. 设置下载镜像源，提升我们后续的下载速度 5. 安装 linux 基本组件 6. 执行以下命令 7. 切换到挂载点 8. 设置时间 9. 设置root用户密码 10. 设置语言和本机名 11. 退出 12. 前期准备 13. 安装驱动(请确保是网络连接正常) 14. 安装桌面(这里安装的Gnome) 15. 尾声 可能遇到的问题 如果是懒人或者小白，可以直接使用 Manjaro 系统，它是 Arch 的子项目，安装简单，Arch有的功能它基本都有，背靠 Arch，可以使用 AUR 仓库，配置简单。安装就和 Window 或者其它的 Linux 一样，只需要一个 ISO 镜像就可以。如果你喜欢漂亮美观，并且个性化，浪子推荐 Manjaro-kde 版本。如果你需要漂亮的同时保持简单整洁，浪子推荐 Manjaro-gnome 版本。如果你的硬件配置较低低，又想充分利用资源的话，推荐使用 Manjaro-xfce 版本。 一、国内镜像列表12345678910111213141516171819202122232425262728#### Arch Linux repository mirrorlist## Generated on 2021-07-27#### China#Server = http://mirrors.163.com/archlinux/$repo/os/$arch#Server = http://mirrors.bfsu.edu.cn/archlinux/$repo/os/$arch#Server = https://mirrors.bfsu.edu.cn/archlinux/$repo/os/$arch#Server = http://mirrors.cqu.edu.cn/archlinux/$repo/os/$arch#Server = https://mirrors.cqu.edu.cn/archlinux/$repo/os/$arch#Server = http://mirrors.dgut.edu.cn/archlinux/$repo/os/$arch#Server = https://mirrors.dgut.edu.cn/archlinux/$repo/os/$arch#Server = http://mirrors.hit.edu.cn/archlinux/$repo/os/$arch#Server = https://mirrors.hit.edu.cn/archlinux/$repo/os/$arch#Server = http://mirror.lzu.edu.cn/archlinux/$repo/os/$arch#Server = http://mirrors.neusoft.edu.cn/archlinux/$repo/os/$arch#Server = https://mirrors.neusoft.edu.cn/archlinux/$repo/os/$arch#Server = http://mirrors.nju.edu.cn/archlinux/$repo/os/$arch#Server = https://mirrors.nju.edu.cn/archlinux/$repo/os/$arch#Server = http://mirror.redrock.team/archlinux/$repo/os/$arch#Server = https://mirror.redrock.team/archlinux/$repo/os/$arch#Server = https://mirrors.sjtug.sjtu.edu.cn/archlinux/$repo/os/$arch#Server = http://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch#Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch#Server = http://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch#Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch#Server = https://mirrors.xjtu.edu.cn/archlinux/$repo/os/$arch#Server = http://mirrors.zju.edu.cn/archlinux/$repo/os/$arch 二、前言下面的内容其实到第 13 步各位少侠就可以去找别的适合自己的教程了，这部分是需要结合自己电脑的配置情况去输入命令的。第 14 步安装桌面少侠们也可以去找自己喜欢的桌面风格样式。这里做个说明节省大家的时间。 三、准备工作 镜像 确保网络良好 (最简单的就是使用手机数据线连接电脑，开启USB共享；条件允许使用网线最佳) 四、开始安装注意，以下命令都是紧接着的（可以不看文字，跟着命令走，确保联网正常，命令输入正确），分步是为了给自己做个说明，也便于理解。我也加入了注释，分区部分的注释建议大家一定要看，浪子尽力做到能让第一次安装的少侠看明白。单个字母就是执行了 fdisk /dev/sda 命令后，我们手动输入的命令。 1. 分区1234567891011121314151617181920fdisk /dev/sda # 进入分区命令行，一直到最后的 w 命令，否则一直处于分区命令模式中g # 该命令创建一个新的 gpt 分区表n # 该命令新建分区，默认是1，直接回车即可 # 这一步是选择柱面，直接回车即可+500M # 给这个新建的gpt分区 500M 的空间，如果硬盘空间足够可以多给，后面我们会把分区格式化n # 新建第二个分区，像上面一样，两次回车，大小给 +8G+8G # 给该分区分配 8G 内存，这个分区稍后我们将格式为交换分区n # 建立第三个分区，然后三次回车键；分配剩余所有的空间，如果有需求可以再添加分区p # 上面分区完了后，输入该命令可以看到刚才的分区信息w # 确认无误后，w 保存退出；分区完成 注： 上面三个分区中 500M 的引导分区是必须的，8G 的交换分区如果内存足够也可以不分，建议都分上，它会在内存不足的时候使用硬盘的部分空间当作虚拟内存使用。基本每种系统都有。剩下的分区就是我们操作的分区了。 2. 格式化分区123456mkfs.fat -F32 /dev/sda1 # 上面分配的 500M 的分区格式，用来存放系统信息mkswap /dev/sda2 # 上面分配的 8G 的分区格式为交换分区mkfs.ext4 /dev/sda3 # ext4 文件格式的分区，这个分区就是我们直接操作的空间了 注： 上面的 sdax 需要根据自己的实际分区情况来定，我这里仅仅是示例，可以看后面的注释部分，中途有确认项选择 y 即可。 3. 挂载分区1234567mount /dev/sda3 /mnt # 把sda3挂载到mnt上mkdir -p /mnt/boot/efi # 创建多级目录mount /dev/sda1 /mnt/boot/efi # 把sda1挂载到/mnt/boot/efi下swapon /dev/sda2 # 这个好像是激活swap分区，我忘了；执行命令后，大家可以去查一下 4. 设置下载镜像源，提升我们后续的下载速度1234# 把系统文件先做个备份cp /etc/pacman.d/mirrorlist/etc/pacman.d/mirrorlist.bak# 向文件添加内容，不理解没关系，执行命令就好echo &quot;https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch&quot; &gt; /etc/pacman.d/mirrorlist 5. 安装 linux 基本组件1pacstrap /mnt base base-devel linux linux-firmware dhcpcd iwd neworkmanager grub efibootmgr vim 6. 执行以下命令123456genfstab -U /mnt &gt;&gt; /mnt/etc/fstab# 查看一下是不是和自己开始的分区个数一致，一样代表写入成功；可以执行后续操作；# 如果失败，请重新再来。一般来说，按照顺序执行正确命令到这里理论不会失败# 在这里这么说是因为这一步比较重要，如果失败可以重新尝试一下cat /mnt/etc/fstab 7. 切换到挂载点1arch-chroot /mnt 8. 设置时间123ln -sf /usr/share/zoneinfo/Asia/Shanghai/etc/localtimehwclock --systohc 9. 设置root用户密码1passwd # 之后输入想设置的密码 10. 设置语言和本机名12345678910111213141516171819202122232425262728echo &quot;en_US.UTF-8 UTF-8&quot; &gt;&gt; /etc/locale.genlocale-genecho &quot;LANG=en_US.UTF-8&quot; &gt;&gt; /etc/locale.conf# 以上三行是设置语言，设置为英文是确保没有乱码，# 因为刚装完的系统是没有中文环境的，如果这里设置中文，安装了以后没有中文字体，将会出现乱码。# 安装完了后可以安装中文环境，然后进行设置# 下面开始写入本机信息echo &quot;本机名，想要啥自己输入&quot; &gt;&gt; /etc/hostnamegrub-install --target=x86_64-efi --efi-directory=/boot/efigrub-mkconfig -o /boot/grub/grub.cfg# 创建一个新用户，以username为例(-m 自动生成用户主目录，-G 加入一个不存在的组 wheel)useradd -m -G wheel username# 设置密码passwd username# 然后编辑一个文件vim /etc/sudoers# 找到 %wheel ALL=(ALL)ALL (vim 编辑时输入 `/#%` 会跳到这儿)去掉前面的注释 `#` ，完成后保存退出。 11. 退出12345678910# 退出 arch-chroot 状态exit# 取消挂载umount /mnt/boot/efiumount /mnt# 重启系统reboot(记得拔掉 U 盘) 12. 前期准备123456789101112131415161718192021222324252627282930313233343536# 重启之后登录进系统，这时我们需要进行安装桌面系统的前期准备sudo cp /etc/pacman.d/mirrorlist/etc/pacman.d/mirrorlist.baksudo vim /etc/pacman.d/mirrorlist# 编辑文件加入下面的一行内容。加入的内容依然是我们之前提升下载速度所加入的# 如果还是之前的设置内容，就不用添加了，保存退出即可。Server = &quot;https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch&quot;# 然后编辑 pacman.conf 文件sudo vim /etc/pacman.conf# 直接到最后，把带有下面的标签部分的的两行的注释取消掉，然后再加入以下内容[multilib]Include = /etc/pacman.d/mirrorlist[archlinuxcn]Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch# 按顺序执行以下命令吧sudo systemctl start iwdsudo systemctl start dhcpcdsudo systemctl enable NetworkManagersudo systemctl enable dhcpcdsudo systemctl enable iwd# 编辑文件sudo vim /etc/NetworkManager/NetworkManager.conf# 加入以下内容，保存退出[device]wifi.backend=iwd# 输入 ip a 查看现在连上网没有其实，如果按照我刚开始的联网方式，这里配置完也是连着网的。 13. 安装驱动(请确保是网络连接正常)这一步大家可以根据自己的电脑 硬件型号 去选择，k可以百度也可以上 ArchWiki 查询；下面的桌面系统部分也可以选择自己喜欢的。 12345678910111213141516171819202122# haveged 是做 GPG 签名的sudo pacman -Syu havegedsudo systemctl start havegedsudo systemctl enable havegedsudo rm -rf /etc/pacman.d/gnupgsudo pacman-key --initsudo pacman-key --populate archlinuxsudo pacman -S archlinuxcn-keyring# 我的CPU、显卡是intel 5 代核显，执行以下命令。# 如果是其他的CPU 显卡请 自行 去官网查看或者百度，这个我也不懂，哈哈哈# 显卡驱动sudo pacman -S vulkan-intel lilb32-vulkan-intel mesa lib32-mesa# 声卡驱动sudo pacman -S alsa alsa-utils pulseaudio pulseaudio-alsa 14. 安装桌面(这里安装的Gnome)12345678910111213sudo pacman -S cinnamon gnome gnome-extra#之后一路回车，出现选项选择 y#等待安装完成。sudo pacman -S sddmsudo systemctl enable sddmsudo pacman -S way-microhei way-zenhei ttf-dejavusudo pacman -S google-chrome#现在就可以重启了，让我们怀着高兴紧张又期待的心情输入 reboot 回车吧！ 15. 尾声感谢教我的大佬，还记得大佬对我说，到这里基本的桌面和谷歌浏览器都帮我弄好了，剩下的就要靠我自己了。不知道为什么，当时听到这句话有一点么想哭。然后我听大佬的用的 cinnamon,大佬还给我发了截图。我看过去的第一眼，哇塞！好漂亮！！！然后大佬对我说，你需要自己去设置，默认的很丑，哈哈哈哈。犹记大佬最后对我说 你要学会靠自己，要会自己解决问题，我会尽力的。确实，自己手动安装一遍的收获真的是很大啊，我很佩服教我的大佬，并不仅仅是因为他教我安装 arch。感谢大佬，比心 ^o^ 可能遇到的问题 如果你插入了一个 ntfs 格式的硬盘，Linux 识别不了，不能挂载的话，请安装 ntfs-3g ；命令：yay -S ntfs-3g 未完待续。。。","tags":["linux","arch"],"categories":["Linux","Arch"]},{"title":"Linux Shell","path":"/p/dccc50f5/","content":"Linux 的 Shell 比较好用，有很多的命令，使用 Shell 脚本可以帮助我们节约时间。下面一起来简单了解一下吧。附带一个 Linux 的学习网站：https://www.linuxshelltips.com/，本文比较垃圾，看这个比较好。 一、Shell脚本shell 文件格式： 12345678# 运行shell脚本的程序，通常使用Bourne Again Shell（/bin/bash） Bourne Shell（/bin/sh）#!/bin/bash OR #!/bin/sh# 代表这个 shell 程序需要键盘接收，要不要都行，一个标识#filename:score# 变量名称 SCORE，从命令行接收变量值赋值给该变量read SCORE... 1. 必备知识条件比较大小时，需要使用以下的格式： 等于 大于等于 小于等于 不等于 大于 小于 -eq -ge -le -ne -gt -lt 参数 说明 $? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 $# 传递到脚本的参数个数。 $* 以一个单字符串显示所有向脚本传递的参数。如”$*”用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。 $$ 脚本运行的当前进程ID号。 $- 显示Shell使用的当前选项，与set命令功能相同。 2. 循环 for 循环语句 运算时使用 let 1234567891011for 条件do 语句块done其中：for ad in 1 2 3 4for ab in `seq 1 4`for ((ab = 1; ab &lt; 4; ab++))这三种写法的意思都是相同的，需要特别注意的是，第二行那个符号不是单引号，而是 Tab 上面，Esc 下面的那个键。因为使用的时候不容易看懂，不推荐使用。推荐第三种写法，注意有两个括号。 while 循环语句 1234while 条件do 语句块done until 循环语句 和while循环同样，不同的是判断循环的条件，while条件为真时循环，until 条件为假时循环。 1234until 条件do 语句块done 3. 判断shell 脚本的判断语句使用中括号，两端需要加入空格。比如下面这段代码(文件名为：test.sh)： test.sh1234567#!/bin/bashif [ 1 -ge 2 ];then echo &quot;yes&quot;else echo &quot;no&quot;fi 如果 1 之前和 2 之后没有空格，将会报错，并且永远执行 else 分支： 1./test.sh: line 3: [1: command not found 二、脚本示例12345678910111213141516171819202122232425262728#!/bin/bash# 使用超级管理员的命令需要输入密码，这里先输入一下 yourpassword 替换为超级管理员的密码sudo -S -v &lt;&lt; EOFyourpasswordEOFecho -n &quot;请输入创建的文件夹：&quot;read nameif [ ! -d &quot;$name&quot; ];then echo &quot;$name 文件夹不存在,正在创建&quot; sudo mkdir /$nameelse echo &quot;/$name 文件夹已存在&quot;sudo mkdir /$name/testif [ $? eq 0 ];then echo &quot;文件夹创建成功&quot;else echo &quot;创建失败&quot;sudo touch /$name/test/111.txt # 对文件写入内容echo &quot;自古星耀晦明时，不持太阿误剑诗&quot; | tee /$name/test/111.txt# -a 追加内容echo &quot;无边落木萧萧下，不尽长江滚滚滚来&quot; | tee -a /$name/test/111.txt Shell 脚本对 &gt; 或者 &gt;&gt; 符号有不同的处理，如果使用这种方式会报错；这里使用了 tee 命令来进行文本输入。","tags":["linux","shell"],"categories":["Linux","Shell"]},{"title":"CentOS 服务器配置","path":"/p/fa20a4d7/","content":"此篇文章以后随缘更新，这个系统的相关问题网上一般都有答案，浪子个人已不再使用 CentOS 系统。 一、CentOS7最小安装 1、配置网卡 2、关闭防火墙以及 Linux 的一些安全策略 3、配置本地 yum 源 4、安装常用工具 5、安装依赖关系 6、修改yum源 7. rpm命令 8. lrzsz：文件上传下载 二、部署服务 1. Redis 2. RabbitMQ 3. Python 4. Nginx 5. Btop++ 6. FFmpeg 7. MySQL（解压版） 问题一：密码正确但是进不去 bash 环境 问题二：预读处理 问题三：Can‘t connect to local MySQL server through socket ‘&#x2F;tmp&#x2F;mysql.sock‘ (2) 三、附 1. 关于源码编译安装失败 2. 防火墙 CentOS 7 firewall 基础使用 CentOS 6 iptables 基础使用 一、CentOS7最小安装1、配置网卡先进行网络的连接，编辑网络配置文件（vi /etc/sysconfig/network-scripts/ifcfg-ens32），不同的机器最后的文件名称可能不同，一般都是 ifcfg- 开头。 1234567# 空着的部分自定义即可BOOTPROTO=staticONBOOT=yesIPADDR=NETMASK=GATEWAY=DNS1= 设置完成后，保存退出，使用命令 systemctl restart network 重启网卡。 2、关闭防火墙以及 Linux 的一些安全策略123456systemctl stop firewalldsystemctl disable firewalldsed -i &#x27;s/SELINUX=enforcing/SELINUX=disabled/g&#x27; /etc/selinux/configsetenforce 0 3、配置本地 yum 源12345678# 进入目录cd /etc/yum.repos.d/# 创建 备份 文件夹mkdir bak# 移动该目录下的所有文件到备份文件夹mv * bak# 拷贝一份文件进行编辑cp bak/CentOS-Media.repo /etc/yum.repos.d/CentOS-Media.repo 编辑刚才我们拷贝的文件：vi CentOS-Media.repo，这就是安装软件时读取的安装源配置，加入以下内容，先使用本地镜像安装。 12345[linux]name=linuxbaseurl=file:///media/gpgcheck=0enabled=1 清除yum缓存：yum -y clean all重建yum缓存：yum makecache 4、安装常用工具yum -y install curl telnet vim wget lrzsz net-tools 修改vim配置（可以不修改，按照默认的即可，这里仅仅是偏好） 12345678910vim ~/.vimrcset encoding=utf-8 &quot; 文件编码set number &quot; 显示行号set tabstop=4 &quot; tab宽度为4set softtabstop=4 &quot; 设置一次可以删除4个空格set expandtab &quot; tab转换为空格set nowrap &quot; 不自动换行set showmatch &quot; 显示括号配对情syntax on &quot; 开启语法高亮 5、安装依赖关系yum -y install gcc gcc-c++ make autoconf wget lrzsz libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel glibc glibc-devel glib2 glib2-devel bzip2 bzip2-devel ncurses ncurses-devel curl curl-devel e2fsprogs e2fsprogs-devel krb5-devel libidn libidn-devel openssl openssl-devel libxslt-devel libevent-devel libtool libtool-ltdl bison gd gd-devel vim-enhanced pcre-devel zip unzip ntpdate sysstat patch bc expect rsync 6、修改yum源12345678910# 复制文件cp /etc/yum.repos.d/bak/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo# 进入目录cd /etc/yum.repos.d/# 添加 网易 的下载源wget http://mirrors.163.com/.help/CentOS6-Base-163.repo# 重建缓存yum makecache# 更新源yum -y update 如果不想使用 wget http://mirrors.163.com/.help/CentOS6-Base-163.repo 的话，可以自己编辑：/etc/yum.repos.d/CentOS-Base.repo 这个文件(以下是用的清华源)。编辑完成之后更新库，这时需要网络。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# CentOS-Base.repo## The mirror system uses the connecting IP address of the client and the# update status of each mirror to pick mirrors that are updated to and# geographically close to the client. You should use this for CentOS updates# unless you are manually picking other mirrors.## If the mirrorlist= does not work for you, as a fall back you can try the # remarked out baseurl= line instead.##[base]name=CentOS-$releasever - Base#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os&amp;infra=$infrabaseurl=http://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/os/$basearch/gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7#released updates [updates]name=CentOS-$releasever - Updates#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=updates&amp;infra=$infra#baseurl=http://mirror.centos.org/centos/$releasever/updates/$basearch/baseurl=http://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/updates/$basearch/gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7#additional packages that may be useful[extras]name=CentOS-$releasever - Extras#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=extras&amp;infra=$infra#baseurl=http://mirror.centos.org/centos/$releasever/extras/$basearch/baseurl=http://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/extras/$basearch/gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7#additional packages that extend functionality of existing packages[centosplus]name=CentOS-$releasever - Plus#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=centosplus&amp;infra=$infra#baseurl=http://mirror.centos.org/centos/$releasever/centosplus/$basearch/baseurl=http://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/centosplus/$basearch/gpgcheck=1enabled=0gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7 7. rpm命令12345678# 安装rpm -ivh xxx.rpm# 卸载rpm -evh xxx.rpm# 更新rpm -Uvh xxx.rpm# 显示所有已安装软件rpm -qa 8. lrzsz：文件上传下载123456# 安装yum install -y lrzsz# 下载sz# 上传rz 二、部署服务1. Redis官网源码下载https://redis.io/download/ 123456# 安装编译 redis 需要的工具sudo yum -y install gcc automake autoconf libtool make# 进入解压目录，进行编译，直到编译完成make MALLOC=libc# 安装到指定路径make install PREFIX=/usr/local/redis Redis 的默认的配置文件在源码解压后的目录中 2. RabbitMQRabbitMQ 是使用 Erlang 语言编写的中间件，联想一下 Java，我们可以猜到它需要先搭建 Erlang 环境。主要是这个环境需要编译源码，RabbitMQ 本身官网提供了二进制压缩包。 Erlang源码下载https://www.erlang.org/downloads 一、Erlang环境搭建 12345678910111213141516171819# 安装编译 Erlang 的相关依赖yum install gcc glibc-devel make ncurses-devel openssl-devel xmlto# 解压源码包tar -zxvf otp_src_24.1.7.tar.gzcd otp_src_24.1.7/# 指定安装目录./configure --prefix=/usr/local/erlang# 编译安装make &amp;&amp; make install# 测试安装是否成功：cd /usr/local/erlang/bin/./erl# 安装成功后配置环境变量 vim /etc/profileexport PATH=$PATH:/usr/local/erlang/bin# 添加完成保存退出，刷新使其生效source /etc/profile 二、安装Rabbitmq 通过第一步，我们就搭建好了 Erlang 环境，接下来就是安装 RabbitMQ 了，这个还是比较简单的，因为它已经编译好了，我们可以下载直接配置，无需编译。 二进制文件包下载https://www.rabbitmq.com/install-generic-unix.html 123456789# 解压tar -Jxvf rabbitmq-server-generic-unix-3.9.11.tar.xz# 移动mv rabbitmq_server-3.9.11 /usr/local/rabbitmq# 添加环境变量：vim /etc/profileexport PATH=$PATH:/usr/local/rabbitmq/sbin# 刷新变量source /etc/profile 3. PythonLinux 下基本不需要配置 Python 的环境，有个别的 ISO 镜像版本比较老，比如 CentOS7 的 mini ISO 镜像是2.x的，我们可以通过各大系统的包管理工具进行安装，也可以自己通过源码编译安装。 源码下载https://www.python.org/downloads/ 12345678910111213141516171819202122# 安装相关工具和依赖yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make libffi-devel# 解压压缩包tar -zxvf Python-3.10.2.tgz # 进入文件夹cd Python-3.10.2# 配置安装位置./configure prefix=/usr/local/python3# 编译并安装make &amp;&amp; make install# 使用 python3 验证是否安装成功python3 -V#添加python3的软链接 ln -s /usr/local/python3/bin/python3.8 /usr/bin/python3 #添加 pip3 的软链接 ln -s /usr/local/python3/bin/pip3.8 /usr/bin/pip3 4. Nginx官网源码下载https://nginx.org/en/ 12345678910111213# 解压tar -zvxf nginx-1.20.2.tar.gz# 配置安装路径./configure --prefix=/usr/local/nginx# 编译安装make &amp;&amp; make install# 进入安装目录查看是否安装成功cd /usr/local/nginx# 启动 停止 重启./nginx start./nginx -s stop./nginx -s reload 5. Btop++Btop++ 是一个 Linux 资源监视器，显示处理器、内存、磁盘、网络和进程的使用情况和统计资料，界面美观，使用简单。这里使用了源码编译安装，但是浪子推荐下载 Github 仓库的二进制包解压运行 install.sh 脚本安装。 Github地址https://github.com/aristocratos/btop Gitee同步仓库https://gitee.com/mirrors/btop 1234567891011# 安装、升级相关依赖工具yum install coreutils sed build-essential -yyum install centos-release-scl -yyum install devtoolset-10 -yscl enable devtoolset-10 bash echo &quot;source /opt/rh/devtoolset-10/enable&quot; &gt;&gt; /etc/profile# 克隆源码编译安装git clone https://gitee.com/mirrors/btop.gitcd btopmake &amp;&amp; make install 6. FFmpegFFmpeg使用http://www.ffmpeg.org/ 12345678910111213# 克隆源码 也可以下载 https://github.com/FFmpeg/FFmpeg/releases 相应的包上传git clone https://git.ffmpeg.org/ffmpeg.git ffmpeg# 安装相关依赖yum install yasm.x86_64 -ycd ffmpeg./configure --enable-ffplay --enable-ffserver --prefix=/usr/local/ffmpeg# 编译安装make &amp;&amp; make install# 查看是否安装成功cd /usr/local/ffmpeg 7. MySQL（解压版）yum 方式安装：https://zhuanlan.zhihu.com/p/87069388 使用通用的 MySQL8.x 版本的二进制压缩包进行安装。至于卸载，就把有关 MySQL 创建的几个文件夹删掉就行了，/etc/my.cnf 是默认自带的，卸载的时候删不删都没有问题，如果默认没有这个文件也不必担心，可以手动添加。 1234567891011121314151617181920212223242526272829303132333435363738394041# 检查mysql用户组和用户是否存在，如果没有，则创建cat /etc/group | grep mysqlcat /etc/passwd | grep mysql# 创建 mysql 组groupadd mysql# 新建 mysql 用户并加入 mysql 群组useradd -r -g mysql mysql# 安装所需依赖(需要安装 libaio-devel.x86_64 numactl 这两个依赖)yum -y install libaio-devel.x86_64 numactl# 解压二进制文件包到 /usr/local/mysql 目录tar xxx -C /usr/local/mysqlcd /usr/local/mysql/bin# 初始化数据，成功初始化后需要记录最后 root@localhost: 后的字符串（初始化失败则不显示），它是后面进入 bash 环境的初始密码./mysqld --initialize --user=mysql --datadir=/usr/local/mysql/data --basedir=/usr/local/mysql# vim /etc/my.cnf(没有该文件手动创建) 修改内容basedir=/usr/local/mysqldatadir=/usr/local/mysql/dataport = 3306# 启动MySQL服务 启动成功会有 Starting MySQL.. SUCCESS! 提示；否则就是启动失败，根据提示查看日志记录定位问题cd /usr/local/mysql/support-files/mysql.server start# 添加软链接并重启服务ln -s /usr/local/mysql/support-files/mysql.server /etc/init.d/mysql ln -s /usr/local/mysql/bin/mysql /usr/bin/mysqlservice mysql restart# systemctl restart mysql# 添加开机自启# 1、将服务文件拷贝到 init.d 下，并重命名为 mysqlcp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld# 2、赋予可执行权限chmod +x /etc/init.d/mysqld# 3、添加服务chkconfig --add mysqld# 4、显示服务列表chkconfig --list 至此，安装任务基本完成，下面需要添加用户并分配权限，进入 MySQL 的 bash 环境需要之前进行初始化时生成的密码。 123456789101112131415161718192021# 登录 MySQL，密码使用初始化成功时 root@localhost: 后的字符串mysql -u root -p# 修改密码 毕竟那么不好记# 而且如果不修改 它会报 ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement. 的错误alter user root@&#x27;localhost&#x27; identified by &#x27;newpassword&#x27;;flush privileges;# 开放远程连接use mysql;# 允许所有主机，都可以通过用户为root用户，密码为默认数据库登录密码，进行数据库操作update user set host=&#x27;%&#x27; where user=&#x27;root&#x27;;# ① 适用于 MySQL 8.0之前的版本，可以直接授权 password 为自己设置的密码# grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;password&#x27; with grant option;# ② 适用于 MySQL 8.0之后的版本，需要先创建一个用户，再进行授权【推荐方式②】create user dev@&#x27;%&#x27; identified by &#x27;123456&#x27;;grant select,update,delete,insert on *.* to dev@&#x27;%&#x27; with grant option;# 刷新权限，这一句很重要，使修改生效，如果没有写，则还是不能进行远程连接。这句表示从mysql数据库的grant表中重新加载权限数据，因为MySQL把权限都放在了cache中，所以，做完修改后需要重新加载。flush privileges; 初始化成功截图： 初始化成功截图 记录日志最末尾位置 root@localhost: 后的字符串，此字符串为mysql管理员临时登录密码。 问题一：密码正确但是进不去 bash 环境1ERROR 1045 (28000): Access denied for user &#x27;root&#x27;@&#x27;localhost&#x27; (using password: YES/NO) 解决方法： 使用 kill 命令停止 mysqld 相关服务 cd &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;，运行命令： mysqld_safe --user=mysql --skip-grant-tables --skip-networking &amp; 使用密码登录数据库 mysql -u root -p 并切换到 mysql 数据库 执行命令：update user set host=&#39;%&#39; where user=&#39;root&#39;; 问题二：预读处理123mysql&gt; use dbname;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -A 这个问题是之前使用的 apt-get 管理工具安装的 MySQL 出现的，原因是因爲數據庫採用了預讀處理。解决办法就是在我们进入MySQL的bash环境时，需要加入 -A 参数，不让其预读数据库信息，mysql -u root -p -A。如果覺得每次进入 bash 环境都要添加参数比较麻烦，也可以在 my.cnf 文件里加上如下內容： 12[mysql]no-auto-rehash 问题三：Can‘t connect to local MySQL server through socket ‘&#x2F;tmp&#x2F;mysql.sock‘ (2)这是 my.cnf 的配置问题，下面的三块内容必须都要设置，不然就会使用默认的 socket，位于 /tmp/mysql.sock 目录，因此我们最好配置一下： /etc/my.cnf12345678910111213[mysqld]basedir=/usr/local/mysqldatadir=/usr/local/mysql/datasocket=/usr/local/mysql/mysql.sockport=3306 [client]default-character-set=utf8socket=/usr/local/mysql/mysql.sock [mysql]default-character-set=utf8socket=/usr/local/mysql/mysql.sock 或者我们打一个软链接： 1ln -s /usr/local/mysql/mysql.sock /tmp/mysql.sock 三、附1. 关于源码编译安装失败如果源码编译失败，先确认所需依赖是否全部成功安装，然后清除上一次编译的缓存，之后再次编译，不然会一直失败。参考网址 1234# 清除上一次编译失败的缓存make distclean# 再次编译make 2. 防火墙CentOS 版本不同采用的防火墙管理也不同（当然，我们部署后可以安装）。CentOS 6 使用的 iptables，CentOS 7 使用的 firewall。 CentOS 7 firewall 基础使用12345678910# 查询开放端口firewall-cmd --list-port# 开放端口firewall-cmd --zone=public --add-port=8080/tcp --permanent# 禁用端口firewall-cmd --zone=public --remove-port=8083/tcp --permanent# 重新加载firewall-cmd --reload# 再次查询开放端口firewall-cmd --list-port CentOS 6 iptables 基础使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# 启动service iptables start# 关闭service iptables stop# 查看状态service iptables status# 开机禁用chkconfig iptables off# 开机启用chkconfig iptables on# 允许本地回环接口（即运行本机访问本机） -A和-I参数分别为添加到规则末尾和规则最前面。iptables -A INPUT -i lo -j ACCEPT# 允许已建立的或相关联的通行iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT# 允许所有本机向外的访问iptables -P INPUT ACCEPTiptables -A OUTPUT -j ACCEPT# 允许访问22端口 -s后可以跟 IP 段或指定 IP 地址，如果有其他端口的话，规则也类似。iptables -A INPUT -p tcp --dport 22 -j ACCEPTiptables -A INPUT -p tcp -s 10.159.1.0/24 --dport 22 -j ACCEPT # 允许pingiptables -A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT# 禁止其他未允许的规则访问iptables -A INPUT -j REJECT iptables -A FORWARD -j REJECT# 屏蔽单个IPiptables -I INPUT -s 123.45.6.7 -j DROP# 封整个段即从123.0.0.1到123.255.255.254iptables -I INPUT -s 123.0.0.0/8 -j DROP# 封IP段即从123.45.0.1到123.45.255.254iptables -I INPUT -s 124.45.0.0/16 -j DROP# 封IP段即从123.45.6.1到123.45.6.254iptables -I INPUT -s 123.45.6.0/24 -j DROP# 查看已有规则 -n：只显示IP地址和端口号，不将 IP 解析为域名iptables -L -n# 将所有 iptables 以序号标记显示iptables -L -n --line-numbers# 添加规则# 添加的规则是添加在最后面。如针对 INPUT 链增加一条规则，接收从 eth0 口进入且源地址为192.168.0.0/16网段发往本机的数据iptables -A INPUT -i eth0 -s 192.168.0.0/16 -j ACCEPT# 删除规则iptables -D# 删除所有规则iptables -F# 备份规则iptables-save &gt; /etc/sysconfig/iptables.save# 使用规则iptables-restore &lt; /etc/sysconfig/iptables.save# 重启生效service iptables saveservice iptables restart 开放端口 方法一：通过命令行 123iptables -A INPUT -p tcp --dport 80 -j ACCEPTservice iptables saveservice iptables restart 方法二：编辑配置文件 编辑配置文件：vi /etc/sysconfig/iptables，添加： 12iptables -A INPUT -p tcp --dport 80 -j ACCEPTservice iptables restart","tags":["centos"],"categories":["Linux","CentOS"]},{"path":"/friends/index.html","content":"诗酒趁年华Azhe"},{"title":"关于","path":"/about/index.html","content":"prettywinter 只要不失你的崇高，全世界都会向你敞开。 爱好影视游戏玩比较喜欢武侠世界，看过颇多武侠剧。作品名称推荐星级布袋戏★★★★☆比较喜欢单机，喜欢游戏的剧情发展，画质不是过于关注。作品名称推荐星级仙剑奇侠传★★★★☆古剑奇谭★★★★☆ 镜像站 北京外国语大学开源软件镜像站北京外国语大学开源软件镜像站阿里云官方镜像站https://developer.aliyun.com/mirror/Git淘宝镜像仓库https://npm.taobao.org/mirrors/git-for-windows/ 开源字体 文泉驿系列文泉驿微米黑、正黑、等宽体等思源黑体系列思源黑体是一套 OpenType/CFF 泛中日韩字体FiraCodeFree monospaced font with programming ligaturesJetBrains MonoJetBrains Mono the free and open-source typeface for developers Github 开源项目 文件蜈蚣一款多协议支持的下载器Motrix一款多协议支持的下载器DownkyiBilibili下载器MQTTX一款开源的 MQTT 测试客户端 一些工具 shields.io生成 md 个性标签，例如 Github 的 README 文件的小标签语音转 Base64https://protobuf-decoder.netlify.app/个性文字http://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type%20Something%20图片转文字https://www.degraeve.com/img2txt.phpcolor.oulu.me渐变颜色选择器png转iconpng转icon调整图片大小在线调整图片大小"},{"title":"ElasticSearch + Kibana","path":"/wiki/Database/ElasticSearch.html","content":"ES 简单如个门，浪子最近使用 PG 作为数据库，一般的业务用不上 ES。先了解一下简单的操作。 ElasticSearch分布式搜索引擎的认识 安装配置 1. ES 插曲：ES启动可能出现的问题 2. Kibana ES基本使用 1. 核心概念 2. 索引操作 3. 映射操作 4. 文档操作 高级查询 1. 关键字查询&lt;term&gt; 2. 范围查询&lt;range&gt; 3. 前缀查询&lt;prefix&gt; 4. 通配符查询&lt;wildcard&gt; 5. 多id查询&lt;ids&gt; 6. 模糊查询&lt;fuzzy&gt; 7. 布尔查询&lt;bool&gt; 8. 多字段查询&lt;multi_match&gt; 9. 默认字段分词查询&lt;query_string&gt; 10. 高亮查询&lt;highlight&gt; 11. 返回指定条数&lt;size&gt; 12. 分页查询&lt;form&gt; 13. 排序&lt;sort&gt; 14. 返回指定字段&lt;_source&gt; 分词器 1. ES 内置分词器 2. 中文分词器 3. 扩展词、停用词配置 4. 过滤查询 SpringBoot整合ES开发 1. ElasticsearchOperations 相关注解 2. RestHighLevelClient ES 集群搭建 Head插件查看ES状态 ElasticSearch分布式搜索引擎的认识ES中的默认使用的是标准分词器(StandardAnalyzer)：中文使用单字分词；英文使用单词分词。ES中只有 text 类型是分词的，剩下的 keyword、integer、date 等类型都是不分词的。版本异同： es5 一个索引可以创建多个类型，在es6中仍可以使用,但是已经不推荐。es6 之后一个索引只对应一个类型。es7 的默认分片(即备份)从之前的5调到了1,如果想用原来的可以自己设置；es7 使用jdk11+，已经内置。不过可能会出现使用本地的jdk的情况，如果本地jdk版本低于11，需要配置。编辑环境变量：vim /etc/profile，添加变量 export ES_JAVA_HOME=指定ES安装目录中的jdk，然后 source /etc/profile类型已经在新版本中删除，7之后的版本不在有类型。 安装配置注意，kibana 必须和 ES 同版本。这里以安装的 7.14 版本为例，安装方式都是解压 .tar.gz 包的方式，docker 方式安装比较简单。 ES 默认 web 端口：9200；tcp端口：9300(集群通信)；kibana默认端口：5601 启动 Kibana 之前确保 ES 服务正常启动。 1. ESES 不能以 root 用户启动，否则会报运行时异常，请使用普通用户启动 ES 服务；首先关闭防火墙。之后修改安装目录下的 config 文件夹内的 elasticsearch.yml 文件,修改以下内容： 1234# 开启远程连接network.host: 0.0.0.0# 使用一个节点初始化集群cluster.initial_master_nodes: [&quot;node-1&quot;] 设置完成以后可以启动服务；进入安装的 bin 目录，两个命令二选一，如果是直接启动的，操作时可以再打开一个会话窗口。 1234# 直接启动./elasticsearch# 后台启动 以守护进程启动./elasticsearch -d 插曲：ES启动可能出现的问题另外，一般在启动会出现默认配置较小的错误，我们需要更改系统文件。启动失败时 es 服务会在终端给出建议的大小，我们去修改即可： 以 root 用户修改文件 /etc/security/limits.conf ，在最后加入以下内容（CentOS系统需要。其它的系统可跳过） 1234* soft\tnofile 65536* hard\tnofile 65536* soft\tnproc 4096* hard\tnproc 4096 编辑文件 sudo vim /etc/sysctl.conf，如果没有该文件可以手动创建，加入内容：vm.max_map_count=262144。然后使用 sysctl -p 使其生效并查看输出内容是否和自己设置的一样。 2. Kibana同样是修改 kibana 安装目录下的 config/kibana.yml 文件，修改以下内容： 1234# 开启远程连接server.host: 0.0.0.0# 监控 ES 的地址信息elasticsearch.hosts: [es的ip地址:端口号] ES基本使用1. 核心概念 索引（Index）：一个索引就是一个拥有几分相似特征的文档的集合（类似MySQL的库的概念），ES索引的名称必须是小写。 映射（Mapping）：映射是定义一个文档和它所包含的字段如何被存储和索引的过程。可以简单认为映射就是常规数据库的字段信息。在默认配置下，ES可以根据插入的数据自动地创建mapping，也可以手动创建mapping。mapping中主要包括字段名、字段类型等。 文档（Document）：文档是索引中存储的一条条数据。一条文档是一个可被索引的最小单元。ES的文档采用了轻量级的JSON格式数据来表示。 2. 索引操作123456// 查看es中的索引GET /_cat/indices?v// 创建索引PUT /index_name// 删除索引DELETE /index_name 谨慎使用 delete /* 的操作，删除掉会导致服务无法正常访问，需要重启服务。查看索引有 health 标题，包含三种属性：黄色代表可用，但是有危险；绿色代表健康，可用；红色代表索引不可用。索引没有修改操作。 3. 映射操作一般都是在创建索引的时候创建映射，脱离了索引，映射也就没有意义了。创建映射时不需要指定类型的长度。 12345678910111213141516171819202122232425262728293031323334// 创建映射，一般在创建索引时手动创建映射PUT /index_name &#123; // 指定分片信息，可以不写，使用默认 &quot;settings&quot;:&#123; // 分片为1 &quot;number_of_shards&quot;: 1, // 副本为0 &quot;number_of_replicas&quot;: 0 &#125;, &quot;mappings&quot;:&#123; // 默认字段，映射属性信息必须写在这里面 &quot;properties&quot;:&#123; // 属性名称及其类型 &quot;id&quot;: &#123; &quot;type&quot;: &quot;integer&quot; &#125;, &quot;title&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;price&quot;: &#123; &quot;type&quot;: &quot;double&quot; &#125;, &quot;created_at&quot;: &#123; &quot;type&quot;: &quot;date&quot; &#125;, &quot;desc&quot;: &#123; &quot;type&quot;: &quot;text&quot; &#125;, &#125; &#125;,&#125;// 查看映射信息GET /index_name/_mapping 映射信息不能删除和修改。 4. 文档操作文档操作，插入一条文档 put &#x2F;索引&#x2F;类型&#x2F;id（指定Id用put，让系统自动创建用post） 1234567891011121314151617181920212223242526272829303132333435// 添加文档 手动指定 idPOST /index_name/_doc/1&#123; &quot;id&quot;: 1, &quot;title&quot;: &quot;风中捉刀&quot;, &quot;price&quot;: 0.5, &quot;created_at&quot;: &quot;2021-12-12&quot;, &quot;description&quot;: &quot;天元轮魁&quot;&#125;// 添加文档 自动创建文档 id：取UUID的一部分POST /index_name/_doc/&#123; &quot;title&quot;: &quot;无情葬月&quot;, &quot;price&quot;: 0.5, &quot;created_at&quot;: &quot;2021-10-12&quot;, &quot;description&quot;: &quot;血不染&quot;&#125;// 文档查询 基于 id 查询GET /index_name/_doc/document_id// 删除文档 基于 id 删除DELETE /index_name/_doc/document_id// 更新文档 先删除再添加，不保留其它数据PUT /index_name/_doc/document_id&#123; &quot;filed_name&quot;: &quot;修改值&quot;&#125;// 更新文档 保留原始内容PUT /index_name/_doc/document_id/_update&#123; // doc为默认字段，必填 &quot;doc&quot;: &#123; &quot;filed_name&quot;: &quot;target_value&quot; &#125;&#125; es7 在添加文档时必须在索引名称后面加上 _doc， 批量操作:_bulk(批量操作)添加、修改、删除（弱化事务甚至没有事务） 12345678910111213141516171819202122232425262728POST /index_name/_doc/_bulk&#123; // 手动添加id &quot;index&quot;: &#123;&quot;_id&quot;: 2&#125;&#125;&#123; &quot;id&quot;: 2, &quot;title&quot;: &quot;风中捉刀&quot;, &quot;price&quot;: 0.5, &quot;created_at&quot;: &quot;2021-12-12&quot;, &quot;description&quot;: &quot;天元轮魁&quot;&#125;&#123;&quot;index&quot;: &#123;&quot;_id&quot;: 3&#125;&#125;&#123; &quot;id&quot;: 3, &quot;title&quot;: &quot;玲珑雪霏&quot;, &quot;price&quot;: 0.5, &quot;created_at&quot;: &quot;2021-12-12&quot;, &quot;description&quot;: &quot;天元轮魁&quot;&#125;// 文档批量操作 添加 更新 删除POST /index_name/_doc/_bulk&#123;&quot;index&quot;: &#123;&quot;_id&quot;: 4&#125;&#125; &#123;&quot;id&quot;: 4,&quot;title&quot;: &quot;风中捉刀&quot;,&quot;price&quot;: 0.5,&quot;created_at&quot;:&quot;2021-12-12&quot;,&quot;description&quot;: &quot;天元轮魁&quot;&#125;&#123;&quot;update&quot;: &#123;&quot;_id&quot;: 3&#125;&#125; &#123;&quot;doc&quot;: &#123;&quot;title&quot;: &quot;荻花题叶&quot;&#125;&#125;&#123;&quot;delete&quot;: &#123;&quot;_id&quot;: 2&#125;&#125; 如果添加报错，那么信息需要放到同一行。 高级查询ES官方提供两种检索方式，queryString(查询参数),queryDSl(特定领域查询);官方更推荐使用第二种，简洁强大。Query DSL是利于Restful API传递JSON格式的请求体数据与ES进行交互。 1. 关键字查询&lt;term&gt;1234567891011121314151617181920212223242526272829303132333435// 查询所有 match_all,_doc可以不写，这样在Kibana中会有语法提示GET /index_name/_doc/_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;&#125;// 关键词查询 term// keyword 类型需要输入全部内容搜索// text 类型需要输入单个词/字搜索GET /index_name/_search&#123; &quot;query&quot;:&#123; &quot;term&quot;:&#123; // 搜索 description 关键词 &quot;description&quot;:&#123; // 关键词包含的值 &quot;value&quot;:&quot;天元&quot; &#125; &#125; &#125;&#125;// 查询 keyword 类型，全部输入GET /index_name/_search&#123; &quot;query&quot;:&#123; &quot;term&quot;:&#123; &quot;title&quot;:&#123; &quot;value&quot;:&quot;风中捉刀&quot; &#125; &#125; &#125;&#125; 由于ES默认使用的是标准分词器：英文单词分词，中文单字分词。所以description 只能输入单字搜索。keyword 类型不分词，所以必须输入全部内容才能精准查询。ES 中，除了 text 类型之外的其它类型都不分词。对于中文分词器，我们一般会使用其它的分词器。 2. 范围查询&lt;range&gt;123456789101112GET /index_name/_search&#123; &quot;query&quot;:&#123; &quot;range&quot;:&#123; // 根据price查询范围在 0=&lt;price&lt;=5 的数据 &quot;price&quot;: &#123; &quot;gte&quot;:0, &quot;lte&quot;:5 &#125; &#125; &#125;&#125; 3. 前缀查询&lt;prefix&gt;12345678910GET /index_name/_search&#123; &quot;query&quot;:&#123; &quot;prefix&quot;:&#123; &quot;title&quot;: &#123; &quot;value&quot;:&quot;&quot; &#125; &#125; &#125;&#125; 4. 通配符查询&lt;wildcard&gt;?：匹配一个*：匹配多个 12345678910GET /index_name/_search&#123; &quot;query&quot;:&#123; &quot;wildcard&quot;:&#123; &quot;description&quot;: &#123; &quot;value&quot;:&quot;go*&quot; &#125; &#125; &#125;&#125; 5. 多id查询&lt;ids&gt;123456789GET /index_name/_search&#123; &quot;query&quot;:&#123; &quot;ids&quot;:&#123; // 多个文档id &quot;values&quot;: [1, 2, 4] &#125; &#125;&#125; 6. 模糊查询&lt;fuzzy&gt;最多允许 0-2 次模糊(至多模糊匹配 0 ~ 2 个字符) 1234567891011GET /index_name/_search&#123; &quot;query&quot;:&#123; &quot;fuzzy&quot;:&#123; // 也可以搜索到 风中捉刀 &quot;description&quot;: &quot;风中捉枪&quot; // 搜索不到 风中捉刀 // &quot;description&quot;: &quot;风中捉西瓜&quot; &#125; &#125;&#125; 搜索关键词小于等于2，不允许模糊。搜索关键词长度为3-5，只允许一次模糊。搜索关键词长度大于5，最多允许2次模糊。 7. 布尔查询&lt;bool&gt;12345678910111213141516171819GET /index_name/_search&#123; &quot;query&quot;:&#123; &quot;bool&quot;:&#123; // 以下条件必须都满足才能查询到数据 &quot;must&quot;:&#123; &quot;ids&quot;: &#123; &quot;values&quot;:[1] &#125;, &#123;&quot;term&quot;:&#123; &quot;title&quot;:&#123; &quot;value&quot;: &quot;风中捉刀&quot; &#125; &#125; &#125; &#125; &#125; &#125;&#125; must 必须满足才能查询，must_not 都不满足才能查询。 8. 多字段查询123456789GET /index_name/_search&#123; &quot;query&quot;:&#123; &quot;multi_match&quot;:&#123; &quot;query&quot;: &quot;风中捉刀&quot;, &quot;fields&quot;: [&quot;title&quot;, &quot;description&quot;] &#125; &#125;&#125; 字段类型分词，将查询条件分词之后进行查询，如果不分词，就讲查询条件作为整体进行查询。 9. 默认字段分词查询123456789GET /index_name/_search&#123; &quot;query&quot;:&#123; &quot;query_string&quot;:&#123; &quot;default_field&quot;: &quot;description&quot;, &quot;query&quot;: &quot;可叹，落叶飘零&quot; &#125; &#125;&#125; 10. 高亮查询&lt;highlight&gt;让符合条件的文档高亮显示。只有能分词的才支持高亮。注意，查询出来的文档的关键词，ES会对其加入&lt;em&gt;标签标记，具体高亮样式由我们自己定义。高亮并没有直接修改原始文档，而是放到了另一个标签。 12345678910111213141516GET /index_name/_search&#123; &quot;query&quot;:&#123; &quot;query_string&quot;:&#123; &quot;default_field&quot;: &quot;description&quot;, &quot;query&quot;: &quot;可叹，落叶飘零&quot; &#125; &#125;, &quot;highlight&quot;: &#123; &quot;fields&quot;: &#123;&quot;*&quot;:&#123;&#125;&#125;, // 自定义样式 &quot;pre_tags&quot;:[&quot;&lt;span style=&#x27;color:red;&#x27;&gt;&quot;], &quot;post_tags&quot;:[&quot;&lt;/span&gt;&quot;], &quot;require_field_match&quot;: &quot;false&quot; &#125;&#125; 11. 返回指定条数&lt;size&gt;ES查询数据，默认只显示前10条内容。 123456789101112131415161718GET /index_name/_search&#123; &quot;query&quot;:&#123; &quot;query_string&quot;:&#123; &quot;default_field&quot;: &quot;description&quot;, &quot;query&quot;: &quot;可叹，落叶飘零&quot; &#125; &#125;, &quot;highlight&quot;: &#123; &quot;fields&quot;: &#123;&quot;*&quot;:&#123;&#125;&#125;, // 自定义样式 &quot;pre_tags&quot;:[&quot;&lt;span style=&#x27;color:red;&#x27;&gt;&quot;], &quot;post_tags&quot;:[&quot;&lt;/span&gt;&quot;], &quot;require_field_match&quot;: &quot;false&quot; &#125;, // 指定返回条数 &quot;size&quot;:3&#125; 12. 分页查询&lt;form&gt;123456789101112131415161718GET /index_name/_search&#123; &quot;query&quot;:&#123; &quot;query_string&quot;:&#123; &quot;default_field&quot;: &quot;description&quot;, &quot;query&quot;: &quot;可叹，落叶飘零&quot; &#125; &#125;, &quot;highlight&quot;: &#123; &quot;fields&quot;: &#123;&quot;*&quot;:&#123;&#125;&#125;, // 自定义样式 &quot;pre_tags&quot;:[&quot;&lt;span style=&#x27;color:red;&#x27;&gt;&quot;], &quot;post_tags&quot;:[&quot;&lt;/span&gt;&quot;], &quot;require_field_match&quot;: &quot;false&quot; &#125;, &quot;from&quot;: 2, &quot;size&quot;: 3&#125; 13. 排序&lt;sort&gt;12345678910111213141516171819202122232425GET /index_name/_search&#123; &quot;query&quot;:&#123; &quot;query_string&quot;:&#123; &quot;default_field&quot;: &quot;description&quot;, &quot;query&quot;: &quot;可叹，落叶飘零&quot; &#125; &#125;, &quot;highlight&quot;: &#123; &quot;fields&quot;: &#123;&quot;*&quot;:&#123;&#125;&#125;, // 自定义样式 &quot;pre_tags&quot;:[&quot;&lt;span style=&#x27;color:red;&#x27;&gt;&quot;], &quot;post_tags&quot;:[&quot;&lt;/span&gt;&quot;], &quot;require_field_match&quot;: &quot;false&quot; &#125;, &quot;from&quot;:0, &quot;size&quot;:3, &quot;sort&quot;:[ &#123; &quot;price&quot;:&#123; &quot;order&quot;:&quot;desc&quot; &#125; &#125; ]&#125; 排序会干预ES的内部的规则。 14. 返回指定字段&lt;_source&gt;12345678910GET /index_name/_search&#123; &quot;query&quot;:&#123; &quot;query_string&quot;:&#123; &quot;default_field&quot;: &quot;description&quot;, &quot;query&quot;: &quot;可叹，落叶飘零&quot; &#125; &#125;, &quot;_source&quot;:[&quot;id&quot;, &quot;title&quot;, &quot;description&quot;]&#125; 分词器1. ES 内置分词器Standard Analyzer：默认分词器，英文按单词拆分，统一小写处理。Simple Analyzer：按照单词切分，过滤符号，中文按照空格分词，统一小写处理。Stop Analyzer：统一小写处理，停用词过滤。Whitespace Analyzer：按照空格切分，不转小写。Keyword Analyzer：不分词，直接将输入当作输出。 可以在创建索引的时候为映射字段指定分词器，默认的就是标准分词器（standard）： 123456789PUT /index_name&#123; &quot;mapping&quot;:&#123; &quot;properties&quot;:&#123; &quot;title&quot;:&quot;text&quot;, &quot;analyzer&quot;: &quot;standard|simple|stop|whitespace|keyword&quot; &#125; &#125;&#125; 2. 中文分词器ES支持的中文分词器有IK、smartCN等，推荐的是 IK分词器。 注意： IK分词器的版本要和你安装的ES版本一致。Docker插件所在的目录 /usr/share/elasticsearch/plugins IK分词器类型：ik_smart_word(组粒度拆分)、ik_max_word(细粒度拆分) 3. 扩展词、停用词配置定义扩展词典和停用词典可以修改IK分词器中 config 目录中 IKAnalyzer.cfg.xml 文件。 1234567&lt;properties&gt; &lt;comment&gt;扩展词配置&lt;/comment&gt; &lt;!-- 扩展词典 --&gt; &lt;entry key=&quot;ext_dict&quot;&gt;ext_dict.dic&lt;/entry&gt; &lt;!-- 停用词典 --&gt; &lt;entry key=&quot;ext_stopwords&quot;&gt;ext_stopwords.dic&lt;/entry&gt;&lt;/properties&gt; 在ik分词器目录下config目录中创建 ext_dict.dic、ext_stopwords.dic 文件，文件编码必须为 UTF-8，添加扩展词即可。 4. 过滤查询在ES中，可以使用过滤查询获得更快的查询速度。使用过滤查询，就需要前面使用的布尔查询。 12345678910111213141516171819202122GET /index_name/_search&#123; &quot;query&quot;:&#123; &quot;bool&quot;:&#123; &quot;must&quot;:[ &quot;term&quot;:&#123; &quot;description&quot;:&#123; &quot;value&quot;:&quot;xxx&quot; &#125; &#125; ], &quot;filter&quot;:[ &#123; // 支持 term terms range exists ids 过滤 &quot;term&quot;:&#123; &quot;description&quot;:&quot;&quot; &#125; &#125; ] &#125; &#125;&#125; 会先执行过滤查询，再执行目标查询。一般用于大数据量的查询。过滤查询是ES中一种重要的优化手段。 SpringBoot整合ES开发 导入es依赖 配置客户端 1234567891011@Configurationpublic class RestClientConfig extends AbstractElasticsearchConfiguration &#123; @Bean @Override public RestHighLevelClient elasticsearchClient() &#123; final ClientConfiguration client = ClientConfiguration.builder() .connectedTo(&quot;esIP地址:端口&quot;) .build(); return RestHighLevelClient.create(client).rest(); &#125;&#125; 进行客户端操作 客户端对象有两个，如果进行了上面的配置，那么都会在Spring工厂中创建： ElasticsearchOperations RestHighLevelClient（推荐使用） 1. ElasticsearchOperations特点：始终使用面向对象方式操作ES 索引：用来存放相似文档集合 映射：决定文档的每个字段以什么方式录入到ES中 字段类型 分词器 文档：可以被索引的最小单元 json 数据格式 相关注解 注解名称 说明 @Document(indexName &#x3D; “index_name”, createIndex &#x3D; true) 用于类，指定索引名,是否创建索引 @Id 将放入对象 id 值作为文档 _id 进行映射 @Field(type &#x3D; FieldType.Keyword) 指定字段类型 2. RestHighLevelClient使用 RestHighLevelClient 非常简单，会使用Kibana就可以，它支持使用原生的编写 ES 的语句，只要会。可能这也是大家喜欢使用的原因之一吧。 123456SearchRequest search = new SearchRequest(document);SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();sourceBuilder.query(条件);search.source(sourceBuilder);SearchResponse searchResponse = restHignLevelClient.search(search, RequestOptions.DEFAULT); ES 集群搭建准备三个节点 cluster-|node-1-|config&#x2F;elasticsearch.yml 123456789101112131415161718192021# 集群名称，3个节点必须相同cluster.name: es-cluster# 指定节点名称node.name: # 开放远程连接network.host: 0.0.0.0# 指定使用发布地址进行集群间通信network.publish_host: 192.168.124.3# 指定 web 端口http.port: 9201# 指定 tcp 端口transport.tcp.port: 9301# 指定所有节点的 TCP 通信discovery.seed_hosts: [&quot;192.168.10.1:9301&quot;, &quot;192.168.10.1:9302&quot;, &quot;192.168.10.1:9303&quot;]# 指定可以初始化集群的节点名称cluster.initial_master_nodes: [&quot;node-1&quot;, &quot;node-2&quot;, &quot;node-3&quot;]# 集群最少几个节点可用gateway.recover_after_nodes: 2# 解决跨域问题http.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot; 其它节点配置类似，只要修改对应的节点名称、IP以及对应的端口即可。 查看集群状态：http://任意集群节点ip:端口/_cat/health?v Head插件查看ES状态我们可以使用 Github 上的大佬开发的查看 ES 状态信息的插件监控服务，该插件基于 js 编写，需要 Node 环境。 12345678git clone https://github.com/mobz/elasticsearch-head.gitcd elasticsearch-head# 安装依赖npm install# 启动npm run startopen http://localhost:9100/"},{"title":"MySQL优化","path":"/wiki/Database/MySQL优化原则.html","content":"MySQL: 最流行的开源数据库。MySQL的优化原则，视项目具体情况而定。 一、核心阿里巴巴手册中说：SQL优化标准是到ref，最差是range，达到const最好。索引失效：全值匹配最喜欢，最左前缀规矩严。带头大哥不能死，中间兄弟不能断。索引列上少计算，范围之后全完蛋。LIKE百分最右边，覆盖索引*全不见。不等空值还有OR，你建索引也失效。VAR引号要出现，SQL高级也不难。 建立索引口诀：主键索引自动建，频繁查询索引现；查询关联其他表，外键索引也要看；频繁更新引不建，where条件用到算；单键&#x2F;组合选择难，高并发下组合建；若要速度有体现，排序字段索引建；统计、分组你咋看？索引索引建建建。 1. 尽量不在数据库做运算让数据库做它擅长的事情：尽量不在数据库做运算，复杂运算移到程序端，尽可能简单应用MySQL。 举例:md5()&#x2F;Order by rand() 2. 控制单表数据量 纯 INT 不超过 1000w； 含 char 不超过 500w； 合理分表不超载： userId DATE AREA 建议单库不超过 300~400 个表。 3. 保持表身段苗条 表字段数少而精 √ IO高效 √全表遍历 √表修复快 √提高幵发 √alter table快 单表1G体积 500W行评估 顺序读1G文件需N秒，单行不超过200Byte 单表不超过50个纯INT字段 单表不超过20个CHAR(10)字段 表字段数上限控制在 20~50 个。 4. 平衡范式与冗余严格遵循三大范式？在一些场景中，不必严格遵循三范式，没有绝对的对不错，可以适当时牺牲范式，加入冗余。比如效率优先、提升性能的场景。但会增加代码复杂度。 5. 拒绝3B大SQL（Big SQL）大事务（Big Transaction)大批量（Big Batch） 二、字段1. 用好数值类型TINYINT(1Byte)、SMALLINT(2B)、MEDIUMINT(3B)、INT(4B)、BIGINT(8B)、FLOAT(4B)、DOUBLE(8)、DECIMAL(M,D) 2. 将字符类型转为数字类型数字型VS字符串型索引： 更高效 查询更快 占用空间更小 举例：用无符号INT存储IP，而非CHAR(15)，使用数据库的函数去查看INT UNSIGNED、INET_ATON()、INET_NTOA() 3. 优先使用ENUM或SET优先使用 ENUM 或 SET 的情况：字符串，可能值已知且有限 优点： ENUM占用1字节，转为数值运算；SET视节点定，最多占用8字节 比较时需要加 &#39; 单引号(即使是数值) 举例： 12`sex` enum(&#x27;F&#x27;,&#x27;M&#x27;) COMMENT &#x27;性别&#x27;;`c1` enum(&#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;) COMMENT &#x27;职介审核&#x27;; 4. 避免使用NULL字段 很难进行查询优化 NULL列加索引，需要额外空间 含NULL复合索引无效 5. 少用并拆分TEXT&#x2F;BLOBTEXT 类型处理性能远低于 VARCHAR，会强制生成硬盘临时表，浪费更多空间：VARCHAR(65535) &#x3D;&#x3D;&gt; 64K (注意UTF-8)；尽量不用TEXT&#x2F;BLOB数据类型，若必须使用则拆分到单独的表 6. 不在数据库里存图片三、索引1. 谨慎合理添加索引，能不加的索引尽量不加 改善查询 减慢更新 索引不是越多越好，需要综合评估数据密度和数据分布；最好不超过字段数20%，结合核心SQL优先考虑覆盖索引 举例：不要给“性别”列创建索引 2. 字符字段必须建前缀索引使用场景：前缀的区分度比较高的情况下。 区分度 单字母区分度：$26$ 4字母区分度：$26 * 26 * 26 * 26 &#x3D; 456,976$ 5字母区分度：$26 * 26 * 26 * 26 * 26&#x3D;11,881,376$ 6字母区分度： $26 * 26 * 26 * 26 * 26 * 26&#x3D;308,915,776$ 建立前缀索引的方式： 1ALTER TABLE table_name ADD KEY(column_name(prefix_length)); 这里面有个 prefix_length 参数很难确定，这个参数就是前缀长度的意思。通常可以使用以下方法进行确定，先计算全列的区分度，然后在计算前缀长度为多少时和全列的区分度最相似。不断地调整 prefix_length 的值，直到和全列计算出区分度相近。 1234-- 全列区分度SELECT COUNT(DISTINCT column_name) / COUNT(*) FROM table_name; -- 计算前缀长度为多少时和全列的区分度最相似SELECT COUNT(DISTINCT LEFT(column_name, prefix_length)) / COUNT(*) FROM table_name; 3. 不在索引列做运算不在索引列进行数学运算或函数运算，否则会导致无法使用索引以及全表扫描。 4. 自增列或全局ID做INNODB主键 对主键建立聚簇索引 二级索引存储主键值 主键不应更新修改 按自增顺序插入值 忌用字符串做主键 聚簇索引分裂 推荐用独立于业务的 AUTO_INCREMENT 列或全局 ID 生成器做代理主键 若不指定主键，InnoDB会用唯一且非空值索引代替 5. 尽量不用外键尽量不使用外键，由程序来保证约束，实际中确实很少使用。虽然外键可节省开发量，但是有额外开销：逐行操作，可‘到达’其它表，意味着锁；在高并发场景容易死锁。 四、SQL1. SQL语句尽可能简单2. 保持事务连接小3. 尽可能避免使用SP&#x2F;TRIG&#x2F;FUNC尽可能少用存储过程、触发器；减用使用MySQL函数对结果进行处理，由客户端程序负责。 4. 尽量不用SELECT *，只取需要的数据列5. 改写OR为IN()同一字段，将OR改写为IN()。 OR效率：O(n)，IN 效率：O(Log n) 当n很大时，OR会慢很多。注意控制IN的个数，建议n小于200。 12select * from opp WHERE phone=&#x27;12347856&#x27; or phone=&#x27;42242233&#x27;;select * from opp WHERE phone in (&#x27;12347856&#x27; , &#x27;42242233&#x27;); 6. 改写OR为UNION不同字段，将or改为union 减少对不同字段进行 “or” 查询 Merge index往往很弱智，如果有足够信心：set globaloptimizer_switch=index_merge=off; 123456-- 原写法select * from opp WHERE phone=&#x27;010-88886666&#x27; or cellPhone=&#x27;13800138000&#x27;;-- 优化写法Select * from opp WHERE phone=&#x27;010-88886666&#x27; union Select * from opp WHERE cellPhone=&#x27;13800138000&#x27;; 7. 避免负向查询和使用%前缀模糊查询负向查询：NOT、!&#x3D;、&lt;&gt;、!&lt;、!&gt;、NOT EXISTS、NOT IN、NOT LIKE 等。 避免 % 前缀模糊查询: B+ Tree，不能使用索引，导致全表扫描，效率低。 1select * from post WHERE title like &#x27;北京%&#x27;&#x27;; 8. 少用count(*)COUNT(*)的资源开销大，尽量少用。 计数统计： 实时统计：用memcache，双向更新，凌晨跑基准； 非实时统计：尽量用单独统计表，定期重算。 9. LIMIT高效分页LIMIT 的偏移量越大则查询越慢。 123456-- 分页方式一Select * from table WHERE id&gt;=23423 limit 11;-- 分页方式二Select * from table WHERE id &gt;= ( select id from table limit 10000,1 ) limit 10;-- 分页方式三SELECT * FROM table INNER JOIN (SELECT id FROM table LIMIT 10000,10) USING (id) ; 按场景分析并重组索引。 10. 用UNION ALL而非UNION若无需对结果去重，则用 UNION ALL，UNION 有去重开销。 11. 分解连接保证高并发高并发DB不建议进行两个表以上的JOIN 适当分解联接保证高幵发 可缓存大量早期数据 使用了多个MyISAM表 对大表的小ID IN() 联接引用同一个表多次 举例： 123456MySQL&gt; Select * from tag JOIN tag_post on tag_post.tag_id=tag.id JOIN post on tag_post.post_id=post.id WHERE tag.tag=‘二手玩具’;-- 拆分MySQL&gt; Select * from tag WHERE tag=‘二手玩具’;MySQL&gt; Select * from tag_post WHERE tag_id=1321;MySQL&gt; Select * from post WHERE post.id in (123,456,314,141) 12. GROUP BY去除排序 无需排序：Order by NULL 特定排序：Group by DESC&#x2F;ASC 13. 同数据类型的列值比较原则：数字对数字，字符对字符 数值列与字符类型比较 同时转换为双精度进行比对 字符列与数值类型比较 字符列整列转数值 不会使用索引查询 14. 不同数据类型的列值比较字符列与数值类型比较 123456-- 字段：`remark` varchar(50) NOT NULL COMMENT &#x27;备注,默认为空&#x27;,MySQL&gt;SELECT `id`, `gift_code` FROM gift WHERE `deal_id` = 640 AND remark=115127; MySQL&gt;SELECT `id`, `gift_code` FROM pool_gift WHERE `deal_id` = 640 AND remark=&#x27;115127&#x27;; 15. Load Data导数据批量数据导入： 成批装载比单行装载更快，不需要每次刷新缓存 无索引时装载比索引装载更快 Insert values ,values，values 减少索引刷新 Load data 比 insert 快约20倍 尽量不用 INSERT ... SELECT，可能会出现延迟、同步出错 16. 打散大批量更新凌晨不限制；白天上限默认为100条&#x2F;秒（特殊再议） 1234update post set tag=1 WHERE id in (1,2,3);sleep 0.01;update post set tag=1 WHERE id in (4,5,6);sleep 0.01; 17. Know Every SQL1234567EXPLAINSHOW PROFILEShow Slow LogShow ProcesslistSHOW QUERY_RESPONSE_TIME(Percona)MySQLdumpslowMySQLsla 五、约定1. 隔离线上线下环境构建数据库的生态环境原则：线上连线上，线下连线下。 开发无线上库操作权限 实时数据用real库，模拟环境用sim库，测试用qa库，开发用dev库 2. 禁止未经DBA确认的子查询大部分情况子查询的优化较差，特别是 WHERE 中使用 IN 的子查询，一般可用JOIN改写。 3. 永远不在程序端显示加锁永远不在程序端对数据库显式加锁： 外部锁对数据库不可控 高并发时是灾难 极难调试和排查 并发扣款等一致性问题 采用事务 相对值修改 Commit前二次较验冲突 4. 统一字符集为UTF-85. 统一命名规范库表等名称统一用小写，注意避免用保留字命名。 索引命名默认为“idx_字段名” 库名用缩写，尽量在2~7个字母"},{"title":"PostgreSQL","path":"/wiki/Database/PostgreSQL.html","content":"PostgreSQL：最先进的开源数据库。 一、为什么使用PostgreSQLPostgreSQL 是一个功能强大的开源对象关系数据库系统，它使用并扩展了 SQL 语言，并结合了许多可安全存储和扩展最复杂数据工作负载的特性。PostgreSQL 的起源可以追溯到 1986 年，作为POSTGRES项目的一部分，并在核心平台上进行了 30 多年的积极开发。 PostgreSQL 因其久经考验的架构、可靠性、数据完整性、强大的功能集、可扩展性以及软件背后的开源社区致力于始终如一地提供高性能和创新解决方案而赢得了良好的声誉。PostgreSQL 可在所有主要操作系统一直符合 ACID，并具有强大的附加组件，例如流行的PostGIS地理空间数据库扩展器。毫不奇怪，PostgreSQL 已成为许多人和组织选择的开源关系数据库。 PostgreSQL 具有许多功能，旨在帮助开发人员构建应用程序、帮助管理员保护数据完整性和构建容错环境，并帮助您管理数据，无论数据集大小。除了免费和开源，PostgreSQL 还具有高度可扩展性。例如，您可以定义自己的数据类型、构建自定义函数，甚至使用不同的编程语言而无需重新编译数据库！ PostgreSQL 试图符合SQL 标准，这样的一致性不会与传统特性相矛盾或可能导致糟糕的架构决策。支持 SQL 标准所需的许多功能，但有时语法或功能略有不同。随着时间的推移，可以预期进一步朝着一致性迈进。从 2021 年 9 月发布的第 14 版开始，PostgreSQL 至少符合 SQL:2016 Core 一致性的 179 个强制性特性中的 170 个。在撰写本文时，没有任何关系数据库完全符合此标准。 以上内容摘自官网：https://www.postgresql.org/about/ 二、基础操作安装完成后切换到 postgres 用户，启动服务，输入 psql 进入 bash 环境，或者使用 psql -d databasename 进入指定的数据库。或者直接输入 sudo -u postgres psql 也是可以进入 bash 环境的。 用户bash命令1234# 清空指定用户的密码$ sudo passwd -d user# 设置指定用户的密码，根据系统提示进行输入即可$ sudo -u user passwd PostgreSQL客户端命令1234567891011121314151617# 连接本地数据库psql -U &lt;username&gt; -W dbname# 连接到远程数据库psql -h &lt;host&gt; -U &lt;username&gt; -W dbname# 修改密码ALTER USER postgres WITH PASSWORD &#x27;postgres&#x27;;# 显示所有数据库\\l# 显示当前数据库的所有表\\d# 显示数据库的表空间\\db+# 进入指定的数据库\\c dbname# 退出bash\\q Java连接操作Postgres1. 添加依赖123456789101112131415161718192021&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.baomidou/mybatis-plus-boot-starter --&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.postgresql/postgresql --&gt;&lt;dependency&gt; &lt;groupId&gt;org.postgresql&lt;/groupId&gt; &lt;artifactId&gt;postgresql&lt;/artifactId&gt; &lt;version&gt;42.5.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 2. 配置123456789101112server: port: 8080spring: datasource: url: jdbc:postgresql://localhost:5432/test username: postgres password: postgresmybatis-plus: type-aliases-package: com.basic.entity global-config: banner: false 测试略过，使用 Mybatis-plus 测试很简单。 3. 数据库类型和Java类型对应关系 database_type JavaType description timstamp with time zone OffsetDateTime 带时区的时间戳 timstamp without time zone LocalDateTime 不带时区的时间戳 timstamp without time zone LocalDateTime 不带时区的时间戳"},{"title":"MongoDB基础操作","path":"/wiki/Database/MongoDB基础操作.html","content":"MongoDB5.x版本基础操作整理，新版与之前的版本有些许变化。 MongoDB的三个默认库 基础操作 1.库操作 2.集合操作 3.文档操作 索引 1. 基本操作 2. 复合索引 3. 聚合查询（aggregate） SpringBoot 整合 MongoDB MongoDB架构 1. 主从复制（4.0 版本废弃，了解即可） 2. 副本集 3. 分片（sharding） 4. 环境搭建 MongoDB的三个默认库admin： root 数据库local： 这个数据永远不会复制，可以用来存储限于本地单台服务器的任意集合。config： 当 Mongo 用于分片设置时，config 数据库在内部使用，用于保存分片的相关信息。 这三个库一般不需要操作。 基础操作1.库操作12345678// 查看所有库show databases; / show dbs;// 切换/创建指定库(不存在即创建)use 库名;// 查看当前所在库db// 删除当前库db.dropDatabase(); 1.使用 use 创建新库时，如果库内没有集合数据时，使用 show databases 是看不到新建的库的，但是可以使用 db 查看当前所在库。2.使用删除库的命令时，删除后使用 db 命令还是在已删除的库中的，但是该库确实已经删除，因为该库已经没有数据了。 2.集合操作集合：就类似与 MySQL 数据库中的表的概念，一个集合对应一张表。在向不存在的集合插入数据时，会自动创建该集合并插入数据。 12345678// 创建库use 库名;// 查看集合show collections; / show tables;// 创建集合db.createCollection(&quot;集合名称&quot;);// 删除集合db.集合名称.drop(); 如果集合并不存在，使用文档操作插入数据时，会隐式的创建不存在的集合并插入该数据 3.文档操作官方文档https://docs.mongodb.com/manual/reference/method/ 文档：就是一条条的数据，增删改查就是针对文档的。每条文档在放入集合的时候，MongoDB会自动的维护一个 _id，当然，我们可以手动指定，该 id 不允许重复。 单条文档插入 1234567891011121314// 查询所有文档db.集合名称.find();// 插入单条文档db.集合名称.insert(&#123;&#125;);// 删除文档：第二个参数可选db.集合名称.remove(&#123;&#125;, &#123; # 只删除一条 justOne: true &#125;);// 查询文档总条数：db.user.count();// 查询符合条件的文档条数：db.user.find(&#123;age: 18&#125;).count(); 新版本使用 insert 也可以直接插入多条文档 多条插入 1234567891011121314db.集合名称.insertMany( [&#123;&#125;, &#123;&#125;], &#123; // 写入策略，默认为1，要求确认写操作;0不要求 writeConcern: 1, // 是否按顺序写入，默认true，按顺序插入 ordered: true &#125;);db.集合名称.insert([ &#123;&#125;, &#123;&#125;]); 脚本插入 123for (let i = 1; i &lt; 10; i++) &#123; db.集合名称.insert(&#123;name: &quot;小明&quot; + i, age: i+10, bir: &quot;2021-10-0&quot; + i&#125;);&#125; 文档删除 1234// 删除所有文档db.集合名称.remove(&#123;&#125;);// 删除指定条件的文档db.集合名称.remove(&#123;条件&#125;); 文档更新：最后一个参数是可选的 12345678910111213db.集合名称.update( &#123;查询指定文档(类似 where)&#125; &#123;目标更新值(set 后面的值)&#125;, &#123; // 如果查不到更新的文档，是否将当前文档插入集合中， // 默认false不插入 upsert: &lt;boolean&gt;, // 是否只更新查询到的第一条记录。默认false，只更新第一条记录 multi: &lt;boolean&gt;, // 抛出异常的级别 riteConcern: &lt;document&gt; &#125;); 1234// 默认更新方式：先删除，后插入 结果不保留其它字段db.user.update(&#123;name: &quot;小明&quot;&#125;, &#123;age: 19, likes: [&quot;看书&quot;, &quot;听音乐&quot;]&#125;);// 如果想在原始记录上直接更新：使用 $setdb.user.update(&#123;name: &quot;小明&quot;&#125;, &#123;$set:&#123;age: 19, likes: [&quot;吃饭&quot;, &quot;睡觉&quot;]&#125;&#125;); 默认的更新方式是先删除再插入，如果想保留其它的字段，在原始的记录上进行修改，需要使用 $set，例如：db.user.update(&#123;name:&quot;小明&quot;&#125;, &#123;$set:&#123;name:&quot;小黑&quot;&#125;&#125;)。 文档查询 123456789101112131415161718192021222324252627282930313233343536// 查询所有文档(默认显示前 20 条数据)db.集合名称.find();// 查询文档数量db.集合名称.count();db.集合名称.find(条件).count();// 格式化后展示数据db.集合名称.find().pretty();// 查询年龄大于20的db.集合名称.find(&#123;age: &#123;$gt: 20&#125;&#125;);// and 且查询：名字年龄同时满足db.集合名称.find(&#123;name: &#x27;小明&#x27;, age: 24&#125;);// or 或查询：名字年龄有一个满足db.集合名称.find(&#123;$or: [&#123;nmae: &quot;小明&quot;&#125;, &#123;age: 20&#125;]&#125;);// $size 按照数组长度查询db.集合名称.find(&#123;likes: &#123;$size: 2&#125;&#125;);// 排序（1：升序；-1：降序）// 按年龄升序排列输出db.集合名称.find().sort(&#123;name: 1, age: 1&#125;);// 模糊查询(使用正则实现，不能使用引号，使用 /)db.集合名称.find(&#123;name: /小/&#125;);// 分页查询 skip：起始条数 limit：每页条数db.集合名称.find(&#123;&#125;).skip(0).limit(2);// 去重db.集合名称.distinct(&#x27;age&#x27;);// 查询时指定返回字段(1：返回，0;不返回)。0和1不能同时用// 默认返回 _iddb.集合名称.find(&#123;&#125;, &#123;name: 1&#125;);// $type 查询，只查询字段为指定类型的文档数据db.集合名称.find(&#123;key: &#123;$type: 2&#125;&#125;);db.集合名称.find(&#123;key: &#123;$type: &#x27;String&#x27;&#125;&#125;); 符号 含义 $lt 小于 $gt 大于 $lte 小于等于 $gte 大于等于 $eq 等于 $ne 不等于 类型 对应数字 说明 Double 1 String 2 Object 3 Array 4 Binary data 5 Undefined 6 已废弃 Object id 7 Boolean 8 Date 9 Null 10 Regular Expression 11 JavaScript 13 Symbol 14 JavaScript(with scope) 15 32-bit integer 16 Timestamp 17 64-bit integer 18 Min key 255 Max key 127 注意： And查询时，如果同一个条件出现多次，那么后面的值会覆盖前面的。例如 db.user.find(&#123;name: &#39;小明&#39;,name: &#39;小红&#39;&#125;); 那么，会查找 name 为小红的数据。使用正则表达式实现近似的模糊查询时，需要使用 / 作为正则匹配符。$type 查询的 undefined 类型在新版本中已经废弃。MoongoDB中数字类型默认按 Double 类型存储，不论小数或者整数。查询时只返回指定的字段时，0和1不能同时使用。 索引1. 基本操作123456789101112131415161718192021222324// 创建索引(1:升序；-1:降序)：db.集合名称.createIndex(&#123;name: 1&#125;);// 创建复合索引(左前缀原则):db.集合名称.createIndex(&#123;name: 1, age: -1&#125;)// 查看所有索引：db.集合名称.getIndexes();// 查看索引大小(字节大小)：db.集合名称.totalIndexSize();// 创建升序索引：db.集合名称.createIndex(&#123;name:1&#125;)// 创建降序索引：db.集合名称.ensu// 创建索引指定索引名称：db.集合名称.createIndex(&#123;name:1&#125;, &#123;name: &quot;name_index&quot;&#125;)// 创建唯一索引：db.集合名称.createIndex(&#123;name:1&#125;, &#123;unique: true&#125;)// 创建指定时间过期的索引，单位：秒db.集合名称.createIndex(&#123;name: 1&#125;, &#123;expireAfterSeconds: 20&#125;);// 删除指定索引db.集合名称.dropIndex(&quot;索引名称&quot;);// 删除所有索引，不包含 _iddb.集合名称.dropIndexes(); 2. 复合索引一个索引的值由多个key共同维护的索引称为复合索引。MongoDB的复合索引和关系型数据库一样，也满足最左匹配原则。 3. 聚合查询（aggregate）主要用于处理数据。 表达式 描述 $sum 计算总和 $avg 计算平均值 $min 获取集合中所有文档对应值的最小值 $max 获取集合中所有文档对应值的最大值 $push 将值加入一个数组中，不会判断是否只有重复的值 $addToSet 将值加入一个数组中，会判断是否有重复的值，若该值数组中已经存在，则不加入 $first 根据资源文档的排序获取第一个文档数据 $last 根据资源文档的排序获取最后一个文档数据 举例： 1234567// _id 不是文档的id，而是聚合查询的标识符db.test.aggregate([&#123;$group: &#123;_id: &#x27;$by_user&#x27;, &#x27;avg_by_user&#x27;: &#123;$avg: &#x27;$likes&#x27;&#125;&#125;&#125;])//聚合查询：查询喜欢该作者的人数的平均值、最大值、最小值。// 即获取 liskes 列的平均值，最大值，最小值db.test.aggregate([&#123;$group: &#123;_id: &#x27;$by_user&#x27;, &#x27;avg_by_user&#x27;: &#123;$avg: &#x27;$likes&#x27;&#125;&#125;&#125;])db.test.aggregate([&#123;$group: &#123;_id: &#x27;$by_user&#x27;, &#x27;max_by_user&#x27;: &#123;$max: &#x27;$likes&#x27;&#125;&#125;&#125;])db.test.aggregate([&#123;$group: &#123;_id: &#x27;$by_user&#x27;, &#x27;min_by_user&#x27;: &#123;$min: &#x27;$likes&#x27;&#125;&#125;&#125;]) 注意： 在使用以上的聚合查询时，使用的 _id 不是文档默认维护的id，而是以哪个字段为标识符进行分组查询。上面的例子就是以 by_user 字段为标识符。类似MySQL中的 order by xxx。 SpringBoot 整合 MongoDB 引入依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt; &lt;version&gt;2.6.4&lt;/version&gt;&lt;/dependency&gt; 配置 properties 或者 yaml 编写程序 MongoDB架构1. 主从复制（4.0 版本废弃，了解即可）备份、故障恢复、读扩展生产环境中，如果使用的是老版本的 MongoDB，推荐的从节点不超过 12 个。 从节点：仅仅负责数据同步，冗余备份，不能进行自动故障转移。 启动主节点：.&#x2F;mongod –port 27017 –dbpath &#x2F;root&#x2F;data&#x2F;master –master –bind_ip 0.0.0.0 –oplogSize 100启动多个从节点：.&#x2F;mongod –port 27018 –dbpath &#x2F;root&#x2F;data&#x2F;slave1 –slave –bind_ip 0.0.0.0 –source 192.168.10.1:27017 –only 100 –autoresync.&#x2F;mongod –port 27019 –dbpath &#x2F;root&#x2F;data&#x2F;slave2 –slave –bind_ip 0.0.0.0 –source 192.168.10.1:27017 –only 100 –source： 指定主库的位置–only： 指定复制哪个库 默认的从节点也不能查看，开启从节点的查看权限： rs.slaveOK(); yum install -y lrzsz 文件的上传和下载 2. 副本集为了解决主从复制中自动转移的问题，尽管主从在新版本中已经废弃，MongoDB 又提出了新的结构，就是副本集。可以理解为带有自动故障转移的主从复制架构。推荐的副本集为奇数个。 副本集必须进行初始化。 123mongod --port 27017 --dbpath ../repl/data1 --bind_ip 0.0.0.0 --replSet myreplace/[localhost:27018,localhost:27019]mongod --port 27018 --dbpath ../repl/data2 --bind_ip 0.0.0.0 --replSet myreplace/[localhost:27017,localhost:27019]mongod --port 27019 --dbpath ../repl/data3 --bind_ip 0.0.0.0 --replSet myreplace/[localhost:27017,localhost:27018] –replRet 副本集，myreplace 副本集名称&#x2F;集群中其它节点的主机和端口。对副本集进行查看时，如果不允许查询，使用 rs.secondaryOk()后再进行查询。多个副本集组成的的名称必须一样推荐使用本机IP地址，尽量不要使用 localhost 配置副本集，连接任意节点：use admin初始化副本集： 12345678910111213# 初始化配置：如果错了可以多次修改，以最后一次为准&gt; var config = &#123; _id:&quot;myreplace&quot;, members:[ # 副本集主机地址：端口 # 推荐使用本机的IP地址，不要使用 localhost &#123;_id:0, host: &quot;localhost: 27017&quot;&#125;, &#123;_id:1, host: &quot;localhost: 27018&quot;&#125;, &#123;_id:2, host: &quot;localhost: 27019&quot;&#125;, ]&#125;# 调用初始化函数&gt; rs.initiate(config); 当集群超过半数以上的节点宕机时，集群无法对外提供服务。 3. 分片（sharding）目的：解决单点压力问题（并发访问） Shard：用于存储实际的数据块，实际生产环境中一个shard server角色可由几台机器组成一个replica set承担，防止主机单点故障。Config Server：mongod实例，存储了整个ClusterMetadata。Query Routers：前端路由，客户端由此接入，且让整个集群看上去像单一数据库，前端应用可以透明使用。Shard Key：片键，设置分片时需要在集合中选择一个片键作为拆分数据的依据。片键的选取决定了数据散列是否均匀。 4. 环境搭建MongoDB4.0版本之后要求Config Server必须以副本集方式部署，以保证系统的高可用。也建议每一个Shard也为一个副本集，目前没有强制要求必须为副本集。 创建三个分片，每一个分片创建一个副本集，一共是6个。再创建3个Config Server和一个Router Process，一共10个端口，9个数据目录。 1.启动s0 r0 1234567891011121314# 分片./mongod --port 27017 --dbpath ../cluster/shard/s0 --bind_ip 0.0.0.0 shardsvr --replSet r0/121.5.167.13:27018# 对应副本集./mongod --port 27018 --dbpath ../cluster/shard/s0-repl --bind_ip 0.0.0.0 shardsvr --replSet r0/121.5.167.13:27017# 登录任意节点执行use admin# 编写配置config = &#123;_id: &quot;r0&quot;, members:[ &#123;_id: 0, host: &quot;121.5.167.13:27017&quot;&#125;, &#123;_id: 1, host: &quot;121.5.167.13:27018&quot;&#125;,]&#125;# 初始化，在初始化之前的配置信息可以多次执行，以最后一次为准rs.initiate(config); 2.启动s1 r1 12345678910111213./mongod --port 27019 --dbpath ../cluster/shard/s1 --bind_ip 0.0.0.0 shardsvr --replSet r1/121.5.167.13:27020./mongod --port 27020 --dbpath ../cluster/shard/s1-repl --bind_ip 0.0.0.0 shardsvr --replSet r1/121.5.167.13:27019# 登录任意节点执行use admin# 编写配置config = &#123;_id: &quot;r1&quot;, members:[ &#123;_id: 0, host: &quot;121.5.167.13:27019&quot;&#125;, &#123;_id: 1, host: &quot;121.5.167.13:27020&quot;&#125;,]&#125;# 初始化rs.initiate(config); 3.启动s2 r2 12345678910111213./mongod --port 27021 --dbpath ../cluster/shard/s2 --bind_ip 0.0.0.0 shardsvr --replSet r3/121.5.167.13:27022./mongod --port 27022 --dbpath ../cluster/shard/s2-repl --bind_ip 0.0.0.0 shardsvr --replSet r2/121.5.167.13:27021# 登录任意节点执行use admin# 编写配置config = &#123;_id: &quot;r2&quot;, members:[ &#123;_id: 0, host: &quot;121.5.167.13:27021&quot;&#125;, &#123;_id: 1, host: &quot;121.5.167.13:27022&quot;&#125;,]&#125;# 初始化rs.initiate(config); 4.启动3个config服务 12345678910111213141516./mongod --port 27023 --dbpath ../cluster/shard/config1 --bind_ip 0.0.0.0 --replSet config/[121.5.167.13:27024,121.5.167.13:27025] --configsvr./mongod --port 27024 --dbpath ../cluster/shard/config2 --bind_ip 0.0.0.0 --replSet config/[121.5.167.13:27023,121.5.167.13:27025] --configsvr./mongod --port 27025 --dbpath ../cluster/shard/config3 --bind_ip 0.0.0.0 --replSet config/[121.5.167.13:27023,121.5.167.13:27024] --configsvr# 初始化configuse admin# 编写配置config = &#123;_id: &quot;config&quot;, configsvr: true, members:[ &#123;_id: 0, host: &quot;121.5.167.13:27023&quot;&#125;, &#123;_id: 1, host: &quot;121.5.167.13:27024&quot;&#125;, &#123;_id: 1, host: &quot;121.5.167.13:27025&quot;&#125;,]&#125;# 初始化rs.initiate(config); 5.启动路由服务 1./mongod --port 27026 --configdb config/121.5.167.13:27023,121.5.167.13:27024,121.5.167.13:27025 --bind_ip 0.0.0.0 6.登录 mongos 服务 123456789101112./mongo --port 27026use admin# 添加分片信息db.runCommand(&#123;addshard: &quot;121.5.167.13:27017&quot;, &quot;allowLocal&quot;:true&#125;);db.runCommand(&#123;addshard: &quot;121.5.167.13:27019&quot;, &quot;allowLocal&quot;:true&#125;);db.runCommand(&#123;addshard: &quot;121.5.167.13:27021&quot;, &quot;allowLocal&quot;:true&#125;);# 启用指定数据库的分片db.runCommand(&#123;enablesharding: &quot;xxx&quot;&#125;);# 设置库的片键信息 xxx库的xxxx集合，使用 _id 作为片键（不推荐）db.runCommand(&#123;shardcollection: &quot;xxx.xxxx&quot;, key: &#123;_id: 1&#125;&#125;);# 使用 xxx库xxxx集合的 _id 的哈希作为散列（推荐）db.runCommand(&#123;shardcollection: &quot;xxx.xxxx&quot;, key: &#123;_id: &quot;hashed&quot;&#125;&#125;);"},{"title":"数据库","path":"/wiki/Database/index.html","content":"数据库相关内容"},{"title":"Redis","path":"/wiki/Database/Redis.html","content":"Redis 是一个 Key-Value 结构的开源（BSD）的非关系型数据库。 一、了解Redis 两种数据持久化方式 1. RDB（数据快照） 2. AOF（操作记录） 内存淘汰策略 二、Redis的几种模式 伪集群搭建配置文件示例 三、缓存设计典型问题 1. 缓存穿透 布隆过滤器 2. 缓存击穿（失效） 3. 缓存雪崩 热点缓存key重建优化 四、规范建议 1. key名设计 2. value设计 一、了解RedisRedis 是一个开源（BSD 许可）的内存数据结构存储，用作数据库、缓存、消息代理和流引擎。Redis 提供数据结构，例如字符串、散列、列表、集合、排序集合、带范围查询的位图、超日志、地理空间索引和流。Redis 内置复制、Lua 脚本、LRU 驱逐、事务和不同级别的磁盘持久性，并通过Redis Sentinel提供高可用，Redis Cluster 提供自动分区。 您可以原子操作对这些类型附加到字符串；增加哈希值；将元素推入列表；计算集交并、差；或获取排序集中排名最高的成员。 为了达到最佳性能，Redis 使用内存中的数据集。根据您的用例，Redis 可以通过定期将数据集转储到磁盘或将每个命令附加到基于磁盘的日志。如果您只需要一个功能丰富的网络内存缓存，您也可以禁用持久性。 Redis 支持异步复制，具有快速非阻塞同步和自动重新连接以及网络拆分上的部分重新同步。 应用场景举例：缓存系统（“热点”数据：高频读、低频写）、计数器、消息队列系统、排行榜、社交网络和实时系统。 两种数据持久化方式1. RDB（数据快照）优点：RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于进行备份：并且 Redis 加载 RDB 恢复数据远远快于 AOF 的方式。你可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。缺点：由于每次生成 RDB 开销较大，非实时持久化，可能会出现数据丢失（类似于定时任务）。 体积更小；恢复更快；性能更高 2. AOF（操作记录）优点：数据保证开启后，Redis每执行一个修改数据的命令，都会把这个命令追加到 AOF 文件中。AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。 缺点：对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积（和 RDB 相反）。 根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。 如果开启了 AOF，在服务重启恢复数据时会以 AOF 为准恢复数据；如果同时开启了 AOF 和 RDB持久化，在服务重启恢复数据时会以 AOF 为准恢复数据；如果只开启了 RDB，在服务重启恢复数据时会以 dump 的方式恢复数据； 内存淘汰策略内存淘汰策略：Redis 的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。 二、Redis的几种模式 主从模式redis 主从复制，从节点默认是只读的，当 master 服务挂掉之后，从节点不能代替主节点；主从复制架构只是一个数据的备份。 哨兵模式(建立在主从模式上)哨兵的作用，就是监控主、从数据库的状态，当主数据库宕机以后，哨兵会在一定的时间内去判断，然后在从数据库中选举出一个去顶替主数据库，从而实现redis数据的高可用。 集群模式 Redis 的集群模式使用了 CRC16 算法，该算法有以下特点: 对集群模式下的所有key进行 CRC16 计算，计算的结果始终在 0-16383 之间（Redis 有 16384 的 slot） 对客户端的key进行CRC16算法计算时，同一个key经过多次计算，计算结果始终一致。 对客户端的不同的key进行CRC16计算，会出现不同的key计算结果一致。 伪集群搭建配置文件示例搭建 redis 伪集群实现 session 共享：修改不同端口的配置文件： 1234567891011121314151617# 启动端口号port 7000# 允许远程连接bind 0.0.0.0# rdb 方式持久化数据的文件名dbfilename dump-7000.rdb# 开启守护进程(即后台运行)daemonize yes# 开启 aof 缓存并指定 aof 方式持久化数据的文件名appendonly yesappendonlyfilename &quot;appendonly-7000.aof&quot;# 开启集群配置cluster-enabled yes# 配置集群节点名称cluster-config-file nodes-7000.conf# 集群超时时间 5scluster-node-timeout 5000 配置主从数据库后使用 redis-cli 进行连接后，使用 info replication 命令查看当前数据库的 role，“master” 是主节点，“slave” 是从节点。默认从库是只读的，不能进行写操作。 三、缓存设计典型问题1. 缓存穿透缓存穿透是指查询一个根本不存在的数据，缓存层和存储层都不会命中，通常出于容错的考虑，如果从存储层查不到数据则不写入缓存层。缓存穿透将导致不存在的数据每次请求都要到存储层去查询，失去了缓存保护后端存储的意义。造成缓存穿透的基本原因有两个：第一，自身业务代码或者数据出现问题。第二，一些恶意攻击、爬虫等造成大量空命中。 解决方案： 缓存空对象； 布隆过滤器对于恶意攻击，向服务器请求大量不存在的数据造成的缓存穿透，还可以用布隆过滤器先做一次过滤，对于不存在的数据，布隆过滤器一般都能够过滤掉，不让请求再往后端发送。当布隆过滤器说某个值存在时，这个值可 能不存在；当它说不存在时，那就肯定不存在。 布隆过滤器布隆过滤器就是一个大型的位数组和几个不一样的无偏 hash 函数。所谓无偏就是能够把元素的 hash 值算得比较均匀。 向布隆过滤器中添加 key 时，会使用多个 hash 函数对 key 进行 hash，算得一个整数索引值然后对位数组长度进行取模运算得到一个位置，每个 hash 函数都会算得一个不同的位置。再把位数组的这几个位置都置为 1 就完成了 add 操作。向布隆过滤器询问 key 是否存在时，跟 add 一样，也会把 hash 的几个位置都算出来，看看位数组中这几个位置是否都为 1，只要有一个位为 0，那么说明布隆过滤器中这个 key 不存在。如果都是 1，这并不能说明这 个 key 就一定存在，只是极有可能存在，因为这些位被置为 1 可能是因为其它的 key 存在所致。如果这个位数组比较稀疏，这个概率就会很大，如果这个位数组比较拥挤，这个概率就会降低。这种方法适用于数据命中不高、数据相对固定、实时性低（通常是数据集较大）的应用场景，代码维护较为 复杂，但是缓存空间占用很少。 2. 缓存击穿（失效）由于大批量缓存在同一时间失效可能导致大量请求同时穿透缓存直达数据库，可能会造成数据库瞬间压力过大甚至挂掉，对于这种情况我们在批量增加缓存时最好将这一批数据的缓存过期时间设置为一个时间段内的不同时间。 3. 缓存雪崩由于缓存层承载着大量请求，能够有效地保护存储层，但是如果缓存层由于某些原因不能提供服务(比如超大并 发过来，缓存层支撑不住，或者由于缓存设计不好，类似大量请求访问bigkey，导致缓存能支撑的并发急剧下降)，于是大量请求都会打到存储层，存储层的调用量会暴增，造成存储层也会级联宕机的情况。预防和解决缓存雪崩问题，可以从以下三个方面进行着手。1） 保证缓存层服务高可用性，比如使用 Redis Sentinel 或 Redis Cluster。2） 依赖隔离组件为后端限流熔断并降级。比如使用 Sentinel 或 Hystrix 限流降级组件。比如服务降级，我们可以针对不同的数据采取不同的处理方式。当业务应用访问的是非核心数据（例如电商商 品属性，用户信息等）时，暂时停止从缓存中查询这些数据，而是直接返回预定义的默认降级信息、空值或是错误提示信息；当业务应用访问的是核心数据（例如电商商品库存）时，仍然允许查询缓存，如果缓存缺失，也可以继续通过数据库读取。3） 提前演练。在项目上线前，演练缓存层宕掉后，应用以及后端的负载情况以及可能出现的问题，在此基础上做一些预案设定。 热点缓存key重建优化开发人员使用“缓存+过期时间”的策略既可以加速数据读写，又保证数据的定期更新，这种模式基本能够满足绝大部分需求。 但是有两个问题如果同时出现，可能就会对应用造成致命的危害：当前key是一个热点key（例如一个热门的娱乐新闻），并发量非常大。重建缓存不能在短时间完成，可能是一个复杂计算，例如复杂的SQL、多次IO、多个依赖等。在缓存失效的瞬间， 有大量线程来重建缓存，造成后端负载加大，甚至可能会让应用崩溃。要解决这个问题主要就是要避免大量线程同时重建缓存。我们可以利用互斥锁来解决，此方法只允许一个线程重建缓存，其他线程等待重建缓存的线程执行完，重新从缓存获取数据即可。 伪代码12345678910111213141516171819202122String get(String key) &#123; // 从Redis中获取数据 String value = redis.get(key); // 如果value为空，则开始重构缓存 if (value == null) &#123; String mutexKey = &quot;mutext:key:&quot; + key; // 只允许一个线程重建缓存，使用nx，并设置过期时间ex if (redis.set(mutexKey, &quot;1&quot;, &quot;ex 180&quot;, &quot;nx&quot;)) &#123; // 从数据源获取数据 value = db.get(key); // 回写Redis，并设置过期时间 redis.setex(key, timeout, value); // 删除key_mutex redis.delete(mutexKey); &#125; else &#123; // 其他线程休息50毫秒后重试 Thread.sleep(50); get(key); &#125; &#125; return value; &#125; 四、规范建议1. key名设计 可读性和可管理性：以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如 业务名:表名:id。 简洁性：保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视。 不要包含特殊字符。 2. value设计 拒绝bigkey(防止网卡流量、慢查询) 在Redis中，一个字符串最大512MB，一个二级数据结构（例如hash、list、set、zset）可以存 储大约40亿个(2^32-1)个元素，但实际中如果下面两种情况，我就会认为它是bigkey。 字符串类型：它的big体现在单个value值很大，一般认为超过10KB就是bigkey。 非字符串类型：哈希、列表、集合、有序集合，它们的big体现在元素个数太多。一般来说，string类型控制在10KB以内，hash、list、set、zset元素个数不要超过5000。反例：一个包含200万个元素的list。非字符串的bigkey，不要使用del删除，使用hscan、sscan、zscan方式渐进式删除，同时要注意防止bigkey过期时间自动删除问题(例如一个200万的zset设置1小时过期，会触发del操作，造成阻塞）。 bigkey的危害： 导致redis阻塞 网络拥塞bigkey也就意味着每次获取要产生的网络流量较大，假设一个 bigkey 为 1 MB，客户端每秒访问量为1000，那么每秒产生1000MB的流量，对于普通的千兆网卡(按照字节算是128MB&#x2F;s)的服务器来说简直是灭顶之灾，而且一般服务器会采用单机多实例的方式来部署，也就是说一个 bigkey 可能会对其他实例也造成影响，其后果不堪设想。 过期删除有个bigkey，它安分守己（只执行简单的命令，例如hget、lpop、zscore等），但它设置了过期时间，当它过期后，会被删除，如果没有使用 Redis4.0 的过期异步删除(lazyfree-lazy-expire yes)，就会存在阻塞Redis的可能性。 一般来说，bigkey 的产生都是由于程序设计不当，或者对于数据规模预料不清楚造成的，来看几个例子：(1) 社交类：粉丝列表，如果某些明星或者大v不精心设计下，必是bigkey。(2) 统计类：例如按天存储某项功能或者网站的用户集合，除非没几个人用，否则必是bigkey。(3) 缓存类：将数据从数据库 load 出来序列化放到 Redis 里，这个方式非常常用，但有两个地方需要注意。第一，是不是有必要把所有字段都缓存；第二，有没有相关关联的数据，有的同学为了图方便把相关数据都存一个 key 下，产生 bigkey。 如何优化bigkey？ 拆big list： list1、list2、…listN；big hash：可以讲数据分段存储，比如一个大的key，假设存了1百万的用户数据，可以拆分成 200 个key，每个key下面存放5000个用户数据 如果 bigkey 不可避免，也要思考一下要不要每次把所有元素都取出来(例如有时候仅仅需要 hmget，而不是 hgetall)，删除也是一样，尽量使用优雅的方式来处理。 选择适合的数据类型。 例如：实体类型(要合理控制和使用数据结构，但也要注意节省内存和性能之间的平衡) 正例反例1hmset user:1 name tom age 19 favor football123set user:1:age 19 3 set user:1:favor footballset user:1:name tom"},{"title":"业务常用SQL","path":"/wiki/Database/业务常用SQL.html","content":"一些常用的业务 SQL，另外数据库推荐使用日期格式：%Y-%m-%d %H:%i:%s。 MySQL123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051-- 重置表 ID 从 1 开始自增; id_key 为自增 idalter table table_name drop id_key;alter table table_name add id_key int not null primary key auto_increment first;-- 增加递增列SELECT @rank:=@rank + 1 AS num FROM (SELECT @rank:=0) a-- 构建近 12 个月的月份虚拟表-- 注意：table_name 中的数据记录条数必须 &gt;= 12 SELECT DATE_FORMAT(@cdate := date_add( @cdate, INTERVAL - 1 MONTH ),&#x27;%Y-%m&#x27;) AS cdateFROM (SELECT @cdate := date_add(NOW(), INTERVAL 1 MONTH ) FROM table_name LIMIT 12) a ORDER BY cdate-- 构建近 30 天的天数虚拟表-- 注意：table_name 中的数据记录条数必须 &gt;= 30SELECT DATE_FORMAT(@cdate := date_add( @cdate, INTERVAL - 1 DAY ),&#x27;%Y-%m-%d&#x27;) AS cdateFROM (SELECT @cdate := date_add(now(), INTERVAL 1 DAY ) FROM table_name LIMIT 30) a ORDER BY cdate-- 构建近 30 天的日期虚拟表，此种写法 indexs 不能去掉，必须查询，适合有这种需求的使用-- 同样，table_name 中的数据记录条数必须 &gt;= 30SELECT @cdate := @cdate + 1 AS indexs,DATE_FORMAT( DATE( DATE_SUB( CURRENT_DATE, INTERVAL @s DAY ) ), &#x27;%Y-%m-%d&#x27; ) AS cdate FROM table_name, ( SELECT @cdate := -1 ) tempWHERE @cdate &lt; 30ORDER BY cdate-- 查询今天的数据SELECT * FROM table_name WHERE TO_DAYS(create_time) = TO_DAYS(NOW());-- 查询当前一周的数据 1 表示一周的第一天从星期一开始SELECT * FROM table_name WHERE YEARWEEK(DATE_FORMAT(create_time,&#x27;%Y-%m-%d&#x27;), 1) = YEARWEEK(NOW(), 1);-- 查询本月的数据SELECT * FROM table_name WHERE DATE_FORMAT(create_time, &#x27;%Y-%m&#x27;) = DATE_FORMAT(CURDATE(), &#x27;%Y-%m&#x27;);-- 查询最近七天的数据(当前日期往前推七天)SELECT a.cdate AS mdayFROM ( SELECT CURDATE() AS cdate UNION ALL SELECT DATE_SUB(CURDATE(), INTERVAL 1 DAY) AS cdate UNION ALL SELECT DATE_SUB(CURDATE(), INTERVAL 2 DAY) AS cdate UNION ALL SELECT DATE_SUB(CURDATE(), INTERVAL 3 DAY) AS cdate UNION ALL SELECT DATE_SUB(CURDATE(), INTERVAL 4 DAY) AS cdate UNION ALL SELECT DATE_SUB(CURDATE(), INTERVAL 5 DAY) AS cdate UNION ALL SELECT DATE_SUB(CURDATE(), INTERVAL 6 DAY) AS cdate) a LEFT JOIN ( SELECT DATE(create_time) AS c_time, other FROM table_name GROUP BY DATE(create_time)) b ON a.cdate = b.c_time ORDER BY mday; Oracle1234567891011121314-- 补全一年 12 个月select lpad(level,2,0) from dual connect by level&lt;13select to_char(sysdate, &#x27;yyyy-&#x27;) || lpad(level, 2, 0) datevalue from dual connect by level &lt; 13;--oracle 未来12个月SELECT TO_CHAR(ADD_MONTHS(ADD_MONTHS(SYSDATE, 0), ROWNUM - 1), &#x27;YYYY-MM&#x27;) AS YEARMONTHFROM ALL_OBJECTSWHERE ROWNUM &lt;= 12;--oracle 前12个月SELECT TO_CHAR(ADD_MONTHS(SYSDATE, 1 - ROWNUM), &#x27;YYYY-MM&#x27;) AS YEARMONTHFROM ALL_OBJECTSWHERE ROWNUM &lt;= 12; hive、oracle、mysql内建函数对照表 PG1234-- 生成指定的一段时间的连续日期，学了这个我感觉 MySQL5.7 是个什么垃圾！！！select to_char(cdate,&#x27;YYYY-MM-DD&#x27;) as date fromgenerate_series(to_timestamp(&#x27;2023-03-27&#x27;,&#x27;YYYY-MM-DD&#x27;), to_timestamp(&#x27;2023-04-01&#x27;,&#x27;YYYY-MM-DD&#x27;),&#x27;1 days&#x27;) as cdateorder by date PG 的 generate_series 函数可以学习一下，非常 nice：https://www.cnblogs.com/mchina/archive/2013/04/03/2997722.html"},{"title":"GitHub+PicGo搭建图床","path":"/wiki/Git/GitHub+PicGo搭建图床.html","content":"一、PicGo是什么？在本机如何使用？PicGo 是图片上传到其它存储平台的助手。它支持多种图床：weibo, qiniu, tcyun, upyun, github, aliyun, imgur and SM.MS。 我们在写文章的过程中，免不了要在文章内放置图片，对于自己搭建的博客网站，或者是自己编写 md 文档，那么图片的处理就比较麻烦了，截图、命名、存储等都是问题。 二、本机安装 PicGo安装完成启动 PicGo 客户端，点击图床设置，选择 Github图床，点击 设为默认图床，然后进行图床的配置： 设定仓库名：username&#x2F;repo 设定分支名：main 设定Token：GitHub 平台创建的 token 指定存储路径：指定仓库下的指定分支下的文件夹路径。简单理解就是把图片放在仓库的哪个目录下。 设定自定义域名：图片成功上传后返回的链接，格式为 自定义设定域名&#x2F;指定存储路径&#x2F;上传后的图片名称 。浪子这里使用了 jsdelivr 的 CDN 加速链接。 配置完成后就可以在上传区选择需要上传的图片啦。比如打开资源管理器选择图片，或者直接拖动需要上传的图片到上传区区域，PicGO 就会把这些图片上传到指定的 Github 仓库的路径下。 三、配置 Github1. 创建一个存放图片的仓库2. 建立一个目标分支，默认是 main3. 创建 Github Token登录Github，点击头像，依次选择 settings -&gt; Developer settings -&gt; Personal access tokens，选择 Generate new token，进入填写如下信息，填写完毕点击最后的绿色按钮 Generate token 保存。注意：生成的 token 只会显示一次，一定要复制后保存下来。 否则需要重新生成。 上面的步骤都完成之后把相应的信息填写到 PicGo 中，然后就可以使用该软件进行图片上传啦~ 四、VSCode+PicGo插件浪子经常使用 VsCode 写 markdown 文件，之前不经常在文章里放图片，后来放图片的时候感觉真麻烦。不过幸好，VsCode 里也有 PicGo 的插件供我们使用。单纯在 VsCode 中使用这个插件不需要安装 PicGo 客户端。 1. VsCode安装PicGo插件打开 VsCode 的扩展商店搜索 picgo，安装图中红框框中插件。 安装完成后使用 Ctrl + Shift + P 快捷键，搜索打开 settings.json 文件，添写以下内容保存，这里面的内容和上面的配置类似。 settings.json12345678910111213141516171819// 如果在本机安装了 PicGo 客户端，第一次启动后会自动生成 json 文件，然后你只需要配置这一项就 OK 啦// &quot;picgo.configPath&quot;: &quot;C:\\\\Users\\\\你的用户名\\\\AppData\\\\Roaming\\\\picgo\\\\data.json&quot;,// 如果本机没有安装 PicGo 客户端，只安装了 PicGo 插件，需要配置以下信息// 当前使用图床 可选：weibo, qiniu, tcyun, upyun, github, aliyun, imgur and SM.MS&quot;picgo.picBed.current&quot;: &quot;github|weibo|qiniu|tcyun|upyun|aliyun|imgur|SM.MS&quot;,&quot;picgo.picBed.uploader&quot;: &quot;github|weibo|qiniu|tcyun|upyun|aliyun|imgur|SM.MS&quot;,// 设定分支&quot;picgo.picBed.github.branch&quot;: &quot;branch&quot;,// 设定仓库&quot;picgo.picBed.github.repo&quot;: &quot;repo&quot;,// token&quot;picgo.picBed.github.token&quot;: &quot;token&quot;,// 自定义返回的链接&quot;picgo.picBed.github.customUrl&quot;: &quot;return-url&quot;,// 上传路径&quot;picgo.picBed.github.path&quot;: &quot;path&quot;, 2. 在VsCode中使用快捷键 OS 从剪切板上传 从资源管理器上传图像（打开文件夹选择上传） 从输入框上传图像 Windows&#x2F;Unix Ctrl + Alt + U Ctrl + Alt + E Ctrl + Alt + O OsX Cmd + Opt + U Cmd + Opt + E Cmd + Opt + O"},{"title":"GitHub Action部署Hexo博客","path":"/wiki/Git/GithubAction部署Hexo博客.html","content":"一、什么是Github ActionGitHub Actions 是一个持续集成和持续交付 (CI&#x2F;CD) 平台，可用于自动执行构建、测试和部署管道。可以创建工作流程来构建和测试存储库的每个拉取请求，或将合并的拉取请求部署到生产环境。 GitHub Actions 不仅仅是 DevOps，还允许您在存储库中发生其他事件时运行工作流程。例如，您可以运行工作流程，以便在有人在您的存储库中创建新问题时自动添加相应的标签。 GitHub 提供 Linux、Windows 和 macOS 虚拟机来运行工作流程，或者您可以在自己的数据中心或云基础架构中托管自己的自托管运行器。 二、使用Github Action部署Hexo博客使用过 Github Pages 和 Hexo 服务的少侠都知道，我们写完文章的时候，都会执行 hexo cl &amp;&amp; hexo g &amp;&amp; hexo d 这几条命令去发布到 Pages 仓库。如果有 备份 的小伙伴们，可能会在 Pages 的仓库（yourname.github.io）使用另一个 分支 去存储备份；或者直接使用两个仓库：Pages 仓库和存储 Hexo 的文件备份。这时当我们写完文章后，使用推送命令 git add . &amp;&amp; git commit -m &quot;add/update&quot; &amp;&amp; git push 把文件提交到备份库&#x2F;分支，然后再执行 hexo cl &amp;&amp; hexo g &amp;&amp; hexo d部署到 Pages 服务的分支或者仓库。 从上面介绍来看，需要备份文件的Hexo博客，每次都需要经过两个步骤： 备份写好的文件以及主题等配置 Pages仓库部署静态文件 那么能不能简化成为一步呢？答案是肯定的，CI&#x2F;CD 在日常的项目中已经是很常见的了，接下来我们使用 Github Action 来帮助我们完成自动部署。这样我们自己只需要在本地写好文章，然后推送到远程仓库，至于后面的 hexo cl &amp;&amp; hexo g &amp;&amp; hexo d 这几个命令就交给 Action 去帮助我们自动完成。 当然，有的少侠喜欢写完直接部署，隔一段时间才进行备份文件的推送，亦或者不需要文件&#x2F;主题配置的备份，可能觉得这样做没必要（浪子以前就是）。这个看少侠自己的情况了，如果想把玩把玩Github Action，可以当作 CI&#x2F;CD 的入门案例。 三、开始1. SSH密钥配置SSH 密钥的作用我想大家都了解了，这里配置这个密钥是两个仓库或者两个分支去通信的凭证。举个栗子，Pages服务是单独一个仓库，而我的备份文件在一个私有库中(一般备份不想让他人可见)，我在我的私有库中使用了Github Action，把自己的内容去部署发布到 Pages 仓库。这样不同仓库或者不同分支进行交互时就需要一个身份的验证。这样我想大家就理解了，下面的内容就是生成一个 SSH 密钥对，把 公钥 放在 Pages 服务仓库的变量里，把 私钥 放在 备份仓库 的变量里，之后在 Action 的 yml 文件中去使用，这样备份仓库就可以与 Pages 仓库完成认证并顺利部署了。 1.1 创建新的SSH密钥：ssh-keygen -t rsa -C &#39;xxx@xx.com&#39; -f ~/.ssh/action_rsa，创建完成后会在 ~/.ssh/ 路径下生成两个文件：action_rsa 和 action_rsa.pub 1.2 设置密钥 Github Pages服务同一个仓库的新分支存放备份 在 yourname.github.io 仓库，依次点击 settings -&gt; Deploy keys -&gt; Add deploy key。 title随便填写，记着就行，后面编写脚本需要用到； key填写上面生成的 action_rsa.pub 公钥的全部内容； Allow write access 选项打勾。 然后还是在仓库的 settings 页面，点击 Deploy keys 下面的 Secrets 选项，选择 Actions，新建一个 secret： Name 随便填写，后面编写脚本需要用到； Value 填写 action_rsa 私钥的全部内容。 新仓库存放备份 如果 Github Pages 个人博客和 Hexo 备份文件是在两个不同的仓库中，密钥的配置和上面类似。不同之处在于 action_rsa 私钥需要放在 Hexo 备份仓库的便量里。其它的步骤都和 2.1 一样。 至此，密钥的配置结束。 2. Action脚本Github Action 的脚本文件是在 .github/workflows/xxx.yml 路径下，是 yml 格式的。我们可以使用别人已经写好的脚本，也可以全部自己编写。 需要注意的是，如果你使用的 Hexo 主题中有自定义标签，并且在 markdown 文件中有所使用的话，Action 自动部署的时候会发生解析错误，找不到自定义标签的解析内容，这点需要注意。解决办法就是在 Hexo 仓库中使用 git submodule add origin https://github.com/xxxx/ themes/xxx 的方式去添加主题，在 yml 文件中使用 submodules: true 选项开启子模块检出，下面给两个不同的示例。其中，第二种方式在部署的时候可以把提交信息返回给 Action 自动部署的仓库中。 纯脚本文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263name: Hexo Blog CI# master branch on push, auto runon: push: branches: - main jobs: build: runs-on: ubuntu-latest steps: # check it to your workflow can access it # from: https://github.com/actions/checkout - name: Checkout Repository main branch uses: actions/checkout@v3 # 是否检出子模块，此选项只对 git submodule add &lt;你使用的主题地址&gt; 生效，对于直接 git clone 的主题不生效 # 推荐在选择 Hexo 主题时，使用 git submodule add https://github.com/xxx/xxx.git themes/xxx with: submodules: true fetch-depth: 0 # from: https://github.com/actions/setup-node - name: Setup Node.js 16.x uses: actions/setup-node@v3 with: node-version: 16 check-latest: true # 缓存node_modules，避免每次跑action都要重新下载 - name: Cache node modules uses: actions/cache@v1 id: cache with: path: node_modules key: $&#123;&#123; runner.os &#125;&#125;-node-$&#123;&#123; hashFiles(&#x27;**/package-lock.json&#x27;) &#125;&#125; restore-keys: | $&#123;&#123; runner.os &#125;&#125;-node- - name: Setup Hexo Dependencies run: | npm install hexo-cli -g npm install - name: Setup Deploy Private Key env: # 引用之前设置的仓库私钥 HEXO_DEPLOY_PRIVATE_KEY: $&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125; run: | mkdir -p ~/.ssh/ echo &quot;$HEXO_DEPLOY_PRIVATE_KEY&quot; &gt; ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts - name: Setup Git Infomation run: | git config --global user.name &quot;github-action&quot; git config --global user.email &quot;github-action@no-reply.com&quot; - name: Deploy Hexo run: | hexo clean hexo generate hexo deploy 3. 测试以上内容全部完成后，本地新建一个 md 文件后添加内容后，直接推送到远程仓库，等待一段时间，访问 yourname.github.io 查看是否有自己的新文章吧！还是推荐查看 Action 流程，可以查看出错原因。 4. 后话说说后话，当你配置好了，整个博客可以自动部署的时候，另一个问题就是 Action 部署之后所有文章 的 创建日期 和 更新日期 都会变为部署时候的日期。这也是自动部署带来的问题，毕竟 Github Action 是 clone 了我们的仓库后进行操作的。目前的解决方法就是在每一篇的文章的 front-matter 中加入 date 字段去标识。可以参考这篇博客。不过浪子都是手动创建 md 文件写文章，时间这个问题不解决也没大碍，以后有解决方案会更新过来。 5. 解决如果是用了上面浪子提供的脚本的少侠，直接安装安装插件：npm install hexo-filter-date-from-git --save 即可，如果是使用自己的脚本，则需要查看脚本中是否含有 fetch-depth: 0 选项，该选项的填写位置可以参考上面浪子提供的脚本。 之前在 Github 官方的 checkout 脚本的介绍中发现： 123456# Fetch all history for all tags and branchessteps:- name: Checkout uses: actions/checkout@v3 with: fetch-depth: 0 本以为加上这一个就可以解决部署的创建时间的问题，但是结果还是不如人意。后来在群里的一位大佬的指导下，说是需要安装一个 Hexo 的插件，就是上面那个。然后才可以在部署的时候去使用 git commit 的时间去覆盖原有的 date、updated 选项(不论文章的 front-matter 设置与否都会覆盖)。 另外，值得注意的是，如果使用了这个插件，你的 md 文件名称不能含有空格，否则 Action 自动部署会失败。 至此，问题解决，呼，真不容易~"},{"title":"Git 命令","path":"/wiki/Git/Git命令.html","content":"Git常用命令Git 的命令使用特别多，详情可以去 Git官方文档 查阅，这里只罗列一些常用的命令。 工作区：本地计算机文件位置暂存区：执行 git add xxx 后的文件位置版本索引：执行 git commit -m 后远程库（代码托管平台：Github、gitee等）：执行 git push 后文件位置 1. 配置命令12345678910111213141516171819# 配置个人信息，方便远程托管平台统计个人的贡献$ git config --global user.name &quot;个人名称或昵称&quot;$ git config --global user.email &quot;你的邮箱&quot;# 列出所有配置信息：$ git config --list# 取消某一项全局配置$ git config --global --unset user.name################### 下面的配不配都不重要，记住上传的文件都是 LF 就行 ################## core.autocrlf 这个设置主要针对换行符问题，使用新版的 Git 一般不用设置，这个不会有大问题，只是格式问题。# Window 设置 (检入时自动转换为LF，检出时LF转为CRLF)$ git config --global core.autocrlf true# Mac、Linux 设置 (检入时CRLF替换为LF，检出时无操作)$ git config --global core.autocrlf input# 更新 git 到最新版本（window适用）git update-git-for-windows 检入：提交，检出: 下载 2. 添加、删除、提交、推送、比较123456789101112131415161718192021222324252627282930313233# 将当前目录所有文件添加到git暂存区，也可以一次提交多个文件，使用空格分开$ git add .# 提交到版本库并备注提交信息$ git commit -m &quot;my first commit&quot;# 如果第一次提交的内容写的不好或者还有新的相关文件未提交，可以使用下面的命令覆盖之前一次的 commit$ git commit --amend -m &quot;override first commit&quot;# 推送到远程仓库,如果本地和远程的分支名称相同，只写一个分支名称即可# 第一个 master 是本地分支，后面的一个是远程分支$ git push origin [local-branch]:[remote-branch]# 移除文件# 从暂存区移除文件，会把工作区相应文件一并删除，回收站无法还原。如果该文件没有提交，则无法删除，可以使用 -f 选项强制删除。$ git rm [file]# 只删除暂存区文件，保留工作区文件 $ git rm --cached [file]# 删除提交到暂存区的内容$ git rm --cache [file]# 查看提交历史：$ git log# 图形化显示$ git log --graph # 单行显示、短格式、长格式 oneline，short，full$ git log --pretty=oneline/short/full# 撤销工作区中所有未提交的修改内容，将暂存区与工作区都回到上一次版本，并删除之前的所有信息提交：$ git reset --hard 版本ID# 回退到某个版本：$ git reset --soft 版本库ID# 文件比较# 查看工作目录与暂存区的不同$ git diff 3. 分支123456789101112# 切换分支$ git checkout [branch] / git switch [branch]# 删除本地分支$ git branch -d [branch]# 查看本地所有分支$ git branch -a# 查看远程分支$ git branch -r# 查看本地与远程分支的一映射关系$ git branch -vv# 重命名本地分支$ git branch -m [old-branch] [new-branch] 4. 远程操作12345678910111213141516171819202122# 克隆远程库到本地$ git clone https://github.com/个性地址/仓库名称.git# 克隆指定的分支$ git clone -b 分支名称 仓库地址# 关联远程仓库$ git remote add origin https://gitee.com/用户个性地址/HelloGitee.git# 取消远程关联$ git remote remove origin# 查看关联的远程库地址$ git remote -v# 关联上游仓库$ git remote add upstream 仓库地址# 取消关联上游仓库$ git remote remove upstream# 删除远程分支 --delete 简写为 -d$ git push origin -d branch_name# 将本地分支推送到远程分支并建立映射，如果远程不存在将自动创建$ git push -u origin 分支名称 4. 一张图总结git常用命令小结"},{"title":"Git 提交信息","path":"/wiki/Git/Git规范提交信息.html","content":"Git 提交信息规范是一个好的习惯，这样团队合作的时候，如果出问题可以先看 git log，但是如果提交的信息不明确却就……所以我们可以使用工具辅助在提交的时候填写相关内容。 一、commitizen简介commitizen：基于 Node.js 的 git commit 命令行工具，辅助生成标准化规范化的 commit message。 cz-git、git-cz、cz-customizable、cz-conventional-changelog 等是 commitizen 的适配器：提交时选择的交互式页面，依赖于 commitizen 工作。你可以全部安装体验，找到自己喜欢的使用，使用哪个适配器在 package.json 中配置即可。 本文选用 cz-git 进行安装。 cz-git Github 地址： 二、安装1. 本地安装cz-git12npm install -g commitizennpm install -D cz-git package.json12345678&#123; ... &quot;config&quot;: &#123; &quot;commitizen&quot;: &#123; &quot;path&quot;: &quot;./node_module/cz-git|git-cz|cz-customizable|cz-conventional-changelog&quot; &#125; &#125;&#125; 2. 全局安装cz-git1npm install -g commitizen cz-git package.json12345678&#123; ... &quot;config&quot;: &#123; &quot;commitizen&quot;: &#123; &quot;path&quot;: &quot;cz-git|git-cz|cz-customizable|cz-conventional-changelog&quot; &#125; &#125;&#125; 3. 使用1cz 多人合作避免 cz-git 版本不一致问题可以选用本地安装，使团队成员使用同一个版本，个人可以直接使用全局安装。 三、czgczg 的安装、使用非常方便，它也可以进行自定义配置，但是省去了很多的麻烦，浪子非常推荐使用，具体内容可以查看 官方文档。 无需前置配置，无需适配器，没有额外的步骤，你可以使用 npx | npm 脚本 | 全局下载... 在你的任何项目中快速启动。可定制化: 内部包含 cz-git 的核心，继承了 cz-git 的所有特性，具有相同的行为，配置加载… 你可以根据自己的需要配置的 CLI 的行为。 1234# 全局安装npm i -g czg# 特性以及帮助文档czg --help"},{"title":"Git 进阶","path":"/wiki/Git/Git进阶.html","content":"一、 Git Submodulegit submodule 是一个很好的多项目使用共同类库的工具，它允许类库项目做为 repository，子项目做为一个单独的git项目存在父项目中，子项目可以有自己的独立的commit，push，pull。而父项目以Submodule的形式包含子项目，父项目可以指定子项目header，父项目中会的提交信息包含Submodule的信息，再clone父项目的时候可以把Submodule初始化。 说人话就是一个 Git 仓库内部包含其它 Git 仓库，把外面的成为 Git 仓库，里面的称之为 Git 子仓库&#x2F;子模块。常用的命令也是添加、更新、删除。 如果是初次添加子模块： 1git submodule add [repository-url] [custom-directory-path] 如果是 clone 一个含有 submodule 的仓库，直接 clone 后子模块是一个空的文件夹，当然也支持直接 clone 子模块： 12345678910# 直接 clone 仓库以及子仓库git clone --recurse-submodules [repository-url]# clone 后单独 clone 子模块git clone [repository-url]cd [repository-path]/[submodule-path]git submodule init &amp;&amp; git submodule update# init 和 update 也可以使用一个命令git submodule update --init --recursive 1. 删除submodulegit 并不支持直接删除 submodule，需要手动删除对应的文件: 12345cd [repository-path]git submodule deinit [submodule-path]git rm -r [submodule-path]git commit -m &quot;delete submodule&quot;git push"},{"title":"git","path":"/wiki/Git/index.html","content":"在三、四、五、六线城市以及像浪子所在的偏远小山村中想要直接使用浏览器访问 GitHub 是有问题的，输入网址后按下回车键，这个页面都不带刷新的，直接出现 “无法访问该网站” 的错误。解决办法之一就是修改 hosts 文件。 hosts 文件不同的操作系统位置不同，如果是 window 系统，他在 C:\\Windows\\System32\\drivers\\etc 目录下；如果是 Linux 系统，则在 /etc/hosts。这里推荐火绒，可以直接打开火绒，点击修改 hosts 文件，方便好用。注意先对 hosts 文件备份，防止修改错误后可以还原。 首先访问 IPAddress.com，右上角输入 github.com 回车查询。将获取到的网址与 github.com 对应写入到 hosts 文件中。这样基本就可以了。 hosts 文件保存最好先以管理员身份启动记事本后再打开，防止权限不足。"},{"title":"Git 配置","path":"/wiki/Git/Git配置.html","content":"Git官方文档https://git-scm.com/book/zh/v2 Git配置多个SSH密钥Git 的官网下载比较慢，可以去 淘宝镜像站 选择合适的版本进行下载。 Git 安装后配置一下基本信息，这样每次的提交记录都会显示该名称，如果参与了项目，可以统计项目贡献等： 12345678# 配置个人信息，方便远程托管平台统计个人的贡献$ git config --global user.name &quot;个人名称或昵称&quot;$ git config --global user.email &quot;你的邮箱&quot;# 列出所有配置信息：$ git config --list / git config -l# 取消某一项全局配置$ git config --global --unset user.name 为什么配置SSH密钥？避免每次 pull、push 都需要我们手动去输入账户信息。用户信息的认证工作通过 SSH 认证自动帮我们进行。 1. 生成Github用的SSH-Key1234# Linux Mac$ ssh-keygen -t ed25519 -C &#x27;xxx@xx.com&#x27; -f ~/.ssh/github_id_rsa# Window$ ssh-keygen -t ed25519 -C &#x27;xxx@xx.com&#x27; -f C:/Users/用户名/.ssh/github_id_rsa 2. 生成gitee使用的SSH-Key1234# Linux Mac$ ssh-keygen -t ed25519 -C &#x27;xxx@xx.com&#x27; -f ~/.ssh/gitee_id_rsa# Window$ ssh-keygen -t ed25519 -C &#x27;xxx@xx.com&#x27; -f C:/Users/用户名/.ssh/gitee_id_rsa 2022-08-22 修改为 ed25519 密钥生成。 3. 配置在大多数系统中，默认私钥（~&#x2F;.ssh&#x2F;id_rsa 和 ~&#x2F;.ssh&#x2F;identity）会自动添加到 SSH 身份验证代理中。应无需运行 ssh-add path&#x2F;to&#x2F;key，除非在生成密钥时覆盖文件名。 在 Linux 系统中比较容易出现 Permission denied (publickey) 的错误，这就需要使用 ssh-add 把签名的指纹加入到 SSH 的 session 中。但是也会出现问题，综合以上内容，浪子推荐在本地配置 config 文件，我们手动创建文件并添加如下内容（其中 Host 和 HostName 填写 git 服务器的域名，IdentityFile 指定私钥的路径） .ssh/config123456789101112131415161718192021# github1# Host 可以自己定义，在此文件中必须唯一，之后在 down 源码时需要使用这个自定义的 hostHost github.com# HostName 是代码托管平台的域名，例如：code.aliyun.com, github.com, gitee.come 等HostName github.com# 设置用户身份认证方式，这里当然使用 公钥 的方式PreferredAuthentications publickey# 指定公钥对应的私钥路径IdentityFile ~/.ssh/github1_id_rsa# github2Host xyzgithub.comHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/github2_id_rsa# giteeHost gitee.comHostName gitee.comPreferredAuthentications publickeyIdentityFile ~/.ssh/gitee_id_rsa 如果同一个平台配置了多个不同账号的SSH密钥，那么在进行 clone、remote 等操作时，地址需要做一些改变，否则会找不到而报错。在克隆时 git@github.com:xx.git 需要替换为对应的 Host 内容。 例如使用 github2 的账户关联远程仓库： 1git remote add origin git@xyzgithub.com:XXX/repository.git 这里需要使用我们自定义的 Host 内容。 4. 测试是否配置成功1234# 使用 ssh -T 进行测试，成功的话会打印 Hi，username……$ ssh -T git@gitee.com$ ssh -T git@github.com$ ssh -T git@xyzgithub.com 以gitee为例，成功的话会返回下图内容： sucess 5.Windows 中 Git-Bash 中配置 tree 命令和 ll 命令5.1 tree下载tree的二进制文件 后解压，把 bin 目录下的 tree.exe 文件复制到 Git 安装目录 xxx\\Git\\usr\\bin\\ 下即可。 5.1 ll在用户的根目录下 C:\\Users\\jhlz 新建一个 .bashrc 文件（如果有的话就不需要了），熟悉的少侠应该这个文件是做什么的以及如何配置。在该文件中加入以下内容，保存退出: .bashrc1alias ll=&#x27;ls -al&#x27;"},{"title":"Java开发问题总结","path":"/wiki/Java/Java开发问题总结.html","content":"Java 开发遇到的问题以及解决方案整理。 一、Java1. Excel文件导出时中文被转义解决方案详细原理了解：http://www.iefans.net/xiazai-wenjian-http-bianma-content-disposition/ 12String fileName = URLEncode.encode(name, &quot;UTF-8&quot;);response.setHeader(&quot;Content-disposition&quot;, &quot;attachment;filename=&quot;+fileName+&quot;;&quot;+&quot;filename*=utf-8&#x27;&#x27;&quot;+fileName); 文件的下载在响应之前要设置以 附件（attachment） 的形式，否则点击下载时会在浏览器打开。Spring MVC 默认的上传文件大小(max-request-size)最大为10M，可以在 配置文件中修改 二、Spring1. Spring Security跨线程获取用户信息使用 Spring Security 时，如果采用异步方法获取用户信息是获取不到的，它采用 ThreadLocal 存储，这样的话有些请求无法顺利执行，可以在 Spring Boot 启动类主方法添加： 123456public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); // 开启本地线程共享 SecurityContextHolder.setStrategyName(SecurityContextHolder.MODE_INHERITABLETHREADLOCAL); log.info(&quot;启动&quot;);&#125; 2. swagger如果在项目中实现 ResponseBodyAdvice 接口统一封装 controller 返回的接口，访问 swagger 地址时会出现弹窗 Unable to infer base url. This is common when using dynamic servlet registration or when the API is behind an API Gateway 的问题。 需要在实现 ResponseBodyAdvice 的类注解上额外加入 @RestControllerAdvice(basePackages = &quot;xxx.xx.controller&quot;) 限定需要对返回结果进行封装的范围，这样的话就不会拦截 swagger 相关资源的地址，访问就正常了。 也可以下面这样修改（浪子没有测试，具体见：https://juejin.cn/post/6921700441038258189）： 123456789101112131415161718192021@RestControllerAdvice// @RestControllerAdvice(basePackages = &quot;com.example.controller&quot;) // 只对此包中的类进行结果封装public class ResultResponseHandler implements ResponseBodyAdvice &#123; @Override public boolean supports(MethodParameter returnType, Class converterT ype) &#123; // 过滤不需要封装的结果 if (returnType.getParameterType().isAssignableFrom(ResultResp.class)) &#123; return false; &#125; return true; &#125; @Override public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) &#123; if (body instanceof Json || body instanceof UiConfiguration || (body instanceof ArrayList &amp;&amp; ((ArrayList) body).get(0) instanceof SwaggerResource)) &#123; return body; &#125; return ResultResp.success(body); &#125; 3. 跨域注解方式全局配置MVC全局配置注解方式解决跨域12345// 注解用在 Controller 类中，该类所有方法允许其它域中进行访问@CrossOriginpublic class xxxController &#123;&#125;全局配置解决跨域1234567891011121314@Configurationpublic class CorsConfig &#123; @Bean public CorsFilter corsFilter() &#123; UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); CorsConfiguration config = new CorsConfiguration(); config.setAllowedOrigins(&quot;*&quot;); config.setAllowedHeaders(&quot;*&quot;); config.setAllowedMethods(&quot;*&quot;); // 处理所有请求的跨域配置 source.registerCorsConfiguration(&quot;/**&quot;, config); return new CorsFilter(source); &#125;&#125;MVC配置解决跨域1234567891011121314151617181920@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; /** * 跨域访问（CORS） * * @param registry */ @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/**&quot;) .allowCredentials(false) // 所有头 .allowedHeaders(&quot;/**&quot;) // 所有源 .allowedOrigins(&quot;/**&quot;) // 所有方法 .allowedMethods(&quot;/**&quot;) .maxAge(5000); &#125;&#125; 三、MyBatis&#x2F;MyBatis Plus（MP）Result Maps collection does not contain value for ……在 SQL 文件中使用了 resultType=&quot;java.util.map&quot;，并且不止一处使用，那么凡是使用 resultType 或者 resultMap 这种属性的标签，不能有属性指向错误，否则就会报错： “Result Maps collection does not contain value for ……” Parameter index out of range (2 > number of parameters, which is 1).不能在 mybatis 的 sql.xml 中的 sql 标签（&lt;select&gt;、&lt;update&gt;、&lt;delete&gt;等）中注释 sql 语句，如果注释的语句中 带有参数，那么就会报这个错误。如果有必须注释的语句，把相关语句复制一份放在 mybatis 标签外面使用&lt;!-- 注释 sql 内容 --&gt; 注释。如果可以，还是把 SQL 语句存储在外部的 txt 等文本文件里。 1. $ And #这个我想很多人都知道使用哪个比较好了，说说问题。具体语句省略，请注意循环内的条件。 123456789101112select * from user uleft join address a on u.address = a.sitewhere a.longitude = #&#123;longitude&#125; and a.latitude = #&#123;latitude&#125;&lt;if test=&quot;mallId != null and mallId != &#x27;&#x27;&quot;&gt; and u.mallId = #&#123;mallId&#125;&lt;/if&gt;&lt;if test=&quot;propertyType != null and propertyType.size() &gt; 0&quot;&gt; and u.property_type in &lt;foreach collection=&quot;propertyType&quot; index=&quot;index&quot; item=&quot;type&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt; $&#123;type&#125; &lt;/foreach&gt;&lt;/if&gt; 上面的语句在循环中使用了 $&#123;&#125;，我把它修改成了 #&#123;&#125;，但是输入的筛选的条件是不会生效的，继而没有返回数据。 #{}不生效 之后看了看它传的参数，发现接口接收的字符串，然后在业务层转为字符串集合，并且为每个元素加入单引号后传入 SQL 的。 字符串转集合 于是猜想可能就是这个原因导致查询条件不生效，于是把这段代码改成了下面的样子： 字符串转集合修改版 这段代码没有给分割后的字符加入英文单引号，map 方法对每一个元素都去掉前后的空格（请结合自身业务场景确定参数是否可包含空格，浪子这里不需要），然后再次测试该接口，perfect！it is working now! 之后使用修改后的字符转集合方法代码再次使用 $&#123;&#125; 去测试，发现 SQL 语句查询又不生效了。。。 于是浪子明白了：使用 $&#123;&#125; 时，参数为 List 类型需要我们为每个元素手动加入单引号，使用单引号包裹才会生效；而使用 #&#123;&#125; 时，List 参数类型则不需要我们手动加入英文单引号，直接传入 List 即可。 2. 接口传参报错错误信息： 1No primary or default constructor found for interface java.util.List] 后端使用 List&lt;String&gt; 或者数组接参数收时，前端传入数组接收不到；但是可以传字符串，每个元素可以使用英文 , 分割。 3. MP插入或更新null值当使用 Mybatis Plus 时，更新数据为 null 值时，即使数据库的字段设置为可以为 null，但是更新或插入时还是数据更新失败。这个就涉及到字段验证策略了。MP 官网也给出了 解决办法"},{"title":"Java开发总结、踩坑记录等乱七八糟的","path":"/wiki/Java/index.html","content":"感谢 Stellar 的作者提供了这么简洁好用的主题。"},{"title":"项目介绍","path":"/wiki/market/index.html","content":"项目介绍this is an open source project, it for … dev-toolsJdk 17+SpringBoot 3.0+（Spring6）Postgresql 15+Gradle 7.5+ Notice 使用构造注入 减少依赖项 Feature token 登录，passwordencode 自动选择默认使用的更新。 权限校验 日志记录 多数据源支持 Other"},{"title":"项目部署","path":"/wiki/market/项目部署.html","content":"this is a deploy remark, but Something’s wrong, Template render error: (unknown path) ,it amazing"},{"title":"Java API","path":"/wiki/Java/Java随笔/JavaApi.html","content":"一些 Java Api用法的话有空更新 1. 文件监听WatchService 接口可以用来实现对系统的文件进行监听。 123456789101112131415161718192021222324252627282930313233343536373839404142@Testpublic void watchFileTest() &#123; // 监听路径 String path = &quot;D:\\\\&quot;; try &#123; // 创建 WatchService 实例 WatchService watchService = FileSystems.getDefault().newWatchService(); // 这里只监听 创建 事件 // 除此之外，还有修改、删除、特殊事件 // StandardWatchEventKinds.ENTRY_MODIFY // StandardWatchEventKinds.ENTRY_DELETE // StandardWatchEventKinds.OVERFLOW Paths.get(path).register(watchService, StandardWatchEventKinds.ENTRY_CREATE); while (true) &#123; // 一直等待事件，如果没有就阻塞 // 如果对事件不是那么敏感，可以使用 watchService.poll(long timeout, TimeUnit unit) 每隔多少时间获取一次 WatchKey key = watchService.take(); // 获取事件列表 List&lt;WatchEvent&lt;?&gt;&gt; events = key.pollEvents(); // 由于只监听了一种事件，这里使用流处理。 events.stream() .filter(e -&gt; Objects.equals(e.kind(), StandardWatchEventKinds.ENTRY_CREATE)) .forEach(e -&gt; &#123; String fileName = e.context().toString(); System.out.println(&quot;创建了 [&quot; + fileName + &quot;] 文件&quot;); try &#123; // 休眠 1ms 是为了让系统完成相应的回调函数， // 否则你会看到输出多次 ”创建了 [&quot; + fileName + &quot;] 文件“ 内容 Thread.sleep(100); &#125; catch (InterruptedException ex) &#123; throw new RuntimeException(ex); &#125; &#125;); // 重置 watchKey 继续监听文件夹的事件 key.reset(); &#125; &#125; catch (IOException | InterruptedException e) &#123; throw new RuntimeException(e); &#125;&#125; 2. 获取某个接口的所有实现类ServiceLoader 的使用非常的简单。 12345@Testpublic void testServiceLoader() &#123; java.util.ServiceLoader&lt;AssetsStrategy&gt; strategies = java.util.ServiceLoader.load(AssetsStrategy.class); strategies.forEach(System.out::println);&#125; 当然，如果直接执行以上代码是没有任何打印内容的。因为它还需要一点儿额外的配置。你需要在 resources/META-INF 目录下新建 services 目录，然后在新建的目录中添加一个文件，这个文件名必须是 接口所在 的 包路径+接口名称，不带任何后缀，区分大小写。最后按照同样的格式把实现了该接口的实现类写到该文件中。 举个栗子，上面我要获取的是 AssetsStrategy 接口的实现类，假如该接口在 com.example.strategy 包中，并且它有 Model1、Model2 两个实现类，那么我应该在 resources/META-INF/services/com.example.strategy.AssetsStrategy 文件中添加以下内容： com.example.strategy.AssetsStrategy12com.example.model.Model1com.example.model.Model2 然后运行上面的测试代码，就可以看到结果啦~ Java 异步https://www.callicoder.com/java-8-completablefuture-tutorial/https://www.callicoder.com/java-concurrency-multithreading-basics/ https://www.codedemo.club/spring-security-async-principal-propagation/"},{"title":"JVM","path":"/wiki/Java/JVM/JVM.html","content":"JVM 简单理解就是运行 Java 等语言的“操作系统”，没有 JVM，Java 程序就无法运行。本篇文章就来整理一下，没有用到的就不写进来了，用过的或者学习的整理进来。 一、JVM内存模型 二、调优命令 三、常见调优工具 Arthas 四、JVM垃圾收集算法 五、JVM经典优化技术 附：JVM指令码 一、JVM内存模型JVM内存模型图 方法区和堆是所有线程共享的内存区域；而Java虚拟机栈、本地方法栈和程序员计数器是运行是线程私有的内存区域。 Java堆（Heap）,是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。 方法区（Method Area）,方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 程序计数器（Program Counter Register）,程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。当线程发生切换时，记录上次线程挂起的位置，之后线程切换回来的时候，继续从上次记录的位置开始执行。 虚拟机栈（JVM Stacks）,与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 本地方法栈（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。 说到方法区，不得不提一下“永久代”这个概念，尤其是在JDK8以前，许多Java程序员都习惯在HotSpot虚拟机上开发、部署程序，很多人都更愿意把方法区称呼为“永久代”（Permanent Generation），或将两者混为一谈。本质上这两者并不是等价的，因为仅仅是当时的HotSpot虚拟机设计团队选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得 HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的工作。但现在回头来看，当年使用永久代来实现方法区的决定并不是一个好主意，这种设计导致了Java应用更容易遇到内存溢出的问题（永久代有-XX：MaxPermSize的上限，即使不设置也有默认大小，而J9和JRockit只要 没有触碰到进程可用内存的上限，例如32位系统中的4GB限制，就不会出问题），而且有极少数方法 （例如String::intern()）会因永久代的原因而导致不同虚拟机下有不同的表现。当Oracle收购BEA获得了JRockit的所有权后，准备把JRockit中的优秀功能，譬如Java Mission Control管理工具，移植到HotSpot虚拟机时，但因为两者对方法区实现的差异而面临诸多困难。考虑到HotSpot未来的发展，在JDK 6的时候HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计划了，到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Meta-space）来代替，把JDK 7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。引自《深入理解Java虚拟机第二版》 周志明 二、调优命令Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfojps：JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。jstat：JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。jmap：JVM Memory Map命令用于生成heap dump文件。jhat：JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP&#x2F;HTML服务器，生成dump的分析结果后，可以在浏览器中查看jstack，用于生成java虚拟机当前时刻的线程快照。jinfo：JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。jstack：查找死锁。 12345678jmap ‐dump:format=b,file=eureka.hprof 14660# jstack pid -A 后面数字为显示的线程所在行的后面10行，最后的参数是线程id的16进制表示。jstack 19663|grep -A 10 4cd0jstat -gc pid# 打印GC日志方法 %t：时间java ‐jar ‐Xloggc:./gc‐%t.log ‐XX:+PrintGCDetails ‐XX:+PrintGCDateStamps ‐XX:+PrintGCTimeStamps ‐XX:+PrintGCCause ‐XX:+UseGCLogFileRotation ‐XX:NumberOfGCLogFiles=10 ‐XX:GCLogFileSize=100M xxxx.jar 三、常见调优工具常用调优工具分为两类,jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto。jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗GChisto，一款专业分析gc日志的工具 Arthas首先下载到本机，用java -jar运行即可，可以识别机器上所有Java进程。 输入dashboard可以查看整个进程的运行情况，线程、内存、GC、运行环境信息。详细使用参照 官方文档。 四、JVM垃圾收集算法 引用计数法 根可达算法 标记清除算法 标记复制算法 标记整理算法 五、JVM经典优化技术 方法内联： 方法内联就是把目标方法的代码原封不动地 “复制” 到发起调用的方法之中，避免发生真实的方法调用而已。但实际上Java虚拟机中的内联过程却远没 有想象中容易，甚至如果不是即时编译器做了一些特殊的努力，按照经典编译原理的优化理论，大多 数的Java方法都无法进行内联。除了消除方法调用的成本之外，它更重要的意义是为其他优化手段建立良好的基础。 只有使用 invokespecial指令调用的私有方法、实例构造器、父类方法和使用invokestatic指令调用的静态方法才会 在编译期进行解析。除了上述四种方法之外（最多再除去被final修饰的方法这种特殊情况，尽管它使 用invokevirtual指令调用，但也是非虚方法，《Java语言规范》中明确说明了这点），其他的Java方法 调用都必须在运行时进行方法接收者的多态选择，它们都有可能存在多于一个版本的方法接收者，简 而言之，Java语言中默认的实例方法是虚方法。 逃逸分析： 逃逸分析（Escape Analysis）是目前Java虚拟机中比较前沿的优化技术，它与类型继承关系分析一样，并不是直接优化代码的手段，而是为其他优化措施提供依据的分析技术。逃逸分析的基本原理是：分析对象动态作用域，当一个对象在方法里面被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，这种称为方法逃逸；甚至还有可能被外部线程访问到，譬如赋值给可以在其他线程中访问的实例变量，这种称为线程逃逸；从不逃逸、方法逃逸到线 程逃逸，称为对象由低到高的不同逃逸程度。如果能证明一个对象不会逃逸到方法或线程之外（换句话说是别的方法或线程无法通过任何途径 访问到这个对象），或者逃逸程度比较低（只逃逸出方法而不会逃逸出线程），则可能为这个对象实 例采取不同程度的优化比如栈上分配、标量替换、同步消除都是以此为基。 公共子表达式消除 公共子表达式消除是一项非常经典的、普遍应用于各种编译器的优化技术，它的含义是：如果一个表达式E之前已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么 E 的这次出现就称为公共子表达式。对于这种表达式，没有必要花时间再对它重新进行计算，只需要直 接用前面计算过的表达式结果代替E。如果这种优化仅限于程序基本块内，便可称为局部公共子表达式消除（Local Common Subexpression Elimination），如果这种优化的范围涵盖了多个基本块，那就称为全局公共子表达式消除（Global Common Subexpression Elimination）。 数组边界检查消除 附：JVM指令码 JVM指令码 助记符 说明 0x00 nop 什么都不做 0x01 aconst_null 将null推送至栈顶 0x02 iconst_m1 将int型-1推送至栈顶 0x03 iconst_0 将int型0推送至栈顶 0x04 iconst_1 将int型1推送至栈顶 0x05 iconst_2 将int型2推送至操作数栈顶 0x06 iconst_3 将int型3推送至栈顶 0x07 iconst_4 将int型4推送至栈顶 0x08 iconst_5 将int型5推送至栈顶 0x09 lconst_0 将long型0推送至栈顶 0x0a lconst_1 将long型1推送至栈顶 0x0b fconst_0 将float型0推送至栈顶 0x0c fconst_1 将float型1推送至栈顶 0x0d fconst_2 将float型2推送至栈顶 0x0e dconst_0 将double型0推送至栈顶 0x0f dconst_1 将double型1推送至栈顶 0x10 bipush 将单字节的常量值(-128~127)推送至栈顶 0x11 sipush 将一个短整型常量值(-32768~32767)推送至栈顶 0x12 ldc 将int, float或String型常量值从常量池中推送至栈顶 0x13 ldc_w 将int, float或String型常量值从常量池中推送至栈顶（宽索引） 0x14 ldc2_w 将long或double型常量值从常量池中推送至栈顶（宽索引） 0x15 iload 将指定的int型本地变量推送至栈顶 0x16 lload 将指定的long型本地变量推送至栈顶 0x17 fload 将指定的float型本地变量推送至栈顶 0x18 dload 将指定的double型本地变量推送至栈顶 0x19 aload 将指定的引用类型本地变量推送至栈顶 0x1a iload_0 将第一个int型本地变量推送至栈顶 0x1b iload_1 将第二个int型本地变量推送至栈顶 0x1c iload_2 将第三个int型本地变量推送至栈顶 0x1d iload_3 将第四个int型本地变量推送至栈顶 0x1e lload_0 将第一个long型本地变量推送至栈顶 0x1f lload_1 将第二个long型本地变量推送至栈顶 0x20 lload_2 将第三个long型本地变量推送至栈顶 0x21 lload_3 将第四个long型本地变量推送至栈顶 0x22 fload_0 将第一个float型本地变量推送至栈顶 0x23 fload_1 将第二个float型本地变量推送至栈顶 0x24 fload_2 将第三个float型本地变量推送至栈顶 0x25 fload_3 将第四个float型本地变量推送至栈顶 0x26 dload_0 将第一个double型本地变量推送至栈顶 0x27 dload_1 将第二个double型本地变量推送至栈顶 0x28 dload_2 将第三个double型本地变量推送至栈顶 0x29 dload_3 将第四个double型本地变量推送至栈顶 0x2a aload_0 将第一个引用类型本地变量推送至栈顶 0x2b aload_1 将第二个引用类型本地变量推送至栈顶 0x2c aload_2 将第三个引用类型本地变量推送至栈顶 0x2d aload_3 将第四个引用类型本地变量推送至栈顶 0x2e iaload 将int型数组指定索引的值推送至栈顶 0x2f laload 将long型数组指定索引的值推送至栈顶 0x30 faload 将float型数组指定索引的值推送至栈顶 0x31 daload 将double型数组指定索引的值推送至栈顶 0x32 aaload 将引用型数组指定索引的值推送至栈顶 0x33 baload 将boolean或byte型数组指定索引的值推送至栈顶 0x34 caload 将char型数组指定索引的值推送至栈顶 0x35 saload 将short型数组指定索引的值推送至栈顶 0x36 istore 将栈顶int型数值存入指定本地变量 0x37 lstore 将栈顶long型数值存入指定本地变量 0x38 fstore 将栈顶float型数值存入指定本地变量 0x39 dstore 将栈顶double型数值存入指定本地变量 0x3a astore 将栈顶引用型数值存入指定本地变量 0x3b istore_0 将栈顶int型数值存入第一个本地变量 0x3c istore_1 将栈顶int型数值存入第二个本地变量 0x3d istore_2 将栈顶int型数值存入第三个本地变量 0x3e istore_3 将栈顶int型数值存入第四个本地变量 0x3f lstore_0 将栈顶long型数值存入第一个本地变量 0x40 lstore_1 将栈顶long型数值存入第二个本地变量 0x41 lstore_2 将栈顶long型数值存入第三个本地变量 0x42 lstore_3 将栈顶long型数值存入第四个本地变量 0x43 fstore_0 将栈顶float型数值存入第一个本地变量 0x44 fstore_1 将栈顶float型数值存入第二个本地变量 0x45 fstore_2 将栈顶float型数值存入第三个本地变量 0x46 fstore_3 将栈顶float型数值存入第四个本地变量 0x47 dstore_0 将栈顶double型数值存入第一个本地变量 0x48 dstore_1 将栈顶double型数值存入第二个本地变量 0x49 dstore_2 将栈顶double型数值存入第三个本地变量 0x4a dstore_3 将栈顶double型数值存入第四个本地变量 0x4b astore_0 将栈顶引用型数值存入第一个本地变量 0x4c astore_1 将栈顶引用型数值存入第二个本地变量 0x4d astore_2 将栈顶引用型数值存入第三个本地变量 0x4e astore_3 将栈顶引用型数值存入第四个本地变量 0x4f iastore 将栈顶int型数值存入指定数组的指定索引位置 0x50 lastore 将栈顶long型数值存入指定数组的指定索引位置 0x51 fastore 将栈顶float型数值存入指定数组的指定索引位置 0x52 dastore 将栈顶double型数值存入指定数组的指定索引位置 0x53 aastore 将栈顶引用型数值存入指定数组的指定索引位置 0x54 bastore 将栈顶boolean或byte型数值存入指定数组的指定索引位置 0x55 castore 将栈顶char型数值存入指定数组的指定索引位置 0x56 sastore 将栈顶short型数值存入指定数组的指定索引位置 0x57 pop 将栈顶数值弹出 (数值不能是long或double类型的) 0x58 pop2 将栈顶的一个（long或double类型的)或两个数值弹出（其它） 0x59 dup 复制栈顶数值并将复制值压入栈顶 0x5a dup_x1 复制栈顶数值并将两个复制值压入栈顶 0x5b dup_x2 复制栈顶数值并将三个（或两个）复制值压入栈顶 0x5c dup2 复制栈顶一个（long或double类型的)或两个（其它）数值并将复制值压入栈顶 0x5d dup2_x1 &lt;待补充&gt; 0x5e dup2_x2 &lt;待补充&gt; 0x5f swap 将栈最顶端的两个数值互换(数值不能是long或double类型的) 0x60 iadd 将栈顶两int型数值相加并将结果压入栈顶 0x61 ladd 将栈顶两long型数值相加并将结果压入栈顶 0x62 fadd 将栈顶两float型数值相加并将结果压入栈顶 0x63 dadd 将栈顶两double型数值相加并将结果压入栈顶 0x64 isub 将栈顶两int型数值相减并将结果压入栈顶 0x65 lsub 将栈顶两long型数值相减并将结果压入栈顶 0x66 fsub 将栈顶两float型数值相减并将结果压入栈顶 0x67 dsub 将栈顶两double型数值相减并将结果压入栈顶 0x68 imul 将栈顶两int型数值相乘并将结果压入栈顶 0x69 lmul 将栈顶两long型数值相乘并将结果压入栈顶 0x6a fmul 将栈顶两float型数值相乘并将结果压入栈顶 0x6b dmul 将栈顶两double型数值相乘并将结果压入栈顶 0x6c idiv 将栈顶两int型数值相除并将结果压入栈顶 0x6d ldiv 将栈顶两long型数值相除并将结果压入栈顶 0x6e fdiv 将栈顶两float型数值相除并将结果压入栈顶 0x6f ddiv 将栈顶两double型数值相除并将结果压入栈顶 0x70 irem 将栈顶两int型数值作取模运算并将结果压入栈顶 0x71 lrem 将栈顶两long型数值作取模运算并将结果压入栈顶 0x72 frem 将栈顶两float型数值作取模运算并将结果压入栈顶 0x73 drem 将栈顶两double型数值作取模运算并将结果压入栈顶 0x74 ineg 将栈顶int型数值取负并将结果压入栈顶 0x75 lneg 将栈顶long型数值取负并将结果压入栈顶 0x76 fneg 将栈顶float型数值取负并将结果压入栈顶 0x77 dneg 将栈顶double型数值取负并将结果压入栈顶 0x78 ishl 将int型数值左移位指定位数并将结果压入栈顶 0x79 lshl 将long型数值左移位指定位数并将结果压入栈顶 0x7a ishr 将int型数值右（符号）移位指定位数并将结果压入栈顶 0x7b lshr 将long型数值右（符号）移位指定位数并将结果压入栈顶 0x7c iushr 将int型数值右（无符号）移位指定位数并将结果压入栈顶 0x7d lushr 将long型数值右（无符号）移位指定位数并将结果压入栈顶 0x7e iand 将栈顶两int型数值作“按位与”并将结果压入栈顶 0x7f land 将栈顶两long型数值作“按位与”并将结果压入栈顶 0x80 ior 将栈顶两int型数值作“按位或”并将结果压入栈顶 0x81 lor 将栈顶两long型数值作“按位或”并将结果压入栈顶 0x82 ixor 将栈顶两int型数值作“按位异或”并将结果压入栈顶 0x83 lxor 将栈顶两long型数值作“按位异或”并将结果压入栈顶 0x84 iinc 将指定位置的int型变量增加指定值（i++, i–, i+&#x3D;2） 0x85 i2l 将栈顶int型数值强制转换成long型数值并将结果压入栈顶 0x86 i2f 将栈顶int型数值强制转换成float型数值并将结果压入栈顶 0x87 i2d 将栈顶int型数值强制转换成double型数值并将结果压入栈顶 0x88 l2i 将栈顶long型数值强制转换成int型数值并将结果压入栈顶 0x89 l2f 将栈顶long型数值强制转换成float型数值并将结果压入栈顶 0x8a l2d 将栈顶long型数值强制转换成double型数值并将结果压入栈顶 0x8b f2i 将栈顶float型数值强制转换成int型数值并将结果压入栈顶 0x8c f2l 将栈顶float型数值强制转换成long型数值并将结果压入栈顶 0x8d f2d 将栈顶float型数值强制转换成double型数值并将结果压入栈顶 0x8e d2i 将栈顶double型数值强制转换成int型数值并将结果压入栈顶 0x8f d2l 将栈顶double型数值强制转换成long型数值并将结果压入栈顶 0x90 d2f 将栈顶double型数值强制转换成float型数值并将结果压入栈顶 0x91 i2b 将栈顶int型数值强制转换成byte型数值并将结果压入栈顶 0x92 i2c 将栈顶int型数值强制转换成char型数值并将结果压入栈顶 0x93 i2s 将栈顶int型数值强制转换成short型数值并将结果压入栈顶 0x94 lcmp 比较栈顶两long型数值大小，并将结果（1，0，-1）压入栈顶 0x95 fcmpl 比较栈顶两float型数值大小，并将结果（1，0，-1）压入栈顶；当其中一 个数值为NaN时，将-1压入栈顶 0x96 fcmpg 比较栈顶两float型数值大小，并将结果（1，0，-1）压入栈顶；当其中一 个数值为NaN时，将1压入栈顶 0x97 dcmpl 比较栈顶两double型数值大小，并将结果（1，0，-1）压入栈顶；当其中 一个数值为NaN时，将-1压入栈顶 0x98 dcmpg 比较栈顶两double型数值大小，并将结果（1，0，-1）压入栈顶；当其中 一个数值为NaN时，将1压入栈顶 0x99 ifeq 当栈顶int型数值等于0时跳转 0x9a ifne 当栈顶int型数值不等于0时跳转 0x9b iflt 当栈顶int型数值小于0时跳转 0x9c ifge 当栈顶int型数值大于等于0时跳转 0x9d ifgt 当栈顶int型数值大于0时跳转 0x9e ifle 当栈顶int型数值小于等于0时跳转 0x9f if_icmpeq 比较栈顶两int型数值大小，当结果等于0时跳转 0xa0 if_icmpne 比较栈顶两int型数值大小，当结果不等于0时跳转 0xa1 if_icmplt 比较栈顶两int型数值大小，当结果小于0时跳转 0xa2 if_icmpge 比较栈顶两int型数值大小，当结果大于等于0时跳转 0xa3 if_icmpgt 比较栈顶两int型数值大小，当结果大于0时跳转 0xa4 if_icmple 比较栈顶两int型数值大小，当结果小于等于0时跳转 0xa5 if_acmpeq 比较栈顶两引用型数值，当结果相等时跳转 0xa6 if_acmpne 比较栈顶两引用型数值，当结果不相等时跳转 0xa7 goto 无条件跳转 0xa8 jsr 跳转至指定16位offset位置，并将jsr下一条指令地址压入栈顶 0xa9 ret 返回至本地变量指定的index的指令位置（一般与jsr, jsr_w联合使用） 0xaa tableswitch 用于switch条件跳转，case值连续（可变长度指令） 0xab lookupswitch 用于switch条件跳转，case值不连续（可变长度指令） 0xac ireturn 从当前方法返回int 0xad lreturn 从当前方法返回long 0xae freturn 从当前方法返回float 0xaf dreturn 从当前方法返回double 0xb0 areturn 从当前方法返回对象引用 0xb1 return 从当前方法返回void 0xb2 getstatic 获取指定类的静态域，并将其值压入栈顶 0xb3 putstatic 为指定的类的静态域赋值 0xb4 getfield 获取指定类的实例域，并将其值压入栈顶 0xb5 putfield 为指定的类的实例域赋值 0xb6 invokevirtual 调用实例方法 0xb7 invokespecial 调用超类构造方法，实例初始化方法，私有方法 0xb8 invokestatic 调用静态方法 0xb9 invokeinterface 调用接口方法 0xba – 0xbb new 创建一个对象，并将其引用值压入栈顶 0xbc newarray 创建一个指定原始类型（如int, float, char…）的数组，并将其引用值压 入栈顶 0xbd anewarray 创建一个引用型（如类，接口，数组）的数组，并将其引用值压入栈顶 0xbe arraylength 获得数组的长度值并压入栈顶 0xbf athrow 将栈顶的异常抛出 0xc0 checkcast 检验类型转换，检验未通过将抛出ClassCastException 0xc1 instanceof 检验对象是否是指定的类的实例，如果是将1压入栈顶，否则将0压入栈顶 0xc2 monitorenter 获得对象的锁，用于同步方法或同步块 0xc3 monitorexit 释放对象的锁，用于同步方法或同步块 0xc4 wide &lt;待补充&gt; 0xc5 multianewarray 创建指定类型和指定维度的多维数组（执行该指令时，操作栈中必 须包含各维度的长度值），并将其引用值压入栈顶 0xc6 ifnull 为null时跳转 0xc7 ifnonnull 不为null时跳转 0xc8 goto_w 无条件跳转（宽索引） 0xc9 jsr_w 跳转至指定32位offset位置，并将jsr_w下一条指令地址压入栈顶"},{"title":"Java事务失效","path":"/wiki/Java/Java随笔/Java事务失效的几种情况.html","content":"Java 事务失效的几种情况。 一、Spring 声明式事务失效的几种情况Spring 的声明式事务非常的好用，但是使用不当的话事务会失效，对于生产环境中是非常严重的问题。 如果对 AOP 熟悉的 coder 可能这个问题非常简单，如果不了解也可以凭经验解决。下面总结一些情况。 权限修饰符和 final 的情况不用说了，如果使用 IDE 的话基本上都会提示错误。 1. 自行 try-catch，吞掉异常123456789@Override@Transactional(rollbackFor = Exception.class)public void saveBatch(List&lt;User&gt; list) &#123; try&#123; saveBatch(list); &#125; catch (Exception e) &#123; log.error(&quot;保存失败：&#123;&#125;&quot;, e.getMessage()); &#125;&#125; 如果是这种情况，虽然添加了事务，那么也不会生效。解决的办法就是在 catch 中抛出异常，Spring 事务回滚默认是捕获 RuntimeException 和 Error，当然 Spring 也提供了 rollbackFor 属性捕获其它异常，开发中最好指定异常。如下代码： 12345678910@Override@Transactional(rollbackFor = Exception.class)public void saveBatch(List&lt;User&gt; list) &#123; try&#123; saveBatch(list); &#125; catch (Exception e) &#123; log.error(&quot;保存失败：&#123;&#125;&quot;, e.getMessage()); throw new RuntimeException(&quot;保存失败&quot;); &#125;&#125; 2. 同一服务类的方法相互调用不论是事务方法调用事务方法，还是非事务方法调用事务方法，一般使用 声明式事务 失效的情况以此类居多。 1234567891011@Overridepublic void importExcel(List&lt;User&gt; list) &#123; // do something parser saveBatch(list);&#125;@Override@Transactional(propagation = Propagation.NESTED)public void saveBatch(List&lt;User&gt; list) &#123; // do something&#125; 解决办法有下面几种： 使用 Spring 提供的 AopContext.currentProxy() （简单方便）； 将其中的一个方法移至到另一个 xxxService 中，调用时使用 @Autowired 注入调用这是没问题的（还记得开头说的 AOP？）。因为在同一个 Service 中调用方法就不是 Spring 代理的对象了，所以事务也就不会生效了（@Transactional 事务是 Spring 管理的）； 不使用 Spring 的事务管理，自己编写工具管理事务。 这里说说第一种，浪子也是第一次使用，其它两种方法基本上使用过 Spring Web 的 coder 都会。 暴露 Spring 代理对象，需要开启 业务调用 12345678910111213141516171819@SpringBootApplication// 暴露出 Spring 代理对象给业务使用，默认为 false@EnableAspectJAutoProxy(exposeProxy = true)public class Application &#123;...&#125;// 业务调用@Overridepublic void importExcel(List&lt;User&gt; list) &#123; // do something parser // 拿到代理对象 调用相关方法 xxxService currentProxy = (xxxService) AopContext.currentProxy(); currentProxy.saveBatch(list);&#125;@Override@Transactional(rollbackFor = Exception.class)public void saveBatch(List&lt;User&gt; list) &#123; userMapper.saveBatch(list);&#125; 3. 嵌套调用事务嵌套调用时，有时候我们希望这种场景：里面的事务方法如果发生异常回滚，但我不希望外面的回滚： 12345678910111213@Override@Transactional(rollbackFor = Exception.class)public void importExcel(List&lt;User&gt; list) &#123; // do something parser updateSome(user); saveBatch(list);&#125;@Override@Transactional(propagation = Propagation.NESTED)public void saveBatch(List&lt;User&gt; list) &#123; // do something&#125; 上面的例子中，当 saveBatch 发生异常时，我希望它回滚，但是我不希望之前的 updateSome 回滚。但是事实确实都回滚了。原因就是如果下面的 saveBatch 发生异常时会向上抛，以至于外层也发生了异常，所以解决办法也很简单，直接 try-catch。 1234567891011121314151617@Override@Transactional(rollbackFor = Exception.class)public void importExcel(List&lt;User&gt; list) &#123; // do something parser updateSome(user); try &#123; saveBatch(list); &#125; catch (Exception e) &#123; // TODO: handle exception &#125;&#125;@Override@Transactional(propagation = Propagation.NESTED)public void saveBatch(List&lt;User&gt; list) &#123; // do something&#125; 二、事务优化使用事务时最好指定回滚异常，设置事务传播属性；尽量避免大事务连接，可以考虑使用上面的解决办法把事务方法抽离出来，进行内部调用。 本文参考：https://blog.csdn.net/hanjiaqian/article/details/120501741。"},{"title":"Java单元测试","path":"/wiki/Java/Java随笔/Java单元测试实践.html","content":"对于开发来说，单元测试是非常重要的。本篇文章就来记录 Java 中一个较好的单元测试开发实践。 一个好的单元测试尽量实现脱离数据库，减少其它不需要启动的组件和依赖。一般而言我们都会在测试的时候连接数据库，这样的话启动时会启动整个项目（测试类使用 @SpringBootTest）。如果这样的话对于项目的启动和测试时所花费的时间那是比较长的，尤其是微服务，那测试启动差不多何以喝一杯 coffee 了。 Mock数据的优点 可以很简单的虚拟出一个复杂对象（比如虚拟出一个接口的实现类）； 可以配置 mock 对象的行为； 可以使测试用例只注重测试流程与结果； 减少外部类、系统和依赖给单元测试带来的耦合。 Mockito采用 Mock 框架，我们可以对已存在的接口测试，只注重代码的 流程与结果，从而实现测试目的。 Mockito 是 SpringBoot 自带的一个单元测试工具，可以对数据进行模拟。注意： 本文的代码示例均为为 SpringBoot 2.5.x+ 版本。 MockitoTest.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.mockito.Mock;import org.mockito.Mockito;import org.mockito.MockitoAnnotations;import org.mockito.quality.Strictness;import org.springframework.util.Assert;import java.util.Objects;public class MockitoTest &#123; /** * 注意：如果使用 @MockBean 必须与 RunWith 一同使用，否则此 mock 对象无法获取 */ @Mock UserService userService; AutoCloseable autoCloseable; /** * 每次执行测试类之前都执行此方法 * @BeforeAll 在运行测试类时只执行一次 */ @BeforeEach public void openMock() &#123; // 开启 mock 功能（Spring Boot2.5 的写法） autoCloseable = MockitoAnnotations.openMocks(this); // 设置 Mockito 推荐的严格检查配置 Mockito.mockitoSession().startMocking().setStrictness(Strictness.STRICT_STUBS); &#125; /** * 每次执行测试类之后都执行此方法 * @AfterAll 在运行完测试类后只执行一次 */ @AfterEach public void closeMock() &#123; try &#123; autoCloseable.close(); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * test: Mockito example */ @Test public void testMockitoWithReturn() &#123; User user = new User(); user.setId(&quot;10&quot;); // 当你调用 when() 括号里的表达式的时候，会返回后面的 thenReturn() 中的值 // 除此之外，还可以模拟抛出异常，指定返回的对象值 Mockito.when(userService.insert(user)).thenReturn(10); // 调用获取 mock 中设置的 thenReturn 值 int byId = userService.insert(user); // 进行断言测试 Assert.isTrue(Objects.equals(10, byId), &quot;id must is 10&quot;); &#125; /** * 返回异常 */ @Test public void testMockitoWithException() &#123; User user = new User(); user.setId(&quot;10&quot;); // 当你调用 when() 括号里的表达式的时候，会返回后面的 thenThrow() 抛出的异常 Mockito.when(userService.insert(user)).thenThrow(new ArrayIndexOutOfBoundsException()); // 调用获取 mock 中设置的 thenThrow 异常（所以就不断言了） int byId = userService.insert(user); // 调用这个就会正常执行 int newUser = userService.insert(new User()); Assert.notNull(newUser, &quot;newUser must is not null&quot;); &#125; /** * 返回自定义数据 */ @Test public void testMockitoWithCustomer() &#123; ExPass exPass = new ExPass(); exPass.setId(&quot;10&quot;); // thenAnswer() 与 then() 是一样的 Mockito.when(exPassMapper.insert(exPass)).thenAnswer((invocation) -&gt; &#123; return new IllegalArgumentException(); &#125;); int byId = exPassMapper.insert(exPass); Assert.isTrue(Objects.equals(1, byId), &quot;save not is false&quot;); &#125;&#125; 在 SpringBoot2.5.x 中的 mockito 的版本是 3.9.0。除了上面测试的方法外还有一个 thenCallRealMethod() 方法，它的使用也非常简单，有兴趣的可以自己尝试一下~"},{"title":"volatile 关键字","path":"/wiki/Java/Java随笔/volatile.html","content":"本篇文章需要掌握JMM（Java Memory Model） 介绍volatile 在多线程环境下可以保证共享数据的可见性，但不保证数据操作的原子性（线程不安全）。要想保证线程安全，还是需要锁机制或者使用原子类（原子类内部已使用 volatile 保证了可见性）。 为了提高 CPU 的运行效率，JVM 会对一些代码进行重新排序。volatile 修饰变量可以实现禁止指令重排序，修正重排序带来的并发安全问题。 20220727094203 happens-before规则我们知道为了提高处理速度，JVM 会进行指令重排序优化，在并发编程下可能会带来一些安全隐患，比如 重排序导致的多个线程之间的不可见性。如果让程序员去了解这些底层的实现以及具体的规则，那么我们的负担就太重了，会影响并发编程的效率。从 JDK5 开始，提出了 happens-before 概念：如果一个操作的执行结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。简单来说，就是前一个操作的结果可以被后续的操作获取。 happens-before 规则可以理解为对 JVM 的约束规则。它在编译优化的同时，依然保证了多线程的可见性。 happens-before的几个规则 程序顺序原则：同一个线程中前面所有的写操作都对后续操作可见（一个线程内保证语义的串行性）。 锁规则：在线程1解锁之前的所有写操作都对后续加锁的线程可见（unlock必然发生在随后的加锁lock前）。 volatile 规则：如果线程1写入 volatile 变量v，接着线程2读取了这个值，线程1写入 v 之前的写操作都对线程2可见（volatile 变量的写先发生于读，保证了 volatile 变量的可见性）。 传递性：如果 A happens-before B，B happens-before C，那么 A happens-before C。 start() 规则：如果在线程 A 中启动线程 B，那么在线程 B 启动之前，线程 A 中对共享变量的修改都对线程 B 可见。需要注意的是，在线程 B 启动之后，线程 A 再对变量的修改线程 B 未必可见。线程的 start() 方法先于他的每一个动作。 join() 规则：对于线程 A 写入的所有变量，如果任一线程调用 A.join() 或者 A.isAlive() 成功返回后，那么 A 写入的变量都对该线程可见。线程的所有操作先于线程的终结。 线程的中断先于被中断线程的代码。 对象的构造函数执行、结束先于 finalize() 方法。 这些原则都是保证指令重排不会破环原有的语义结构。例如第二条锁原则，unlock必然发生在随后的lock前。如果对一个锁解锁后，再加锁，那么加锁的动作绝对不能重排在解锁前。 volatile使用场景适合纯赋值操作，不适合类似 a++ 操作。 12345678910111213141516171819202122232425262728293031323334353637public class VolatileTest implements Runnable &#123; // 使用 public 是为了测试获取到结果值 public volatile boolean flag = false; public AtomicInteger atomicInteger = new AtomicInteger(0); @Override public void run() &#123; for (int i = 0; i &lt; 10000; i++) &#123; // 修改 flag 的值 switchFlag(); // +1 atomicInteger.incrementAndGet(); &#125; &#125; private void switchFlag() &#123; // 纯赋值操作符合预期 flag = true; // 不符合预期，可能为 true // flag = !flag; &#125;&#125;class Test03 &#123; public static void main(String[] args) throws InterruptedException &#123; VolatileTest v = new VolatileTest(); Thread t1 = new Thread(v); Thread t2 = new Thread(v); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(v.flag); System.out.println(v.atomicInteger.get()); &#125;&#125; volatile 可以适合做多线程中的纯赋值操作，如果一个共享变量自始至终只被各个线程赋值，而没有其它的操作，那么就可以用 volatile 来代替 synchronized 或者代替原子变量，因为赋值自身是有原子性的，而 volatile 又保证了可见性，所以 足以保证线程安全。 volatile与synchronized volatile 只能修饰 实例变量 和 类变量，而 synchronized 可以修饰方法以及代码块。 volatile 保证数据的可见性，但是不保证原子性（多线程进行写操作，不保证线程安全）；而 synchronized 是一种排它（互斥）的机制。 volatile 用于禁止指令重排序，可以解决单例双重检查对象初始化代码执行乱序问题。 volatile 可以看作是轻量版的 synchronized，volatile 不保证原子性，但是如果对一个共享变量进行直接赋值而没有其它的操作，那么就可以用 volatile 来代替 synchronized，因为赋值本身是有原子性的，而 volatile 又保证了可见性，所以就可以保证线程安全了。 总结 volatile 修饰符适用于以下场景，某个属性被多个线程共享，其中一个修改了此属性，其它线程可以立即得到修改后的值；或者作为触发器，实现轻量级同步。 volatile 属性的读写操作都是无锁的，它不能代替 synchronized，因为它没有提供原子性和互斥性。因为无锁，不需要花费时间在获取锁和释放锁，所以它是低成本的。 volatile 只能作用于属性，修饰的属性不会被 compilers 做指令重排序。 volatile 提供了可见性，任一个线程修改值后将立即对其它线程可见，volatile 属性不会被线程缓存，始终从主存中读取。 volatile 提供了 happens-before，保证其修饰的变量在写入 happens-before 后其它线程后续对该变量的读操作。 volatile 可以使得 long 和 double 的赋值是原子的。 volatile 可以在单例双重检查中实现可见性和禁止指令重排序，从而保证安全性。"},{"title":"Maven","path":"/wiki/Java/Java随笔/Maven.html","content":"Maven打包打包之前推荐先清理（clean）再打包（package）。jar 包比较简单，SpringBoot 默认打的就是 jar 包。这里说一下 war 包的打包方式方式。 修改打包方式，去除内嵌的 tomcat 依赖 pom.xml123456&lt;packaging&gt;war&lt;/packaging&gt;...&lt;!-- 去除内嵌的 tomcat 依赖 --&gt;&lt;scope&gt;provided&lt;/scope&gt; 如果整合的是 jsp，那么使用打包的插件时，打包插件必须是 1.4.2 的版本，另外，在pom文件中加入以下内容，指定 jsp 文件的打包位置： pom.xml12345678910111213141516171819202122232425&lt;resources&gt; &lt;!-- 打包时将 jsp 文件拷贝到 META-INF 目录下 --&gt; &lt;resource&gt; &lt;!-- 指定 resources 插件处理那个目录下的资源文件 --&gt; &lt;directory&gt;src/main/webapp&lt;/directory&gt; &lt;!-- 指定必须要放在此目录下才能被访问到 --&gt; &lt;targetPath&gt;META-INF/resources&lt;/targetPath&gt; &lt;includes&gt; &lt;include&gt;**/**&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/**&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.java&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt;&lt;/resources&gt; 在插件中指定入口类： 12345&lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;jvmArgument&gt;-Dfile.encoding=UTF-8&lt;/jvmArgument&gt; &lt;mainClass&gt;com.XXX.Application.class&lt;/mainClass&gt;&lt;/configuration&gt; 在启动类中，继承 SpringBootServletInitiallizer 类，重写 configure() 方法进行配置: 123456public class xxxApplication extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123; return builder.sources(xxxApplication.class); &#125;&#125; 注意： 打成的 war 包使用外部 Tomcat 部署时，项目配置文件中配置的端口和项目名称会失效。后台方式启动 jar 包：nohup java -jar jar包名称 &amp;"},{"title":"前端相关","path":"/wiki/Java/Java随笔/前端相关.html","content":"文件上传表单提交必须是 post 方式，encType 必须为 multiPart/form-data；"},{"title":"程序的锁","path":"/wiki/Java/Java随笔/认识程序中的锁.html","content":"认识程序中的 “锁”。 锁 锁分类 悲观锁 乐观锁 死锁 产生死锁的四个必要条件 死锁的解除 锁锁分类悲观锁使用系统层面的加锁方式 乐观锁数据库层面的锁，通过增加 version 字段以及使用数据库的 事务 的方式加锁 可以解决超卖等问题，一般使用乐观锁，乐观锁的性能相较于悲观锁要好得多，这样在不影响用户的体验下保证了应用的性能。 死锁原因：死锁是由于两个或以上的线程互相持有对方需要的资源，导致这些线程处于等待状态，无法执行。 产生死锁的四个必要条件1.互斥性：线程对资源的占有是排他性的，一个资源只能被一个线程占有，直到释放。 2.请求和保持条件：一个线程对请求被占有资源发生阻塞时，对已经获得的资源不释放。 3.不剥夺：一个线程在释放资源之前，其他的线程无法剥夺占用。 4.循环等待：发生死锁时，线程进入死循环，永久阻塞。 死锁的解除1.抢占资源，从一个或多个进程中抢占足够数量的资源，分配给死锁进程，以解除死锁状态。 2.终止（或撤销）进程，终止（或撤销）系统中的一个或多个死锁进程，直至打破循环环路，使系统从死锁状态解脱出来."},{"title":"业务常用SQL","path":"/wiki/Java/Java随笔/微信公众号模板消息测试推送.html","content":"微信公众号分为订阅号和服务号，订阅号不支持模板消息，但是每天可以群发消息；而服务号一个月可以群发四次消息。认证过的服务号是可以使用模板消息的，认证需要 money，而订阅号就需要有内测的权限，微信对订阅号正在启用模板消息灰度测试，所以很多是不能自己测试的。但是可以使用测试号。不过值得注意的是，测试号只能用于测试，不能用于向正是号推送消息等。 功能实现 首先申请测试号，测试号申请地址 申请登录之后，可以看到已经生成的 appID 和 appsecret，这两个是获取公众号的 accessToken 信息必不可少的。 对于公众号模板消息测试而言，接口配置信息 和 JS接口安全域名 可以略过不用配置。 测试号二维码需要关注，接收模板消息必须关注。模板消息接口需要按照要求增加一个模板。这样，准备工作就做好了，接下来可以进行代码了。 对应请求信息的 url 可以在 体验接口权限表 中点击对应的链接进行查看。 123456789101112// 请求获取 accessTokenprivate static String tokenApi = &quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=&quot; + grant_type + &quot;&amp;appid=&quot; + appid + &quot;&amp;secret=&quot; + secret;// 请求获取用户列表的 url GET请求:https://api.weixin.qq.com/cgi-bin/user/get?access_token=ACCESS_TOKEN&amp;next_openid=NEXT_OPENIDprivate static String userListUrl = &quot;https://api.weixin.qq.com/cgi-bin/user/get?access_token=&quot;;// 请求获取用户基本信息(UnionID机制) GET请求:https://api.weixin.qq.com/cgi-bin/user/info?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CNprivate static String userInfoUrl = &quot;https://api.weixin.qq.com/cgi-bin/user/info?access_token=&quot;;// 发送模板信息 url POST请求:https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=ACCESS_TOKENprivate static String sendUrl = &quot;https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=&quot;; 问题解决 出现 &quot;errcode&quot;:40003,&quot;errmsg&quot;:&quot;invalid openid rid: 61b87426-7ecce312-0478a848&quot; 的错误：解决方案： 设置发送对象的键为 touser，不要为 toUser 或者 openid示例如下： 12345paramData.put(&quot;touser&quot;, openid);paramData.put(&quot;template_id&quot;, templateId);paramData.put(&quot;url&quot;, &quot;xxx/login&quot;);// data 为数据模板的 mapparamData.put(&quot;data&quot;, data);"},{"title":"MyBatis、MyBatis Plus（MP）","path":"/wiki/Java/ORM/MyBatis.html","content":"一、MyBatis二、MyBatis Plus1. 使用 Wrappers.xxxquery() 查询某个字段有时候，我们只需要查询一张表中的一个或几个字段（同一张表），又不想写 SQL 的情况下，可以使用 queryWapper.select() 方式，举个栗子： 1234567891011121314public List&lt;Integer&gt; listManageLevel() &#123; LambdaQueryWrapper&lt;User&gt; query = Wrappers.lambdaQuery(); // 使用 select 方式只查询 age 字段 query.select(User::getAge).groupBy(User::getAge); // 如果使用 selectList() 返回的是对象集合 List&lt;User&gt; users = userMapper.selectList(query); // 也可以使用下面的方式，返回一个 Object 集合，注意修改返回值 // List&lt;Object&gt; ages = sasacMapper.selectObjs(query); List&lt;Integer&gt; ages = users.stream() .map(User::getAge) .collect(Collectors.toList()); return ages;&#125; 注意，上面的查询返回的是一个对象集合，还需要使用 map 映射取出字段。当然，你也可以使用注释掉的代码，返回一个 Object 集合，对于单字段来说是比较好的选择。"},{"title":"SpringBoot","path":"/wiki/Java/SpringFramework/SpringBoot.html","content":"SpringBoot 用起来的真的简单方便，不需要太多繁琐的配置，实现开箱即用，对于 Java 开发人员来说是莫大的福音。这里整理一下相关的内容。 一、SpringBoot 项目构建 二、SpringBoot整合第三方库 1. springdoc 或者 smart-doc 2. MP 3. locback 日志自定义存放文件夹 三、SpringBoot 配置文件 一、SpringBoot 项目构建除了 Spring 官网的模板，也可以使用阿里云的构建模板：https://start.aliyun.com/，该模板除了速度占优势，也有更多的阿里系常用依赖。 二、SpringBoot整合第三方库1. springdoc 或者 smart-docspringdoc 比 swagger 的注解属性更加清晰明了。 smart-doc 只需要写好标准的 JavaDoc，并按照 官网说明 编写即可，不需要其它的注解等。 2. MP12345678# 打印SQL语句 以下配置二选一mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpllogging: level: com.xxx.mapper: debug 3. locback 日志自定义存放文件夹logback 是 SpringBoot 默认使用的日志框架。在使用 logback 框架的时候，如果需要动态的去指定日志存放目录，可以重写 Spring 预留的父类中 PropertyDefinerBase 的方法，然后在 logback.xml 中写入该配置类的完全限定名称即可。 config/LogHomeConfig.java123456789101112// 继承 PropertyDefinerBase 类，重写其中的 getPropertyValue 方法public class LogHomeConfig extends PropertyDefinerBase &#123; @Override public String getPropertyValue() &#123; // 获取用户名 String username = System.getProperty(&quot;user.name&quot;); // 获取操作系统 String os = System.getProperty(&quot;os.name&quot;); // 路径常量可以放到常量类维护，这里说明问题即可（目录放在jar包的同级目录） return os.toLowerCase().contains(&quot;window&quot;) ? &quot;./logs&quot; : &quot;/home/&quot; + username + &quot;/logs&quot;; &#125;&#125; logback.xml123456&lt;configuration&gt; &lt;!-- 日志存放路径，这里使用了 define 标签，class 定义为重写了 PropertyDefinerBase 类方法的配置类 --&gt; &lt;!-- &lt;property name=&quot;log.path&quot; define=&quot;&quot; value=&quot;/home/user/market/logs&quot;&gt; --&gt; &lt;define name=&quot;log.path&quot; class=&quot;com.example.common.logs.LogHomeConfig&quot;/&gt; ...&lt;/configuration&gt; 这样，就可以根据不同的操作系统存储在不同的路径。 关于 slf4 和 Java 中的其它日志框架的关系，引用 Rust 语言圣经 里的一段话，浪子觉得写的非常好： slf4j 是 Java 的日志门面库，日志门面不是说排场很大的意思，而是指相应的日志 API 已成为事实上的标准，会被其它日志框架所使用。通过这种统一的门面，开发者就可以不必再拘泥于日志框架的选择，未来大不了再换一个日志框架就是. 三、SpringBoot 配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455server: port: portspring: application: # 应用名称 name: application-name # 数据源 datasource: # hikari 连接池 type: com.zaxxer.hikari.HikariDataSource # PostgreSQL 连接，默认端口：5432 driver-class-name: org.postgresql.Driver url: jdbc:postgresql://localhost:5432/postgres?serverTimezone=Asia/Shanghai # sqlserver 默认端口号为：1433 # url: jdbc:microsoft:sqlserver://localhost:1433;DatabaseName=dbname # driver-class-name: com.microsoft.jdbc.sqlserver.SQLServerDriver # mysql 默认端口号为：3306 # url: jdbc:mysql://localhost:3306/test?username=root&amp;password=&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;mysqlEncoding=utf-8&amp;serverTimezone=Asia/Shanghai # driver-class-name: com.mysql.jdbc.Driver # oracle 默认端口号为：1521 # url: jdbc:oracle:thin:@localhost:1521:orcl # driver-class-name: oracle.jdbc.driver.OracleDriver hikari: username: username password: password # 最大连接池数量 maximum-pool-size: 20 # 配置一个连接在池中最大生存的时间，单位是毫秒 max-lifetime: 60000 # 存活时间 keepalive-time: 6000 jpa: show-sql: true hibernate: generate_statistics: true naming: # 相当于 org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy（3.0删除） # 驼峰与下划线映射 physical-strategy: org.hibernate.boot.model.naming.CamelCaseToUnderscoresNamingStrategy # jpa 属性配置 properties: hibernate: # 格式化控制台打印 SQL format_sql: true# jdbc:# batch_size: 50# # 检测批处理是否打开 它可能不生效# generate_statistics: true# Spring 内置日志级别logging: level: # 设置某个包的日志打印级别为 debug com.leaf.system.repository: debug"},{"title":"SpringSecurity","path":"/wiki/Java/SpringFramework/SpringSecurity.html","content":"Spring Security 是一个功能强大且高度可定制的身份验证和访问控制框架，专注于为 Java 应用程序提供身份验证和授权。 一、官网学习 1. 思考 二、登录认证 1. 一些说明 AuthenticationManager ProviderManager AuthencationProvider关系 WebSecurityConfigurerAdapter（最新版本标为弃用） UserDetails UserDetailsService用来修改默认认证的数据源信息 Authentication 2. 配置AuthenticationManager的两种方式 3. 密码加密 4. RememberMe 5. 会话管理(SessionManagementFilter) 6. 跨域问题 7. 异常处理 7.1 认证异常 7.2 授权异常 7.3 自定义异常处理配置 8. CSRF（Cross-site request forgery） 二、授权 2.1 两种权限管理策略 1. 基于URL权限管理 2. 基于方法的权限管理 2.2 动态权限修改 2.3 RBAC(Role-Based Access Control) 一、官网学习官方文档https://docs.spring.io/spring-security/reference/servlet/authentication/architecture.html Spring Security是基于一系列的 Filter 来完成的。核心分为认证、授权。 新版本的 Security 配置不需要继承 WebSecurityConfigurerAdapter 类，其配置写法主要是以注册 Bean 的方式为主，具体的使用可以阅读 官方文档 1. 思考 为什么在引入 Spring Security 之后没有任何配置所有的请求就要认证呢？SpringBootWebSecurityConfiguration，自动配置类 在项目中明明没有登录界面，登录界面怎么来的呢？访问接口时，在引入 spring security 之后会先经过一系列过滤器。在请求到达 FilterSecurityInterceptor 时，发现请求并未认证，请求拦截下来，并抛出 AccessDeniedException 异常。抛出的异常会被 ExceptionTranslationFilter 捕获，这个 Filter 中会调用 LoginUrlAuthenticationEntryPoint#commence 方法给客户端返回 302，要求客户端进行重定向到 &#x2F;login 页面。客户端发送 &#x2F;login 请求。&#x2F;login 请求会再次被拦截器中 DefaultLoginPageGeneratingFilter 拦截到，并在拦截器中返回生成登录页面。 为什么使用 user 和控制台打印的密码能登录，登录时验证数据源存在哪里呢？Spring Security中有一个基于内存（InMemoryUserDetailsManager）的默认用户实现。 二、登录认证登录 调用 ProviderManager 的方法进行认证，如果认证成功生成 jwt，把用户信息存入 redis。 自定义 UserDetailsService，查询数据库 校验 定义 jwt 认证过滤器，获取 token，解析 token 中的 userid，查询 redis 中是否存在相应的 userid 并获取用户信息，最后存入 SecurityContextHolder。 1. 一些说明AuthenticationManager ProviderManager AuthencationProvider关系AuthenticationManager 有全局的和局部的，无论哪种，都是通过 ProviderManager 进行实现。每一个 ProviderManager 中都代理一个 AuthenticationProvider列表，列表中每一个实现代表一种身份认证方式。认证时底层数据源调用 UserDetailsService 来实现。 WebSecurityConfigurerAdapter（最新版本标为弃用）WebSecurityConfigurerAdapter 是 Spring Security 为我们提供的扩展类，方便我们重写默认配置，实现定制。 Spring Security(5.7) 中的WebSecurityConfigurerAdapter 标记为弃用状态。新版的改变与使用参考 5.7新版配置，不同之处在于改变了写法，新版主要以配置 Bean 的方式使用。 UserDetails提供核心用户信息，UserDetailsService#loadByUsername() 返回的就是一个 UserDetails 对象。 UserDetailsService用来修改默认认证的数据源信息UserDetailsService 接口下有许多的实现。同时，此接口也方便了我们以后的自定义数据源的扩展。里面定义了一个根据用户名查询用户信息的方法。 Authentication封装的用户信息，包括用户名和密码。 2. 配置AuthenticationManager的两种方式 继承 WebSecurityConfigurerAdapter，springboot 对 security 默认配置中 在工厂默认创建 AuthenticationManager。 12345// 默认配置会自动发现创建的 UserDetailService 的 Bean@Autowiredpublic void initialize(AuthenticationManagerBuilder builder, DataSource datasource) &#123; System.out.println(&quot;spring boot 自动配置的全局 AuthenticationManager&quot;);&#125; 自定义全局认证数据源 12345678910// 自定义配置 AuthenticationManager@Overridepublic void configure(AuthenticationManagerBuilder builder) &#123; builder.userDetailsService(customerUserDetailsService())&#125;// 暴露本地的 AuthenticationManager 自定义实例@Overridepublic AuthenticationManager authenticationManagerBean() throws Exception &#123; return super.authenticationManagerBean();&#125; 小结： 默认自动配置全局 AuthenticationManager 默认找当前项目中是否存在自定义 UserDetailService 实例，如果存在会自动将当前项目的 UserDetailService 实例设置为数据源。 默认自动配置全局 AuthenticationManager 在工厂中使用时直接在代码中注入即可。 一旦通过自定义的方式配置后，会 自动覆盖 默认的实现；并且需要在实现中 指定 自定义的数据源对象 UserDetailsService 实例，并且这个 AuthenticationManager 需要暴露出来（自定义的默认是本地的，不允许其它组件注入）。 3. 密码加密常见加密方案：Hash算法+盐单向自适应函数（占用大量系统资源，每个认证请求都会大大降低应用程序的性能），开发者可以通过bcrypt、PBKDF2、sCrypt以及argon2来体验这种自适应单向函数加密。 密码的认证是由 PasswordEncoder 进行的，他可以根据不同的加密实现不同的认证方式，所以非常的灵活。 自定义密码加密有两种方式，一种是直接指定密码加密的方式（比如Bcrypt），另一种是使用自定义升级的方式。 4. RememberMeRememberMe是一种服务端的行为，并非是把用户名密码保存在Cookie中的信息。传统的登录方式基于Session会话，一旦用户的会话过期，就要再次登录，这样就太过于繁琐。如果有一种机制，会话过期后，还能继续保持认证状态，就会方便很多,RememberMe就是为了解决这一需求而生的。 具体的实现思路就是通过Cookie来记录当前用户身份，用户登录成功之后，会通过一定算法，将用户信息时间戳等进行贾母，加密完成后，通过响应头带回前端存储再Cookie中，当浏览器会话过期之后，如果再次访问网站，会自动将Cookie中的信息发送给服务器，服务器对Cookie中的信息进行校验分析，进而确定出用户的身份，Cookie中所保存的用户信息也是有失效的，例如三天、一周等。 认证成功后写一段信息在Cookie中 5. 会话管理(SessionManagementFilter)会话并发管理：简单来说，就是多个客户端使用同一账户登录。默认情况下，同一账户可以再多少设备上登录并没有限制，我们可以在 Spring Security 中进行配置。 开启会话管理 12345678// 自定义配置@Overridepublic void configure(HttpSecurity http) throw Exception &#123; http... .sessionManagement() // 开启会话管理 // 最大并发会话为 1 .maximumSessions(1);&#125; Spring Security 开启会话管理默认的是挤掉另一个客户端登录；我们可以设置为禁止其它客户端登录（当前用户登录成功，其它客户端无法使用当前的账户登录，除非当前用户注销退出）。集群下的会话管理可以使用 Redis 的Session 共享。 6. 跨域问题 入门：@CrossOrigin该注解由 Spring 框架提供，含有属性：allowCredentials:浏览器是否应当发送凭证信息，如 Cookie。allowHeader:允许访问头origins:允许指定访问的所属域访问，* 表示所有字段。exposeHeaders:哪些响应头可以作为响应的一部分暴露出来。使用通配符无效。maxAge:预检查请求的有效期，有效期内不必再次发送预检请求，默认是100s。methods:允许的请求方法，* 表示所有方法。 进阶：addCrosMapping（Spring MVC 提供） 123456789101112@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/**&quot;) .allowCredentials(false) .allowedHeaders(&quot;*&quot;) .allowedMethods(&quot;*&quot;) .allowedOrigins(&quot;*&quot;) .maxAge(3600); &#125;&#125; CrosFilter（Spring Web提供的跨域处理解决方案） 12345678910111213141516171819202122232425import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.filter.CorsFilter;import java.util.Arrays;@Configurationpublic class WebMvcConfig &#123; FilterRegistrationBean&lt;CorsFilter&gt; corsFilter() &#123; FilterRegistrationBean&lt;CorsFilter&gt; registrationBean = new FilterRegistrationBean&lt;&gt;(); CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.setAllowedHeaders(Arrays.asList(&quot;*&quot;)); corsConfiguration.setAllowedMethods(Arrays.asList(&quot;*&quot;)); corsConfiguration.setAllowedOrigins(Arrays.asList(&quot;*&quot;)); corsConfiguration.setMaxAge(3600L); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(&quot;/**&quot;, corsConfiguration); registrationBean.setFilter(new CorsFilter(source)); registrationBean.setOrder(-1); return registrationBean; &#125;&#125; Spring Security中的跨域解决方案Q： 当项目中使用了Spring Security后，上面的方案有的会失效，有的可以继续使用，这是为什么？A： 通过 @CrossOrigin 注解或者重写 addCorsMappings 方法配置的跨域解决方案，统统失效了（发送的预检请求会被 Spring Security 拦截）；通过 CorsFilter 配置的跨域，有没有失效则要看过滤器的优先级。如果过滤优先级高于 Spring Security 过滤器，即先于 Spring Security 过滤器执行，则 CorsFilter 所配置的跨域处理依然有效；如果优先级低于 Spring Security 过滤器，则 CorsFilter 所配置的跨域处理就会失效。 12345678910111213141516171819202122@Configurationpublic class WebMvcConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests().anyRequest() .authenticated().and() .formLogin().and() // 跨域处理方案 .cors().configurationSource(corsConfigurationSource()).and() .csrf().disable(); &#125; CorsConfigurationSource corsConfigurationSource() &#123; CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.setAllowedHeaders(Arrays.asList(&quot;*&quot;)); corsConfiguration.setAllowedMethods(Arrays.asList(&quot;*&quot;)); corsConfiguration.setAllowedOrigins(Arrays.asList(&quot;*&quot;)); corsConfiguration.setMaxAge(3600L); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(&quot;/**&quot;, corsConfiguration); return source; &#125;&#125; 7. 异常处理7.1 认证异常认证异常涉及的异常类型比较多，AuthenticationException 是所有认证异常的父类。 7.2 授权异常相较于认证异常，权限异常类就要少了很多。在实际项目开发中，如果默认提供的异常无法满足需求，就需要根据实际需求自定义异常类。 7.3 自定义异常处理配置1234567891011121314151617181920212223242526@Configurationpublic class WebMvcConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests().mvcMatchers(&quot;/hello&quot;).hasRole(&quot;ADMIN&quot;) .anyRequest() .authenticated().and() .formLogin().and() .csrf().disable() // 异常处理 .exceptionHandling() // 认证异常 .authenticationEntryPoint((request, response, authException) -&gt; &#123; response.setContentType(MediaType.APPLICATION_JSON_UTF8_VALUE); response.setStatus(HttpStatus.UNAUTHORIZED.value()); response.getWriter().write(&quot;尚未认证，请进行认证操作&quot;); &#125;) // 权限异常 .accessDeniedHandler((request, response, accessDeniedException) -&gt; &#123; response.setContentType(MediaType.APPLICATION_JSON_UTF8_VALUE); response.setStatus(HttpStatus.FORBIDDEN.value()); response.getWriter().write(&quot;无权访问&quot;); &#125;); &#125;&#125; 8. CSRF（Cross-site request forgery）CSRF 即跨站请求伪造，是 web 常见的攻击方式之一。 Spring Security 防止 CSRF 攻击的方式就是通过 csrf_token，前端发起请求的时候需要携带这个 csrf_token，后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问。 CSRF 攻击依靠的是 Cookie 中所携带的认证信息。但是在前后端分离的项目我们的认证信息是基于 Token，而 token 并不存储在 Cookie 中，我们的 token 是设置到请求头中的，所以 CSRF 攻击在前后端分离的项目中就失效了。 二、授权2.1 两种权限管理策略 基于过滤器的权限管理（FilterSecurityInterceptor）主要拦截Http请求，拦截下来后，根据Http请求地址进行权限校验 基于方法的权限管理（MethodSecurityInterceptor）主要是用来处理方法级别的权限问题。当需要调用某一个方法时，基于 AOP 将操作拦截下来，然后判断用户是否具备相关的权限。 1. 基于URL权限管理 antMatchers()：最早出现的，用于任何 HttpMethod 请求列表。 mvcMatchers()：4.x 版本新增的，使用 Spring MVC 的匹配规则。例如，路径 /path，它会匹配 /path，/path/，/path.html 等。如果 Spring MVC 不会处理当前请求，会使用 antMatchers()。 两种方式本质上没有太大区别。mvcMatchers() 指定的话优先使用 MVC 匹配，如果匹配不到，会使用 antMatchers() 匹配。 regexMatchers()；支持正则表达式。 2. 基于方法的权限管理这种方式就是在 controller 层的方法上加上注解，指明需要哪些权限或者具有的角色才能访问对应的资源。 首先，配置类中开启方法权限校验：@EnableGlobalMethodSecurity(prePostEnabled &#x3D; true, SecuredEnable &#x3D; true, jsr250Enabled &#x3D; true)，（这里开启了三种方式，一般只用第一种） 1234567891011121314151617181920212223// 开启配置 启用方法级别的权限认证@Configuration// 开启之后就可以使用 @preAuthorize 也是最常用的注解@EnableGlobalMethodSecurity(prePostEnabled = true)public class SecurityConfig&#123; ...&#125;// 前置校验@preAuthorize(&quot;hasAuthority(&quot;权限名称&quot;)&quot;)// 过滤 filterTarget 必须是数组 集合，不能过滤某个对象@preFilter(filterTarget = &quot;users&quot;)// 后置校验@PostAuthorize()@PostFilter()@Secured(&quot;role1&quot;, &quot;role2&quot;) // 只能判断角色，或者 关系，满足一个即通过请求// 允许所有用户访问@PermitAll()// 拒绝所有访问@DenyAll()// jsr250 提供的注解，和 Secured() 类似@RolesAllowed(&quot;role1&quot;, &quot;role2&quot;) 项目中，一般前四个用的较多，后面几个功能较为单一。 2.2 动态权限修改以上方式都是通过代码实现的，比较难以修改，可以使用动态的权限修改，比如从数据库层面实现，修改字段即可达到修改相应的权限的目的。 实现 FilterInvocationSecurityMetaSource 接口，重写 getAttributes() 方法。 之后再 SecurityConfig 配置类中，使用 http.apply() 方法，覆写里面的配置，setSecurityMetaSource() 改为实现 FilterInvocationSecurityMetaSource 接口的实现类即可。setRejectPublicInvocations() 设为 true&#x2F;false，为 true 时拒绝 公共资源（没有权限管理的公共接口） 的访问。 2.3 RBAC(Role-Based Access Control)RBAC 即基于角色的权限控制。为什么说基于角色呢？ 想像一下，每次添加用户时都单独添加权限的话，那肯定是比较繁琐的。如果我们加入一个“角色”，把常用的一些权限分配给预定义的角色，然后在添加用户的时候直接把“角色”（比如 admin）设置给用户，这个用户就自动拥有对应的权限。这样就比较简单方便。"},{"title":"Spring注解","path":"/wiki/Java/SpringFramework/Spring注解.html","content":"注解的相关说明都扔到这里吧。 Spring 注解 @SpringBootApplication @Component @MapperScan @ControllerAdvice、@RestControllerAdvice @ResponseBody、@RequestBody、@Controller @Async Spring 注解Spring注解总结 Spring注解 @SpringBootApplication@SpringBootApplication 是一个组合注解，包含多个注解； 12345678910// 指定注解的范围@Target// 指定注解什么时候有效@Retention// 自动配置 spring springmvc 相关环境@SpringBootConfiguration// 开启自动配置，自动配置核心注解，自动配置 spring 相关环境，引入第三方技术自动配置其环境，mybatis-springboot、redis-springboot 等等@EnableAutoConfiguration// 组件扫描，默认扫描当前包及子包，根据注解发挥注解作用。@ComponentScan @Component @Repository&#x2F;@Mapper DAO类型 @Service Service类型 @Controller Controller 类型 上面的注解的本质就是 @Component 注解，使用它们可以更加准确的表达一个类型的作用。顺带一提：@Configuration 可以创建多个 Bean 对象，而 @Component 只能创建单个 Bean 对象。 @MapperScan该注解是 Mybatis 提供的，作用是扫描 Dao 层接口，交给 Spring 工厂去创建对象（和在 Dao 接口加 @Mapper 注解效果一样），这个相当于扫描指定的包中所有的文件交给 Spring 管理，不需要在每个类中标识。 @ControllerAdvice、@RestControllerAdvice顾名思义，这两个类都是对 controller 层做增强处理。这两个注解可以用来对 controller 的返回值做统一包装（下面有一个小栗子），也可以和另一个注解 @ExceptionHandler 一起作为全局的系统异常处理（项目常用）。 1234567891011121314151617181920212223242526// @RestControllerAdvice @ControllerAdvice(basePackages = &quot;com.xxx.controller&quot;) // 只对此包中的类进行结果封装public class ResultResponseHandler implements ResponseBodyAdvice &#123; private static final Logger log = LoggerFactory.getLogger(ResultResponseHandler.class); @Override public boolean supports(MethodParameter returnType, Class converterType) &#123; // 过滤不需要封装的结果 if (returnType.getParameterType().isAssignableFrom(ResultResp.class)) &#123; return false; &#125; return true; &#125; /** * 此处处理结果集后响应给客户端 */ @Override public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) &#123; if (body instanceof ResultResp) &#123; return body; &#125; return ResultResp.success(body); &#125;&#125; @ResponseBody、@RequestBody、@Controller这三个注解通常只在 controller 层使用：@RestController = @ResponseBody + @Controller.所以对于目前常见的前后端分离的项目，一般我们直接使用 @RestController 注解即可。 另外我们已经知道，Spring 中使用了 jaskon 作为 json 工具，所以相关的注解底层运作也使用了 jaskon。比如 @ResponseBody、@RequestBody 等。 其中 @ResponseBody 把返回的对象转为 json 格式字符串后响应到客户端；而 @RequestBody 把客户端的 json 字符串参数转为 Java 中的复杂对象。 @AsyncSpring 提供了异步执行的代码的功能,能让我们以多线程的方式执行,但是 Spring 中自带的 @Async 注解执行异步时并没有使用线程池的概念, 如果同时执行多个任务可能会把系统资源耗尽的情况。对此，SpingBoot 做好了优化，默认使用线程池执行任务。 只需要在 SpringBoot 项目中需要异步执行的代码上加上注解 @Async,同时在启动类上加上 @EnableAsync 即可，如下： 1234567@SpringBootApplication@EnableAsyncpublic class AnsyApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(AnsyApplication.class, args); &#125;&#125; 12345@Asyncpublic void test() throws InterruptedException &#123; Thread.sleep(1000); System.out.println(&quot;子线程执行了&quot;);&#125; 测试代码 12345678910111213@RunWith(SpringRunner.class)@SpringBootTest(classes = AnsyApplication.class)public class TestDemo &#123; @Autowired AnsyService service; @Test public void testDemo() throws Exception&#123; service.test(); System.out.println(&quot;主线程执行了&quot;); //阻塞当前的主线程，等待异步执行的结束 Thread.sleep(2000); &#125;&#125;"},{"title":"Spring","path":"/wiki/Java/SpringFramework/Spring总结.html","content":"Spring 笔记整理。 一、Spring 二、Spring的核心API：ApplicationContext 三、Spring工厂创建复杂对象 四、Spring配置文件的细节 1. 只配置bean的class属性 2. name别名的使用 3. ref标签 五、Spring注入方式 1. set注入的简化写法 2. 构造注入 3. 循环依赖 六、Spring工厂创建复杂对象的三种方式 1. FactoryBean 接口 2. 实例工厂 3. 静态工厂 七、如何控制Spring工厂创建对象的次数 1. 控制简单对象的创建次数 2. 控制复杂对象的创建次数 八、对象的生命周期 1. 创建阶段 2. 初始化阶段 3. 销毁阶段 九、配置文件参数化 十、类型转换器 1. 自定义类型转换器实现 十一、后置处理Bean 十二、静态、动态代理的概念 1. 静态代理 2. 动态代理 十三、Spring AOP（Aspect Oriented Programing） 编程 1. 开发步骤 2. AOP的底层实现原理 2.1 JDK动态代理 2.2 CGlib 动态代理 3. 基于注解的AOP开发 4. AOP开发过程中的坑 5. AOP总结 十四、拦截器、过滤器 1. 拦截器 2. 过滤器 十五、Spring的事务管理 1. 事务并发产生的问题 1.1 脏读 1.2 不可重复读 1.3 幻影读 2. 传播属性 2.1 只读属性(readOnly) 2.2 超时属性(timeout) 2.3 异常属性(rollbackFor) 2.4 事务属性常见配置总结 十六、Spring MVC 1. 为什么要整合MVC框架 2. Spring 可以整合那些 MVC 框架 3. Spring整合MVC框架的核心思路 3.1 准备工厂 4. Spring工厂创建对象的优先级 一、SpringSpring 是一个轻量级的解决方案，它有两大核心内容：AOP 和反转控制。 反转控制（Inverse of Control） 反转： 赋值交给 Spring，解耦合 把对于成员变量赋值的控制权，从代码反转到 Spring 工厂和配置文件中完成。 底层实现： 工厂设计模式。 依赖注入DI（Dependency Injection） 注入： 通过 Spring 的工厂及配置文件，为对象（bean、组件）的成员变量赋值。 依赖注入： 当以一个类需要另一个类时，就产生了依赖，一旦出现依赖，就可以把另一个类作为本类的成员变量，最终通过 Spring 配置文件进行注入（赋值）。 二、Spring的核心API：ApplicationContextApplicationContext 是 Spring 的核心接口，它用于对象的创建，可以把它当作一个 Bean 工厂。使用这个接口可以屏蔽实现的差异，从而解耦合。 ApplicationContext 包括： ClassPathXmlApplicationContext (非 Web 环境：main junit) XmlWebApplicationContext（Web 环境） 另外，Application 是一个重量级资源，对于这类资源，我们不应去频繁的创建。 三、Spring工厂创建复杂对象 创建工厂类型； 配置文件的配置 ApplicationContext.xml 通过工厂类获得对象 123ApplicationContext |- ClassPathXmlApplicationContext |- WebXmlApplicationContext 什么是复杂对象？不能通过 new 关键字的构造方法创建的对象。例如，jdbc 的 Connection 对象，Mybatis 中的 SqlSessionFactory 等。 什么是简单对象？可以直接通过 new 构造方法创建对象，这样的对象叫做简单对象。 接口加反射，什么都能做。Spring 工厂是可以调用对象私有的构造方法创建对象，其中大量使用反射来获取信息帮助我们创建对象，这就是 Spring 工厂比我们自己创造的简易工厂强大的地方。 四、Spring配置文件的细节1. 只配置bean的class属性12&lt;!-- 该配置不含 id 属性 --&gt;&lt;bean class=&quot;com.xxx.User&quot;&gt;&lt;/bean&gt; 应用场景：如果这个 bean 只需要使用一次，那么就可以省略 id 值。如果 bean 会使用多次，或者被其他 bean 引用则需要设置 id 值。 2. name别名的使用12&lt;!-- name 就是一个别名，使用 getBean(name) 方法同样也可以创建 bean 对象，与 getBean(id) 是等效的。 --&gt;&lt;bean id=&quot;user&quot; name=&quot;a,b,c&quot; class=&quot;com.xxx.User&quot;&gt; id 和 name 的不同： 别名可以定义多个，id 只能定义一个（比如，人的大名只有一个，小名可以有多个） XML 对于 id 属性的值，命名要求：必须以字母开头，后面是字母、数字、下划线、连字符。不能以特殊字符开头。name 属性值没有要求。因此，name 可以用于比较特殊命名的场景下 ^[注①]^。 代码 containBeanDefinition(id) 只能判断 id 是否存在，不能判断 name；containBean() 可以判断 id，也可以判断 name。 注①： XML 发展到了今天：ID 属性值的限制已经不存在了。这就是语言不断更新发展的好处。 3. ref标签1234567&lt;bean id=&quot;userDao&quot; class=&quot;com.xxx.UserDaoImpl&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.xxx.UserServiceImpl&quot;&gt; &lt;property name=&quot;userDao&quot;&gt; &lt;ref bean=&quot;userDao&quot; /&gt; &lt;/property&gt;&lt;/bean&gt; Spring 4.x 废除了 &lt;ref local=&quot;&quot;/&gt;，它和 &lt;ref bean=&quot;&quot;/&gt; 基本等效。但是前者只能引用本配置文件；后者除了可以引用本配置文件，还可以引用父配置文件。 五、Spring注入方式 名称 举例 所属 说明 setter注入 setxxx() 自动注入 @Autowired Spring提供 默认根据类型注入 自动注入 @Resource JavaEE规范 默认根据名称注入 构造方法注入 public xxxConstruct() 对于 @Autowired 和 @Resource，如果按照默认的类型找不到目标类的话，会自动使用另一种方式去查找。 属性注入：@Value 注入 map 集合时，文件中必须使用 json 格式赋值，使用 #&#123;$&#123;属性&#125;&#125; 取值，map的键如果相同，后面的值会覆盖前面的值。 1. set注入的简化写法 基于属性简化 123456789101112131415161718192021&lt;!-- jdk 类型 --&gt;&lt;!-- 原始写法 --&gt;&lt;property name=&quot;id&quot;&gt; &lt;value&gt;11&lt;/value&gt;&lt;/property&gt;&lt;!-- 简化后写法 --&gt;&lt;property name=&quot;id&quot; value=&quot;11&quot; /&gt;&lt;!-- value 属性只能简化 8 种基本类型 + String 标签 --&gt;&lt;!-- 用户自定义类型 --&gt;&lt;!-- 原始写法 --&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.xxx.UserServiceImpl&quot;&gt; &lt;property name=&quot;userDao&quot;&gt; &lt;ref bean=&quot;userDao&quot; /&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 简化后写法 --&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.xxx.UserServiceImpl&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;&lt;/bean&gt; 基于命名空间 p 简化写法 使用命名空间需要在 xml 的头声明中导入对应的 xsd 模板，否则会报错。 12345&lt;!-- jdk 类型简化写法 --&gt;&lt;bean id=&quot;person&quot; class=&quot;&quot; p:name=&quot;xiaoming&quot; p:id=&quot;100&quot;/&gt;&lt;!-- 自定义类型简化写法 --&gt;&lt;bean id=&quot;&quot; class=&quot;&quot; p:userDao-ref=&quot;userDao&quot;/&gt; 2. 构造注入 提供有参构造方法 123456789public class User &#123; private String name; private Integer age; public User(String name, Integer age) &#123; this.name = name; this.age = age; &#125; &#125; Spring 的配置文件 123456789&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;&lt;!-- 一个标签对应一个参数 --&gt; &lt;constructor-arg type=&quot;&quot;&gt; &lt;value&gt;小明&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg type=&quot;&quot;&gt; &lt;value&gt;20&lt;/value&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; 如果构造方法有重载，并且参数的个数相同，这个时候需要 &lt;constructor-arg type=&quot;&quot;&gt; 指明参数的类型才能完成注入。 3. 循环依赖先说Spring解决循环引用的结论：两个对象都是 单实例 的情况下，且通 过set方式 进行注入才能成功。 Spring AOP创建的代理是在 创建对象-&gt; 属性填充 -&gt; 初始化的时候执行的。 思考：代理对象一定会在初始化的时候创建？不一定，如果涉及循环引用，创建-&gt;singletonFactries-&gt;lambda -&gt;创建 Spring解决循环依赖的步骤：步骤一：1.singletonObjects null2.earlySingleObjects null3.singletonFactories null步骤二：1.singletonObjects null2.earlySingleObjects null3.singletonFactories !&#x3D; null lambda getEarlyBeanRederence(beanName, mbd, bean) 创建代理 proxy，然后从 singletonFactories 中移除，proxy 放到 earlySingletonObjects 中。 先到 singletonObjects 中获取，如果为 null，则在 earlySingleObjects 中获取，如果还为 null，在 singletonFactories 中获取。 通过lambda getEarlyBeanRederence(beanName, mbd, bean) 创建代理，然后从 singletonFactories 中移除，把 proxy 放到 earlySingletonObjects 中。creationBean a(半成品)属性的填充：涉及 getBean(“b”)，过程和上面类似，在 b 中需要 a，上面过程中已经创建了 a，所以可以顺利拿到，进而创建 b。循环依赖就是 “你中有我，我中有你” 的解决方法。 六、Spring工厂创建复杂对象的三种方式1. FactoryBean 接口 实现 FactoryBean 接口的三个方法：getObject()，书写创建复杂对象的代码并返回复杂对象、getObjectType()，返回创建的复杂对象的 Class 对象、isSinglrton()，return true 只创建一个复杂对象，return false 每一次调用，都生成一个复杂对象。 Spring 配置文件的配置 12&lt;!-- 虽然配置是和简单对象是一样的，但是通过 id 获取的是这个类创建的复杂对象 Connection --&gt;&lt;bean id=&quot;conn&quot; class=&quot;com.xxx.ConnectionFactoryBean&quot;&gt; 如果想要获取 ConnectionFactoryBean 对象，需要 getBean(“&amp;conn”)，就是在 id 的前面加上 &amp;。 2. 实例工厂123&lt;!-- 先声明实例对象，再引用 --&gt;&lt;beann id=&quot;connFactory&quot; class=&quot;com.xxx.ConnectionFactory&quot;/&gt;&lt;bean id=&quot;conn&quot; factory-bean=&quot;connFactory&quot; factory-method=&quot;getConnection&quot;/&gt; 3. 静态工厂12&lt;!-- 直接使用 --&gt;&lt;bean id=&quot;conn&quot; class=&quot;com.xxx.xxxFactoryBean&quot; factory-method=&quot;getConnection&quot;/&gt; 七、如何控制Spring工厂创建对象的次数Q：为什么要控制对象的创建次数?A：节省不必要的内存浪费。 什么样的对象只创建一次？ SqlSessionFactory DAO Service 什么样的对象每一次都要创建 Connection SqlSession | Session Controller | Struts2 Action 总之一句话：如果可以共用，并且是线程安全的，可以只创建一次。 1. 控制简单对象的创建次数1&lt;bean id=&quot;&quot; scope=&quot;singleton|prototype&quot; class=&quot;&quot;&gt; singleton: 只会创建一次；prototype: 每一次都会创建新的对象。默认值 singleton。 2. 控制复杂对象的创建次数实现 FactoryBean 的接口的复杂对象：isSingleton() { return true;只会创建一次 return false;每一次都会创建新的}如果没有 isSingleton() 方法，还是配置 scope 属性。 八、对象的生命周期1. 创建阶段scope=&quot;singleton&quot;: Spring 工厂创建的同时（new ClassPathXmlApplicationContext()），对象被创建。如果想要在 singleton 的情况下，使用 getBean() 时才能创建对象，可以加入 lazy-init 属性，lazy-init=&quot;true&quot; scope=&quot;prototype&quot;: 在调用 getBean() 的时候创建对象。 2. 初始化阶段Spring 工厂在创建完对象后，调用对象的初始化方法，完成对应的初始化操作。 初始化方法的提供：程序员根据需求，提供初始化方法，最终完成初始化操作。 初始化调用：Spring 工厂调用。 初始化实现方式： 实现 InitializingBean 接口，重写 afterPropertiesSet() 方法。 对象中提供一个普通的方法 在配置文件中添加 init-method 属性，值为我们定义的普通的方法名称，注意不需要 ()。 Q: 如果一个对象实现了 InitializingBean 接口，也提供了普通的方法，那么执行的顺序是什么样子的呢？A: 先执行 InitializingBean，再执行普通方法。 3. 销毁阶段Spring 销毁对象前，会调用对象的销毁方法，完成销毁。销毁方法的操作只适用于 scope=&quot;singleton&quot; 的对象。销毁操作主要指资源的释放操作。例如 io，connection 等的关闭。 销毁方法：程序员根据自己的需求，定义销毁方法。调用：Spring 工厂完成调用 实现方式： 实现 DisposableBean 接口，重写 destroy() 方法； 自定义销毁方法，在配置文件的 destroy-method 属性中写自定义的方法名。 Q: Spring 什么时候销毁对象？A: ctx.close(); Q: 如果一个对象实现了 DisposableBean 接口，也提供了普通的销毁方法，那么执行的顺序是什么样子的呢？A: 执行顺序：先执行 DisposableBean 接口的实现方法，再执行普通方法。 九、配置文件参数化把Spring配置文件中需要经常修改的字符串信息，转移到一个更小的配置文件中。例如，数据库的连接可能在后期维护中会更换账户和密码，这时就可以把这些内容放到另一个文件中，这个文件专门存储变化的数据。 提供一个小的配置文件（.properties 文件），名字、位置任意。 Spring 的配置文件和小配置文件整合。 db.properties 文件： 1234jdbc.driverClassName = com.mysql.jdbc.Driverjdbc.url = jdbc:mysql://localhost:3306/jhlz?useSSL=falsejdbc.username = rootjdbc.password = root spring-config.xml 文件： 123456789&lt;!-- 配置小文件的路径 --&gt;&lt;context:property-placeholder location=&quot;classpath:/db.properties&quot;/&gt;&lt;bean id=&quot;conn&quot; class=&quot;com.xxx.ConnectionFactoryBean&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;&lt;/bean&gt; 十、类型转换器1. 自定义类型转换器实现 实现 Converter 接口，定义转换的类型与实现。 配置文件注册配置 1234567891011&lt;!-- 创建自定义转换对象 --&gt;&lt;bean id=&quot;myDateConverter&quot; class=&quot;com.xxx.MyDateConverter&quot;&gt;&lt;!-- 注册类型转换器 --&gt;&lt;!-- 目的：告诉 Spring 框架，开发的是一个类型转换器。 --&gt;&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;set&gt; &lt;ref bean=&quot;myDateConverter&quot;/&gt; &lt;/set&gt;&gt; &lt;/property&gt;&lt;/bean&gt; 注册 ConversionServiceFactoryBean 时的 id 必须为 conversionService，大小写也需要一样。Spring 框架其实内置了日期类型的转换器，但只是针对 2021/12/12 这种格式，至于其它格式依然需要程序员手动实现。 十一、后置处理BeanBeanPostProcess 作用： 对 Spring 工厂所创建的对象，进行再加工。 实现 BeanPostProcessor 接口，重写其中的方法。最好是在 after 的方法中写需要的逻辑。 BeanPostProcessor 会对 Spring 工厂创建的所有对象都生效。 十二、静态、动态代理的概念代理设计模式的作用就是额外功能的增强，可以通过动态字节码技术创建 包括JDK CGLIB ASM Javasist（MyBatis也支持）装饰器设计模式：本职功能的增强 1. 静态代理静态代理：为每一个原始类，手工编写一个代理类（有 .java 和 .class 文件） 由此我们可以知道静态代理存在的问题： 静态文件数量过多，不利于项目管理； 额外功能的维护性差（代理类中，额外功能修改复杂）。 2. 动态代理 JDK 动态代理 Proxy.newProxyInstance() 通过接口创建代理的实现类。 CGlib 动态代理 Enhancer 通过继承父类创建的代理类。 十三、Spring AOP（Aspect Oriented Programing） 编程概念：基于 Spring 的动态代理开发，通过代理类为原始类增加额外功能。好处：利于原始类的维护。本质：JDK 动态代理。 思考： AOP 如何创建动态代理类？（动态字节码技术） Spring 的工厂是如何加工创建代理对象？（通过原始对象的id值，获得代理对象）（BeanPostProcessor） SpringBoot中修改创建代理的方式，添加 @EnableApsectJAutoProxy，覆盖SpringBoot的内置设置。 Spring AOP： 默认使用 JDK 代理SpringBoot AOP： 默认使用 CGlib 代理 1. 开发步骤 原始对象 额外功能（MethodInterCeptor） 切入点 组装切面（额外功能 + 切入点） 2. AOP的底层实现原理2.1 JDK动态代理 类加载器的作用通过了类加载器把对应类的字节码文件加载到JVM通过类加载器创建类的 Class 对象，进而创建这个类的对象。 如何获得类加载器？每一个类的 .class 文件自动分配与之对应的 ClassLoader. 动态代理创建的过程中，需要 ClassLoader 创建代理类的 Class 对象，可是因为动态代理类没有对应的 .class 文件，JVM 也就不会为其分配 ClassLoader，如何创建？借用一个 ClassLoader，任意的 ClassLoader 都可以。 2.2 CGlib 动态代理CGlib创建动态代理的原理：父子继承关系创建代理对象，原始类作为父类，代理类作为子类，这样既可以保证两者方法一致，同时在代理类中提供新的实现（额外功能+原始方法）。 CGlib创建代理对象 CGlib代理 3. 基于注解的AOP开发Spring 配置文件加入： 12&lt;!-- 告知Spring是基于注解的AOP --&gt;&lt;aop:aspect-autoproxy/&gt; 在默认情况下：AOP 编程底层使用 JDK 动态代理创建代理对象。那么如何切换到 CGlib 动态代理呢？有两种方式，一种是针对 注解式 开发，另一种是针对 传统 开发。 注解式 AOP 开发：修改 Spring 的配置文件，在开启动态代理的标签中添加属性 proxy-target-class=&quot;true&quot; 12&lt;!-- 告知Spring是基于注解的AOP --&gt;&lt;aop:aspect-autoproxy proxy-target-class=&quot;true&quot;/&gt; 传统 AOP 开发切换到 CGlib 配置 1234&lt;aop:config proxy-target-class=&quot;true&quot;&gt; &lt;aop:pointcut id=&quot;pc&quot; expression=&quot;execution(* login(..)) or execution(* register(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;arround&quot; pointcut-ref=&quot;pc&quot;/&gt;&lt;/aop:config&gt; 编写一个 Aop 配置类：导入 aop 依赖；在 Aop 配置类上加上 @Aspect、@Configuration 注解；编写切面增强方法。 切入点表达式 方法级别的切入点表达式：execution(* com.XXX.*.*(..))，第一个 * 号代表可以返回任意类型值。 类级别的切入点表达式：within(com.XXX.*) 自定义注解表达式：@annotation(com.XXX) 增强方式 前置增强 (@Befor)、后置增强(@After)、环绕增强 (@Arround)、后置返回增强 (@AfterReturning)、异常增强 (@AfterThrowing) 前置和后置都没有返回值，方法参数都是 JointPoint 环绕增强中，需要调用 proceed() 才能继续处理业务逻辑(类似拦截器)，该方法返回值为业务的返回值，因此环绕增强的返回类型比较推荐设置为 Object。 环绕增强的方法参数是 ProceedingJointPoint 4. AOP开发过程中的坑在同一个的业务类中，进行业务方法间的相互调用，只有最外层方法才加入了额外功能，内部的方法通过普通的方式调用，调用的都是原始方法。如果想让内层的方法也通过代理对象调用，必须实现 ApplicationContextAware 接口获得工厂，进而获得代理对象。 5. AOP总结AOP 总结 十四、拦截器、过滤器1. 拦截器 实现 HandlerInterceptor 接口； 重写 preHandle、postHandle、afterCompletion 方法，其中 preHandle 方法中返回 true 代表放行，返回 false 代表中断。 preHandle 返回值为 true 时，执行控制器中的方法，当控制器方法执行完成后会返回拦截器中执行拦截器中的 postHandle 方法，postHandle 执行完成之后响应请求。在响应请求完成后会执行 afterCompletion 方法，该方法无论执行 成功 或者 失败 都会执行。 CustomerInterceptor.class12345678910111213141516171819202122232425public class CustomerInterceptor implements HandlerInterceptor &#123; /** * 先执行 */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return HandlerInterceptor.super.preHandle(request, response, handler); &#125; /** * 上面结果为 true 时执行 */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; HandlerInterceptor.super.postHandle(request, response, handler, modelAndView); &#125; /** * 最后都会执行 */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; HandlerInterceptor.super.afterCompletion(request, response, handler, ex); &#125;&#125; 配置拦截器：实现 WebMvcConfigurer 接口；重写 addInterceptors 方法，添加编写的拦截器。 1234567@Configuration public class WebMvcConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(customerInterceptor()); &#125; &#125; 拦截器只能拦截 controller 相关请求，不能拦截 jsp 静态资源文件；拦截器可以中断请求轨迹；请求之前如果该请求配置了拦截器，请求会先经过拦截器，放行之后执行请求的 controller，controller 执行完成后会回到拦截器继续执行拦截器代码。如果配置了多个拦截器，默认执行的顺序和栈结构是一样的；但是也可以通过 order() 方法修改，里面填 int 类型的数字，数字大的优先执行。 2. 过滤器关于过滤器，它和拦截器比较像，编写方式也非常简单，实现 Filter 接口即可。但是要清楚：过滤器是 Java 提供的，拦截器是 Spring 提供的。下面的内容引用 Spring 的原文： HandlerInterceptor is basically similar to a Servlet Filter, but in contrast to the latter it just allows custom pre-processing with the option of prohibiting the execution of the handler itself, and custom post-processing. Filters are more powerful, for example they allow for exchanging the request and response objects that are handed down the chain. Note that a filter gets configured in web.xml, a HandlerInterceptor in the application context. 汉译一下：HandlerInterceptor基本上类似于Servlet Filter，但与后者不同的是，它只允许自定义预处理(带有禁止执行处理程序本身的选项)和自定义后处理。过滤器更强大，例如，它们允许交换沿链传递的请求和响应对象。注意，过滤器是在web.xml中配置的，HandlerInterceptor是在应用程序上下文中配置的。 十五、Spring的事务管理Spring 管理事物的方式： 编程式事务，在代码中硬编码。(不推荐使用) 声明式事务，在配置文件中配置(推荐使用) 基于XML的声明式事务 基于注解的声明式事务 1. 事务并发产生的问题1.1 脏读一个事务读取了另外一个事务没有提交的数据。解决方案：@Transactional(isolation&#x3D;Isolation.READ_COMMITTED) 1.2 不可重复读在同一个事务中，多次查询同一条数据，但是读取的结果不同。解决方案：@Transactional(isolation&#x3D;Isolation.REPEATABLE_READ)本质：一把行锁 1.3 幻影读在一个事务中，对整表数据查询，显示的结果不一样。注意：是整表。会在本事务中出现数据不一致。解决方案：@Transactional(isolation&#x3D;Isolation.SERIALIZABLE)本质：表级锁。 隔离属性在实战中的建议：推荐使用 Spring 指定的 ISOLATION_DEFAULT MySQL repeatable_read Oracle read_commited 在真正的项目中，并发访问情况是很低的。如果真的遇到并发问题，那么可以使用乐观锁解决，基于系统层面的，不会对系统的性能有太大的影响。比如：Hibernate（JPA） Version、MyBatis 通过拦截器自定义开发。 2. 传播属性概念：它描述了事务解决嵌套问题的特征。什么是事务的嵌套：它指的是一个大的事务中，包含了若干个小的事务。问题：大事务中融入了很多小的事务，它们彼此影响，最终就会导致外部大的事务失败，丧失了事务的原子性。 属性名称 外部不存在事务 外部存在事务 用法 备注 REQUIRED 开启事务 融合到外部事务中 @Transactional(Propagation.REQUIRED) 增删改 SUPPORTS 不开启事务 融合到外部事务中 @Transactional(Propagation.SUPPORTS) 查询 REQUIRES_NEW 开启新的事务 挂起外部事务，开启新的事务 @Transactional(propagation.REQUIRES_NEW) 日志记录 NOT_SUPPORTED 不开启事务 挂起外部事务 @Transactional(Propagation.NOT_SUPPORTED) 极其不常用 NEVER 不开启事务 抛出异常 @Transactional(Propagation.NEVER) 极其不常用 MANDATORY 抛出异常 融合到外部事务 @Transactional(Propagation.MANDATORY) 极其不常用 2.1 只读属性(readOnly)默认为 false，不开启。针对只查询的操作，可以设为 true 开启可以提高系统的运行效率。 2.2 超时属性(timeout)timeout 以秒为单位，默认值为 -1，最终由对应的数据库来指定。 2.3 异常属性(rollbackFor)Spring 的事务处理过程中，默认对于 RuntimeException 及其子类，采用的回滚的策略；对于 Exception 及其子类，采用的是提交的策略。 手动指定：rollbackFor &#x3D; Exception.classnoRollbackFor &#x3D; RuntimeException.class 建议在实战中使用 RuntimeException 及其子类，使用事务异常属性的默认值。 2.4 事务属性常见配置总结 隔离属性 默认值 传播属性 Required（默认值） 增删改 Supports 查询操作 只读属性 readOnly false 增删改 true 查询操作 超时属性 默认值 -1 异常属性 默认值 增删改操作 @Transaction查询操作 @Transaction(propagation&#x3D;Propagation.SUPPORTS, readOnly&#x3D;true) 十六、Spring MVC1. 为什么要整合MVC框架 MVC 框架提供了控制器调用 Service 请求响应的处理， 接收请求参数 request.getParameter() 控制程序的运行流程 视图解析（jsp JSON Freemarker Thyemeleaf） 2. Spring 可以整合那些 MVC 框架 struts 1 webwork jsf struts 2 springMVC 3. Spring整合MVC框架的核心思路3.1 准备工厂 Web 开发过程中如何创建工厂ApplicationContext ctx = new new WebXmlApplicationContext(&quot;/applicationContext.xml&quot;); 如何保证工厂唯一同时被共用工厂存储在 ServletContext 这个作用域中 ServletContext.setAttribute(“xxxx”, ctx); 唯一：WebXmlApplicationContext @Configuration的使用：使用这个注解可以让 Spring 工厂创建 bean，可以不用在 applicationContext.xml 中编写 bean 标签。 创建工厂的代码改变了，需要使用 AnnotationConfigApplicationContext。指定配置 bean 的 Class。ApplicationContext ctx = new AnnotationConfigApplicationContext(xxxConfig.class);指定配置 bean 所在的路径。ApplicationContext ctx = new AnnotationConfigApplicationContext(&quot;com.config&quot;); 4. Spring工厂创建对象的优先级bean 标签 &gt; @Bean &gt; @Component 及其衍生注解。 Spring 读取Properties文件：PropertiesPlaceholderConfigurer 读取yml文件转换为Proterties：YamlPropertiesFactoryBean#setResources()YamlPropertiesFactoryBean#getObject() Spring与YML集成依赖（最低所需版本：1.18） 12345&lt;dependency&gt; &lt;groupId&gt;org.yaml&lt;/groupId&gt; &lt;artifactId&gt;snakeyaml&lt;/artifactId&gt; &lt;version&gt;1.30&lt;/version&gt;&lt;/dependency&gt;"},{"title":"微服务","path":"/wiki/Java/SpringFramework/微服务.html","content":"微服务笔记整理 Spring Cloud微服务 1. Spring Cloud相关组件说明 1.1 服务注册与发现中心组件(管理微服务的健康值状态) 1.2 服务间通信组件 1.3 服务熔断器（解决服务雪崩问题） 1.4 服务网关中心（提供请求统一入口，路由转发，过滤） 1.5 服务统一配置中心 2. SpringCloud Alibaba组件 使用Spring Cloud Alibaba搭建微服务 微服务使用依赖版本号：spring boot：2.3.2.RELEASEspring cloud：Hoxton.SR9spring cloud Alibaba：2.2.6.RELEASEsentinel：1.8.1nacos：1.4.2rocketMQ：4.4.0Dubbo：2.7.8seata：1.3.0 微服务的 版本选择 需要有一定的要求，不然可能出现冲突和其它的问题； Spring Cloud微服务微服务时代充满着自由的气息，微服务时代充斥着迷茫的选择。 服务间的远程调用解决方案：RMI（Sun&#x2F;Oracle）Thrift（Facebook）Dubbo（阿里巴巴）gRPC（Google）otan2（新浪）Finagle（Twitter）brpc（百度）Arvo（Hadoop）JSON-RPCREST 服务发现： Eureka(Netflix) Consul(HashiCorp,GO语言编写)，启动后可以访问 ip:8500 进入管理页面 Nacos(Alibaba开源)，启动后可以使用 ip:8848 进入管理页面 Zookeeper(Apache,Java语言编写) Etcd（CoreOS） CoreDNS（CNCF） 微服务：一种服务架构。基于单体应用的业务进行拆分，拆分的每一个服务都是一个独立项目，针对拆分出来的微服务都是基于分布式管理。微服务的通信方式：RPC协议、Http协议(推荐) 优点： 1、拆分的每个服务各司其职，解耦合 2、每个服务高度自治 3、不会因为一个服务的问题导致其他服务不可用 缺点： 1、服务部署复杂度增加 2、分布式系统复杂(服务间通信、负载均衡…高可用等等) 随着微服务的发展，出现了很多的 SpringCloud 微服务工具集，这些一站式微服务工具，帮助我们解决了分布式系统中各种问题，让开发人员更专注于自己的业务开发。 目前有两种搭建微服务的方式，其实搭建微服务主要是组件的选取。一种是 Spring Cloud 整合的微服务工具集，另一种是阿里开源的 Spring Cloud Alibaba 微服务一站式解决方案。 1. Spring Cloud相关组件说明1.1 服务注册与发现中心组件(管理微服务的健康值状态) Eureka(Netflix) Consul(HashiCorp,GO语言编写)，启动后可以访问 ip:8500 进入管理页面 Nacos(Alibaba开源)，启动后可以使用 ip:8848 进入管理页面 Zookeeper(Apache,Java语言编写) 1.2 服务间通信组件 RestTemplate + Ribbon(NetFlix)实现负载均衡 OpenFeign(包含Ribbon)伪http客户端，支持Spring注解(推荐) RestTemplate 与 Openfegin 对比： RestTemplate 将路径写死在代码中，不利于维护。 Openfegin组件(内部集成了Ribbon)：解决了 RestTemplate 实现服务间通信的所有问题，并且使用简单，支持注解。 使用 OpenFeign 组件进行客户端的服务通信时，映射地址(@RequestMapping)和被调用的 FeignClient 的对应的方法映射地址必须相同；方法名称可以不同，但为确保一致性，推荐使用相同的方法名和相同的映射地址。 1.3 服务熔断器（解决服务雪崩问题） Hystrix(进入了维护模式)以及对应的可视化展示工具 Hystrix DashBoard Hystrix 断路器打开条件： 当满足一定的阈值，默认10秒内超过20个请求 当失败率达到一定的时候，默认10秒内超过50%的请求失败 1.4 服务网关中心（提供请求统一入口，路由转发，过滤） Gateway (转发、负载均衡、断言、过滤) zuul1.x zuul2.x 1.5 服务统一配置中心 config 组件： ConfigServer 获取远程仓库的地址存入本地仓库 ConfigClient 根据 ConfigServer 读取自身配置 bus 组件：消息总线：将微服务所有节点链接到一起，通过总线实现自动配置刷新 2. SpringCloud Alibaba组件Sentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。 Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。 RocketMQ：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。 Dubbo：Apache Dubbo™ 是一款高性能 Java RPC 框架。 Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。 sentinel（哨兵）:五大规则： a.流控规则: 只能使用别名(@SentinelResource())，才能使用自定义处理 b.降级规则 c.热点规则 d.系统规则 e.授权规则 使用Spring Cloud Alibaba搭建微服务引入依赖： 1234567891011121314151617181920212223242526272829&lt;!--spring cloud alibabab 依赖--&gt;&lt;!--全局配置中心依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;version&gt;2.2.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--服务注册中心依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;version&gt;2.2.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- openfeign 依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- sentinel 依赖--&gt;&lt;dependency&gt;&lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;&lt;artifactId&gt;sentinel-core&lt;/artifactId&gt;&lt;version&gt;1.7.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;&lt;/dependency&gt; nacos 提供了两种远程读取文件方式，在具体的使用中可以根据需要灵活选择配置方式。 名称 +　后缀 前缀 + 开发环境 + 后缀 12345678910111213141516171819202122232425262728293031323334# 第一种获取远程配置的方式 名称 + 后缀 == dataIDspring.cloud.nacos.server-addr=localhost:8848spring.cloud.nacos.config.namespace=spring.cloud.nacos.config.group=USERSspring.cloud.nacos.config.name=users-prodspring.cloud.nacos.config.file-extension=properties# 配置名称spring.cloud.nacos.config.name=configclient-prod# 配置的后缀名称spring.cloud.nacos.config.file-extension=properties# 第二种获取远程配置的方式 前缀 + 环境 + 后缀# 例如 configclient-prod.properties# 前缀#spring.cloud.nacos.config.prefix=configclient# 后缀#spring.cloud.nacos.config.file-extension=properties# 间隔符#spring.profiles.active=prod# 命名空间#spring.cloud.nacos.config.namespace=public# 配置所属组id#spring.cloud.nacos.config.group=# nacos 注册发现#spring.cloud.nacos.discovery.enabled=true# 注册中心地址#spring.cloud.nacos.server-addr=localhost:8848# 与 sentinel dashboard 通信spring.cloud.sentinel.enabled=truespring.cloud.sentinel.eager=truespring.cloud.sentinel.transport.port=8719spring.cloud.sentinel.transport.dashboard=localhost:9191 注解说明：@EnableDiscoveryClient这个注解，这个注解的作用是让该服务放注册中心注册和从注册中心获取其他服务@RefreshScope实现拉取远程配置自动刷新；不用重新启动，修改远程文件刷新即可生效"}]