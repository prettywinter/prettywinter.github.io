<!DOCTYPE html>
<html lang='en'>

<head>
  <meta name="generator" content="Hexo 6.3.0">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.19.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://gcore.jsdelivr.net'>
  <link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>Java: Spring - 浮萍一叶</title>

  
    <meta name="description" content="Spring 笔记整理。">
<meta property="og:type" content="website">
<meta property="og:title" content="Spring">
<meta property="og:url" content="https://prettywinter.github.io/wiki/Java/SpringFramework/Spring%E6%80%BB%E7%BB%93">
<meta property="og:site_name" content="浮萍一叶">
<meta property="og:description" content="Spring 笔记整理。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://fastly.jsdelivr.net/gh/prettywinter/dist/images/doc/CGlib%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1.png">
<meta property="og:image" content="https://fastly.jsdelivr.net/gh/prettywinter/dist/images/doc/CGlib%E4%BB%A3%E7%90%86.png">
<meta property="og:image" content="https://fastly.jsdelivr.net/gh/prettywinter/dist/images/doc/AOP%E6%80%BB%E7%BB%93.png">
<meta property="article:published_time" content="2023-05-03T05:34:53.921Z">
<meta property="article:modified_time" content="2023-05-03T05:34:53.921Z">
<meta property="article:author" content="江湖浪子">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fastly.jsdelivr.net/gh/prettywinter/dist/images/doc/CGlib%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1.png">
  
  
  
  

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="浮萍一叶" type="application/atom+xml">
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  
    <link rel="shortcut icon" href="https://fastly.jsdelivr.net/gh/prettywinter/dist/images/favicon/favicon-32x32.png">
  

  

  


  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='wiki'>
    

  




<div class="widgets"><widget class="widget-wrapper logo-wrap wiki"><div class="widget-body"><a style="filter: grayscale(100%)" class="wiki-home cap" href="/wiki"><svg aria-hidden="true" viewBox="0 0 16 16" width="1rem" height="1rem" fill="currentColor"><path fill-rule="evenodd" d="M7.78 12.53a.75.75 0 01-1.06 0L2.47 8.28a.75.75 0 010-1.06l4.25-4.25a.75.75 0 011.06 1.06L4.81 7h7.44a.75.75 0 010 1.5H4.81l2.97 2.97a.75.75 0 010 1.06z"></path></svg>All Products</a><a class="title" href="/wiki/Java/index.html"><div class="main" ff="title">Java</div></a></div></widget>
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/wiki/Java/" placeholder="Search in /wiki/Java/"><svg t="1670596976048" class="icon search-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2676" width="200" height="200"><path d="M938.2 832.6L723.8 618.1c-2.5-2.5-5.3-4.4-7.9-6.4 36.2-55.6 57.3-121.8 57.3-193.1C773.3 222.8 614.6 64 418.7 64S64 222.8 64 418.6c0 195.9 158.8 354.6 354.6 354.6 71.3 0 137.5-21.2 193.2-57.4 2 2.7 3.9 5.4 6.3 7.8L832.5 938c14.6 14.6 33.7 21.9 52.8 21.9 19.1 0 38.2-7.3 52.8-21.8 29.2-29.1 29.2-76.4 0.1-105.5M418.7 661.3C284.9 661.3 176 552.4 176 418.6 176 284.9 284.9 176 418.7 176c133.8 0 242.6 108.9 242.6 242.7 0 133.7-108.9 242.6-242.6 242.6" p-id="2677"></path></svg></form><div id="search-result"></div><div class="search-no-result">No Results!</div></div></div></widget>




<widget class="widget-wrapper toc multi" id="data-toc"><div class="widget-header cap dis-select"><span class="name">Java</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Java/index.html#start"><span class="toc-text">Java开发总结、踩坑记录等乱七八糟的</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Java/Java%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93"><span class="toc-text">Java开发问题总结</span></a></div></div><div class="widget-header cap dis-select"><span class="name">Spring</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Java/SpringFramework/%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-text">微服务</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Java/SpringFramework/Spring%E6%B3%A8%E8%A7%A3"><span class="toc-text">注解</span></a></div><div class="doc-tree active"><a class="doc-tree-link active" href="/wiki/Java/SpringFramework/Spring%E6%80%BB%E7%BB%93"><span class="toc-text">Spring</span></a><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Spring"><span class="toc-text">一、Spring</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Spring%E7%9A%84%E6%A0%B8%E5%BF%83API%EF%BC%9AApplicationContext"><span class="toc-text">二、Spring的核心API：ApplicationContext</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Spring%E5%B7%A5%E5%8E%82%E5%88%9B%E5%BB%BA%E5%A4%8D%E6%9D%82%E5%AF%B9%E8%B1%A1"><span class="toc-text">三、Spring工厂创建复杂对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Spring%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-text">四、Spring配置文件的细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8F%AA%E9%85%8D%E7%BD%AEbean%E7%9A%84class%E5%B1%9E%E6%80%A7"><span class="toc-text">1. 只配置bean的class属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-name%E5%88%AB%E5%90%8D%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">2. name别名的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-ref%E6%A0%87%E7%AD%BE"><span class="toc-text">3. ref标签</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Spring%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="toc-text">五、Spring注入方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-set%E6%B3%A8%E5%85%A5%E7%9A%84%E7%AE%80%E5%8C%96%E5%86%99%E6%B3%95"><span class="toc-text">1. set注入的简化写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9E%84%E9%80%A0%E6%B3%A8%E5%85%A5"><span class="toc-text">2. 构造注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-text">3. 循环依赖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81Spring%E5%B7%A5%E5%8E%82%E5%88%9B%E5%BB%BA%E5%A4%8D%E6%9D%82%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">六、Spring工厂创建复杂对象的三种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-FactoryBean-%E6%8E%A5%E5%8F%A3"><span class="toc-text">1. FactoryBean 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9E%E4%BE%8B%E5%B7%A5%E5%8E%82"><span class="toc-text">2. 实例工厂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82"><span class="toc-text">3. 静态工厂</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6Spring%E5%B7%A5%E5%8E%82%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="toc-text">七、如何控制Spring工厂创建对象的次数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8E%A7%E5%88%B6%E7%AE%80%E5%8D%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E6%AC%A1%E6%95%B0"><span class="toc-text">1. 控制简单对象的创建次数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8E%A7%E5%88%B6%E5%A4%8D%E6%9D%82%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E6%AC%A1%E6%95%B0"><span class="toc-text">2. 控制复杂对象的创建次数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">八、对象的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E9%98%B6%E6%AE%B5"><span class="toc-text">1. 创建阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5"><span class="toc-text">2. 初始化阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%94%80%E6%AF%81%E9%98%B6%E6%AE%B5"><span class="toc-text">3. 销毁阶段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8F%82%E6%95%B0%E5%8C%96"><span class="toc-text">九、配置文件参数化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%99%A8"><span class="toc-text">十、类型转换器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">1. 自定义类型转换器实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86Bean"><span class="toc-text">十一、后置处理Bean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E9%9D%99%E6%80%81%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">十二、静态、动态代理的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">1. 静态代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">2. 动态代理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81Spring-AOP%EF%BC%88Aspect-Oriented-Programing%EF%BC%89-%E7%BC%96%E7%A8%8B"><span class="toc-text">十三、Spring AOP（Aspect Oriented Programing） 编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4"><span class="toc-text">1. 开发步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-AOP%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">2. AOP的底层实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">2.1 JDK动态代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-CGlib-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">2.2 CGlib 动态代理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84AOP%E5%BC%80%E5%8F%91"><span class="toc-text">3. 基于注解的AOP开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-AOP%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%9D%91"><span class="toc-text">4. AOP开发过程中的坑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-AOP%E6%80%BB%E7%BB%93"><span class="toc-text">5. AOP总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81%E6%8B%A6%E6%88%AA%E5%99%A8%E3%80%81%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-text">十四、拦截器、过滤器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-text">1. 拦截器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-text">2. 过滤器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%94%E3%80%81Spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="toc-text">十五、Spring的事务管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E4%BA%A7%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">1. 事务并发产生的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E8%84%8F%E8%AF%BB"><span class="toc-text">1.1 脏读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="toc-text">1.2 不可重复读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%B9%BB%E5%BD%B1%E8%AF%BB"><span class="toc-text">1.3 幻影读</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BC%A0%E6%92%AD%E5%B1%9E%E6%80%A7"><span class="toc-text">2. 传播属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7-readOnly"><span class="toc-text">2.1 只读属性(readOnly)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E8%B6%85%E6%97%B6%E5%B1%9E%E6%80%A7-timeout"><span class="toc-text">2.2 超时属性(timeout)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E5%BC%82%E5%B8%B8%E5%B1%9E%E6%80%A7-rollbackFor"><span class="toc-text">2.3 异常属性(rollbackFor)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93"><span class="toc-text">2.4 事务属性常见配置总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%85%AD%E3%80%81Spring-MVC"><span class="toc-text">十六、Spring MVC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%95%B4%E5%90%88MVC%E6%A1%86%E6%9E%B6"><span class="toc-text">1. 为什么要整合MVC框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Spring-%E5%8F%AF%E4%BB%A5%E6%95%B4%E5%90%88%E9%82%A3%E4%BA%9B-MVC-%E6%A1%86%E6%9E%B6"><span class="toc-text">2. Spring 可以整合那些 MVC 框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Spring%E6%95%B4%E5%90%88MVC%E6%A1%86%E6%9E%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF"><span class="toc-text">3. Spring整合MVC框架的核心思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%87%86%E5%A4%87%E5%B7%A5%E5%8E%82"><span class="toc-text">3.1 准备工厂</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Spring%E5%B7%A5%E5%8E%82%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">4. Spring工厂创建对象的优先级</span></a></li></ol></li></ol></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Java/SpringFramework/SpringBoot"><span class="toc-text">SpringBoot</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Java/SpringFramework/SpringSecurity"><span class="toc-text">SpringSecurity</span></a></div></div><div class="widget-header cap dis-select"><span class="name">MyBatis/MyBatisPlus(MP)</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Java/ORM/MyBatis"><span class="toc-text">MyBatis、MyBatis Plus（MP）</span></a></div></div><div class="widget-header cap dis-select"><span class="name">Java随笔</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Java/Java%E9%9A%8F%E7%AC%94/JavaApi"><span class="toc-text">Java API</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Java/Java%E9%9A%8F%E7%AC%94/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-text">Spring事务失效</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Java/Java%E9%9A%8F%E7%AC%94/Java%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5"><span class="toc-text">Java单元测试</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Java/Java%E9%9A%8F%E7%AC%94/volatile"><span class="toc-text">volatile 关键字</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Java/Java%E9%9A%8F%E7%AC%94/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3"><span class="toc-text">前端相关</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Java/Java%E9%9A%8F%E7%AC%94/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%A8%A1%E6%9D%BF%E6%B6%88%E6%81%AF%E6%B5%8B%E8%AF%95%E6%8E%A8%E9%80%81"><span class="toc-text">业务常用SQL</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Java/Java%E9%9A%8F%E7%AC%94/%E8%AE%A4%E8%AF%86%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E9%94%81"><span class="toc-text">程序的锁</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Java/Java%E9%9A%8F%E7%AC%94/Maven"><span class="toc-text">Maven</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Java/Java%E9%9A%8F%E7%AC%94/Gradle"><span class="toc-text">Gradle</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Java/Java%E9%9A%8F%E7%AC%94/Java%E4%BD%BF%E7%94%A8mysql-binlog%E8%A7%A3%E6%9E%90%E6%95%B0%E6%8D%AE"><span class="toc-text">Java解析MySQL的binlog日志</span></a></div></div><div class="widget-header cap dis-select"><span class="name">JVM</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/Java/JVM/JVM"><span class="toc-text">JVM</span></a></div></div></widget>



<widget class="widget-wrapper related"><div class="widget-header cap theme dis-select"><span class="name">More 知识总结</span></div><div class="widget-body related-posts"><a class="item wiki" href="/wiki/Git/index.html"><span class="title">Git总结</span></a><a class="item wiki" href="/wiki/Database/index.html"><span class="title">数据库总结</span></a></div></widget>
</div>


    </aside>
    <div class='l_main'>
      

      

  
  
<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" id="home" href="/">Home</a><span class="sep"></span><a class="cap breadcrumb" id="menu" href="/wiki/">Wiki</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/wiki/Java/index.html">Java</a></div><div id="post-meta">Updated on&nbsp;<time datetime="2023-05-03T05:34:53.921Z">2023-05-03</time></div></div>

  <article class='md-text content wiki'>
  <h1 class="article-title"><span>Spring</span></h1>
  <p>Spring 笔记整理。</p>
<span id="more"></span>

<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=4 orderedList=false} -->

<!-- code_chunk_output -->
<ul>
<li><a href="#%E4%B8%80spring">一、Spring</a></li>
<li><a href="#%E4%BA%8Cspring%E7%9A%84%E6%A0%B8%E5%BF%83apiapplicationcontext">二、Spring的核心API：ApplicationContext</a></li>
<li><a href="#%E4%B8%89spring%E5%B7%A5%E5%8E%82%E5%88%9B%E5%BB%BA%E5%A4%8D%E6%9D%82%E5%AF%B9%E8%B1%A1">三、Spring工厂创建复杂对象</a></li>
<li><a href="#%E5%9B%9Bspring%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%86%E8%8A%82">四、Spring配置文件的细节</a><ul>
<li><a href="#1-%E5%8F%AA%E9%85%8D%E7%BD%AEbean%E7%9A%84class%E5%B1%9E%E6%80%A7">1. 只配置bean的class属性</a></li>
<li><a href="#2-name%E5%88%AB%E5%90%8D%E7%9A%84%E4%BD%BF%E7%94%A8">2. name别名的使用</a></li>
<li><a href="#3-ref%E6%A0%87%E7%AD%BE">3. ref标签</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94spring%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F">五、Spring注入方式</a><ul>
<li><a href="#1-set%E6%B3%A8%E5%85%A5%E7%9A%84%E7%AE%80%E5%8C%96%E5%86%99%E6%B3%95">1. set注入的简化写法</a></li>
<li><a href="#2-%E6%9E%84%E9%80%A0%E6%B3%A8%E5%85%A5">2. 构造注入</a></li>
<li><a href="#3-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96">3. 循环依赖</a></li>
</ul>
</li>
<li><a href="#%E5%85%ADspring%E5%B7%A5%E5%8E%82%E5%88%9B%E5%BB%BA%E5%A4%8D%E6%9D%82%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F">六、Spring工厂创建复杂对象的三种方式</a><ul>
<li><a href="#1-factorybean-%E6%8E%A5%E5%8F%A3">1. FactoryBean 接口</a></li>
<li><a href="#2-%E5%AE%9E%E4%BE%8B%E5%B7%A5%E5%8E%82">2. 实例工厂</a></li>
<li><a href="#3-%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82">3. 静态工厂</a></li>
</ul>
</li>
<li><a href="#%E4%B8%83%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6spring%E5%B7%A5%E5%8E%82%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AC%A1%E6%95%B0">七、如何控制Spring工厂创建对象的次数</a><ul>
<li><a href="#1-%E6%8E%A7%E5%88%B6%E7%AE%80%E5%8D%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E6%AC%A1%E6%95%B0">1. 控制简单对象的创建次数</a></li>
<li><a href="#2-%E6%8E%A7%E5%88%B6%E5%A4%8D%E6%9D%82%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E6%AC%A1%E6%95%B0">2. 控制复杂对象的创建次数</a></li>
</ul>
</li>
<li><a href="#%E5%85%AB%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">八、对象的生命周期</a><ul>
<li><a href="#1-%E5%88%9B%E5%BB%BA%E9%98%B6%E6%AE%B5">1. 创建阶段</a></li>
<li><a href="#2-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5">2. 初始化阶段</a></li>
<li><a href="#3-%E9%94%80%E6%AF%81%E9%98%B6%E6%AE%B5">3. 销毁阶段</a></li>
</ul>
</li>
<li><a href="#%E4%B9%9D%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8F%82%E6%95%B0%E5%8C%96">九、配置文件参数化</a></li>
<li><a href="#%E5%8D%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%99%A8">十、类型转换器</a><ul>
<li><a href="#1-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%99%A8%E5%AE%9E%E7%8E%B0">1. 自定义类型转换器实现</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81%E4%B8%80%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86bean">十一、后置处理Bean</a></li>
<li><a href="#%E5%8D%81%E4%BA%8C%E9%9D%99%E6%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5">十二、静态、动态代理的概念</a><ul>
<li><a href="#1-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86">1. 静态代理</a></li>
<li><a href="#2-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">2. 动态代理</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81%E4%B8%89spring-aopaspect-oriented-programing-%E7%BC%96%E7%A8%8B">十三、Spring AOP（Aspect Oriented Programing） 编程</a><ul>
<li><a href="#1-%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4">1. 开发步骤</a></li>
<li><a href="#2-aop%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">2. AOP的底层实现原理</a><ul>
<li><a href="#21-jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">2.1 JDK动态代理</a></li>
<li><a href="#22-cglib-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">2.2 CGlib 动态代理</a></li>
</ul>
</li>
<li><a href="#3-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84aop%E5%BC%80%E5%8F%91">3. 基于注解的AOP开发</a></li>
<li><a href="#4-aop%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%9D%91">4. AOP开发过程中的坑</a></li>
<li><a href="#5-aop%E6%80%BB%E7%BB%93">5. AOP总结</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81%E5%9B%9B%E6%8B%A6%E6%88%AA%E5%99%A8%E8%BF%87%E6%BB%A4%E5%99%A8">十四、拦截器、过滤器</a><ul>
<li><a href="#1-%E6%8B%A6%E6%88%AA%E5%99%A8">1. 拦截器</a></li>
<li><a href="#2-%E8%BF%87%E6%BB%A4%E5%99%A8">2. 过滤器</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81%E4%BA%94spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86">十五、Spring的事务管理</a><ul>
<li><a href="#1-%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E4%BA%A7%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98">1. 事务并发产生的问题</a><ul>
<li><a href="#11-%E8%84%8F%E8%AF%BB">1.1 脏读</a></li>
<li><a href="#12-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB">1.2 不可重复读</a></li>
<li><a href="#13-%E5%B9%BB%E5%BD%B1%E8%AF%BB">1.3 幻影读</a></li>
</ul>
</li>
<li><a href="#2-%E4%BC%A0%E6%92%AD%E5%B1%9E%E6%80%A7">2. 传播属性</a><ul>
<li><a href="#21-%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7readonly">2.1 只读属性(readOnly)</a></li>
<li><a href="#22-%E8%B6%85%E6%97%B6%E5%B1%9E%E6%80%A7timeout">2.2 超时属性(timeout)</a></li>
<li><a href="#23-%E5%BC%82%E5%B8%B8%E5%B1%9E%E6%80%A7rollbackfor">2.3 异常属性(rollbackFor)</a></li>
<li><a href="#24-%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93">2.4 事务属性常见配置总结</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%8D%81%E5%85%ADspring-mvc">十六、Spring MVC</a><ul>
<li><a href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%95%B4%E5%90%88mvc%E6%A1%86%E6%9E%B6">1. 为什么要整合MVC框架</a></li>
<li><a href="#2-spring-%E5%8F%AF%E4%BB%A5%E6%95%B4%E5%90%88%E9%82%A3%E4%BA%9B-mvc-%E6%A1%86%E6%9E%B6">2. Spring 可以整合那些 MVC 框架</a></li>
<li><a href="#3-spring%E6%95%B4%E5%90%88mvc%E6%A1%86%E6%9E%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF">3. Spring整合MVC框架的核心思路</a><ul>
<li><a href="#31-%E5%87%86%E5%A4%87%E5%B7%A5%E5%8E%82">3.1 准备工厂</a></li>
</ul>
</li>
<li><a href="#4-spring%E5%B7%A5%E5%8E%82%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7">4. Spring工厂创建对象的优先级</a></li>
</ul>
</li>
</ul>
<!-- /code_chunk_output -->

<h2 id="一、Spring"><a href="#一、Spring" class="headerlink" title="一、Spring"></a>一、Spring</h2><p>Spring 是一个轻量级的解决方案，它有两大核心内容：AOP 和反转控制。</p>
<ol>
<li><p>反转控制（Inverse of Control）</p>
<ul>
<li>反转： 赋值交给 Spring，解耦合</li>
<li>把对于成员变量赋值的控制权，从代码反转到 Spring 工厂和配置文件中完成。</li>
<li>底层实现： 工厂设计模式。</li>
</ul>
</li>
<li><p>依赖注入DI（Dependency Injection）</p>
<ul>
<li>注入： 通过 Spring 的工厂及配置文件，为对象（bean、组件）的成员变量赋值。</li>
<li>依赖注入： 当以一个类需要另一个类时，就产生了依赖，一旦出现依赖，就可以把另一个类作为本类的成员变量，最终通过 Spring 配置文件进行注入（赋值）。</li>
</ul>
</li>
</ol>
<h2 id="二、Spring的核心API：ApplicationContext"><a href="#二、Spring的核心API：ApplicationContext" class="headerlink" title="二、Spring的核心API：ApplicationContext"></a>二、Spring的核心API：ApplicationContext</h2><p>ApplicationContext 是 Spring 的核心接口，它用于对象的创建，可以把它当作一个 Bean 工厂。使用这个接口可以屏蔽实现的差异，从而解耦合。</p>
<p>ApplicationContext 包括：</p>
<ol>
<li>ClassPathXmlApplicationContext (非 Web 环境：main junit)</li>
<li>XmlWebApplicationContext（Web 环境）</li>
</ol>
<p>另外，Application 是一个重量级资源，对于这类资源，我们不应去频繁的创建。</p>
<h2 id="三、Spring工厂创建复杂对象"><a href="#三、Spring工厂创建复杂对象" class="headerlink" title="三、Spring工厂创建复杂对象"></a>三、Spring工厂创建复杂对象</h2><ol>
<li><p>创建工厂类型；</p>
</li>
<li><p>配置文件的配置 ApplicationContext.xml</p>
</li>
<li><p>通过工厂类获得对象</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext</span><br><span class="line">  |- ClassPathXmlApplicationContext</span><br><span class="line">  |- WebXmlApplicationContext</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p>什么是复杂对象？<br>不能通过 <strong>new</strong> 关键字的构造方法创建的对象。例如，jdbc 的 <strong>Connection</strong> 对象，Mybatis 中的 <strong>SqlSessionFactory</strong> 等。</p>
</li>
<li><p>什么是简单对象？<br>可以直接通过 <strong>new</strong> 构造方法创建对象，这样的对象叫做简单对象。</p>
</li>
</ul>
<p>接口加反射，什么都能做。Spring 工厂是可以调用对象私有的构造方法创建对象，其中大量使用反射来获取信息帮助我们创建对象，这就是 Spring 工厂比我们自己创造的简易工厂强大的地方。</p>
<h2 id="四、Spring配置文件的细节"><a href="#四、Spring配置文件的细节" class="headerlink" title="四、Spring配置文件的细节"></a>四、Spring配置文件的细节</h2><h3 id="1-只配置bean的class属性"><a href="#1-只配置bean的class属性" class="headerlink" title="1. 只配置bean的class属性"></a>1. 只配置bean的class属性</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 该配置不含 id 属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.xxx.User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>应用场景：如果这个 bean 只需要使用一次，那么就可以省略 id 值。如果 bean 会使用多次，或者被其他 bean 引用则需要设置 id 值。</p>
</blockquote>
<h3 id="2-name别名的使用"><a href="#2-name别名的使用" class="headerlink" title="2. name别名的使用"></a>2. name别名的使用</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- name 就是一个别名，使用 getBean(name) 方法同样也可以创建 bean 对象，与 getBean(id) 是等效的。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">name</span>=<span class="string">&quot;a,b,c&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xxx.User&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>id 和 name 的不同：</p>
<ol>
<li>别名可以定义多个，id 只能定义一个（比如，人的大名只有一个，小名可以有多个）</li>
<li>XML 对于 id 属性的值，命名要求：必须以字母开头，后面是字母、数字、下划线、连字符。不能以特殊字符开头。name 属性值没有要求。因此，name 可以用于比较特殊命名的场景下 <strong>^[注①]^</strong>。</li>
<li>代码<br>  containBeanDefinition(id) 只能判断 id 是否存在，不能判断 name；containBean() 可以判断 id，也可以判断 name。</li>
</ol>
<blockquote>
<p><strong>注①：</strong> XML 发展到了今天：ID 属性值的限制已经不存在了。这就是语言不断更新发展的好处。</p>
</blockquote>
<h3 id="3-ref标签"><a href="#3-ref标签" class="headerlink" title="3. ref标签"></a>3. ref标签</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xxx.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xxx.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;userDao&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Spring 4.x 废除了 <code>&lt;ref local=&quot;&quot;/&gt;</code>，它和 <code>&lt;ref bean=&quot;&quot;/&gt;</code> 基本等效。但是前者只能引用本配置文件；后者除了可以引用本配置文件，还可以引用父配置文件。</p>
</blockquote>
<h2 id="五、Spring注入方式"><a href="#五、Spring注入方式" class="headerlink" title="五、Spring注入方式"></a>五、Spring注入方式</h2><table>
<thead>
<tr>
<th>名称</th>
<th>举例</th>
<th>所属</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>setter注入</td>
<td>setxxx()</td>
<td></td>
<td></td>
</tr>
<tr>
<td>自动注入</td>
<td>@Autowired</td>
<td>Spring提供</td>
<td>默认根据类型注入</td>
</tr>
<tr>
<td>自动注入</td>
<td>@Resource</td>
<td>JavaEE规范</td>
<td>默认根据名称注入</td>
</tr>
<tr>
<td>构造方法注入</td>
<td>public xxxConstruct()</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>对于 @Autowired 和 @Resource，如果按照默认的类型找不到目标类的话，会自动使用另一种方式去查找。</p>
<p>属性注入：@Value 注入 map 集合时，文件中必须使用 json 格式赋值，使用 <code>#&#123;$&#123;属性&#125;&#125;</code> 取值，map的键如果相同，后面的值会覆盖前面的值。</p>
<h3 id="1-set注入的简化写法"><a href="#1-set注入的简化写法" class="headerlink" title="1. set注入的简化写法"></a>1. set注入的简化写法</h3><ol>
<li><p>基于属性简化</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- jdk 类型 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 原始写法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>11<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 简化后写法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;11&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- value 属性只能简化 8 种基本类型 + String 标签 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用户自定义类型 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 原始写法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xxx.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;userDao&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 简化后写法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xxx.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>基于命名空间 p 简化写法</p>
<p> 使用命名空间需要在 xml 的头声明中导入对应的 xsd 模板，否则会报错。</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- jdk 类型简化写法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;xiaoming&quot;</span> <span class="attr">p:id</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 自定义类型简化写法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span> <span class="attr">p:userDao-ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-构造注入"><a href="#2-构造注入" class="headerlink" title="2. 构造注入"></a>2. 构造注入</h3><ol>
<li><p>提供有参构造方法</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, Integer age)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">      <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Spring 的配置文件</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 一个标签对应一个参数 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>小明<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>20<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果构造方法有重载，并且参数的个数相同，这个时候需要 <code>&lt;constructor-arg type=&quot;&quot;&gt;</code> 指明参数的类型才能完成注入。</p>
</blockquote>
</li>
</ol>
<h3 id="3-循环依赖"><a href="#3-循环依赖" class="headerlink" title="3. 循环依赖"></a>3. 循环依赖</h3><p>先说Spring解决循环引用的结论：两个对象都是 <strong>单实例</strong> 的情况下，且通 <strong>过set方式</strong> 进行注入才能成功。</p>
<p>Spring AOP创建的代理是在 创建对象-&gt; 属性填充 -&gt; 初始化的时候执行的。</p>
<p>思考：代理对象一定会在初始化的时候创建？<br>不一定，如果涉及循环引用，创建-&gt;singletonFactries-&gt;lambda -&gt;创建</p>
<p>Spring解决循环依赖的步骤：<br>步骤一：<br>1.singletonObjects    null<br>2.earlySingleObjects  null<br>3.singletonFactories  null<br>步骤二：<br>1.singletonObjects    null<br>2.earlySingleObjects  null<br>3.singletonFactories  !&#x3D; null lambda getEarlyBeanRederence(beanName, mbd, bean) 创建代理 proxy，然后从 singletonFactories 中移除，proxy 放到 earlySingletonObjects 中。</p>
<blockquote>
<ol>
<li>先到 singletonObjects 中获取，如果为 null，则在 earlySingleObjects 中获取，如果还为 null，在 singletonFactories 中获取。</li>
<li>通过lambda getEarlyBeanRederence(beanName, mbd, bean) 创建代理，然后从 singletonFactories 中移除，把 proxy 放到 earlySingletonObjects 中。<br>creationBean a(半成品)<br>属性的填充：涉及 getBean(“b”)，过程和上面类似，在 b 中需要 a，上面过程中已经创建了 a，所以可以顺利拿到，进而创建 b。循环依赖就是 “你中有我，我中有你” 的解决方法。</li>
</ol>
</blockquote>
<h2 id="六、Spring工厂创建复杂对象的三种方式"><a href="#六、Spring工厂创建复杂对象的三种方式" class="headerlink" title="六、Spring工厂创建复杂对象的三种方式"></a>六、Spring工厂创建复杂对象的三种方式</h2><h3 id="1-FactoryBean-接口"><a href="#1-FactoryBean-接口" class="headerlink" title="1. FactoryBean 接口"></a>1. FactoryBean 接口</h3><ol>
<li><p>实现 FactoryBean 接口的三个方法：getObject()，书写创建复杂对象的代码并返回复杂对象、getObjectType()，返回创建的复杂对象的 Class 对象、isSinglrton()，return true 只创建一个复杂对象，return false 每一次调用，都生成一个复杂对象。</p>
</li>
<li><p>Spring 配置文件的配置</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 虽然配置是和简单对象是一样的，但是通过 id 获取的是这个类创建的复杂对象 Connection --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;conn&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xxx.ConnectionFactoryBean&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果想要获取 ConnectionFactoryBean 对象，需要 getBean(“&amp;conn”)，就是在 id 的前面加上 <code>&amp;</code>。</p>
<h3 id="2-实例工厂"><a href="#2-实例工厂" class="headerlink" title="2. 实例工厂"></a>2. 实例工厂</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 先声明实例对象，再引用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beann</span> <span class="attr">id</span>=<span class="string">&quot;connFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xxx.ConnectionFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;conn&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;connFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getConnection&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-静态工厂"><a href="#3-静态工厂" class="headerlink" title="3. 静态工厂"></a>3. 静态工厂</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 直接使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;conn&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xxx.xxxFactoryBean&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getConnection&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="七、如何控制Spring工厂创建对象的次数"><a href="#七、如何控制Spring工厂创建对象的次数" class="headerlink" title="七、如何控制Spring工厂创建对象的次数"></a>七、如何控制Spring工厂创建对象的次数</h2><p>Q：为什么要控制对象的创建次数?<br>A：节省不必要的内存浪费。</p>
<ul>
<li><p>什么样的对象只创建一次？</p>
<ul>
<li>SqlSessionFactory</li>
<li>DAO</li>
<li>Service</li>
</ul>
</li>
<li><p>什么样的对象每一次都要创建</p>
<ul>
<li>Connection</li>
<li>SqlSession | Session</li>
<li>Controller | Struts2 Action</li>
</ul>
</li>
</ul>
<p>总之一句话：如果可以共用，并且是线程安全的，可以只创建一次。</p>
<h3 id="1-控制简单对象的创建次数"><a href="#1-控制简单对象的创建次数" class="headerlink" title="1. 控制简单对象的创建次数"></a>1. 控制简单对象的创建次数</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton|prototype&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>singleton: 只会创建一次；<br>prototype: 每一次都会创建新的对象。<br>默认值 singleton。</p>
<h3 id="2-控制复杂对象的创建次数"><a href="#2-控制复杂对象的创建次数" class="headerlink" title="2. 控制复杂对象的创建次数"></a>2. 控制复杂对象的创建次数</h3><p>实现 FactoryBean 的接口的复杂对象：<br>isSingleton() {<br>  return true;只会创建一次<br>  return false;每一次都会创建新的<br>}<br>如果没有 isSingleton() 方法，还是配置 scope 属性。</p>
<h2 id="八、对象的生命周期"><a href="#八、对象的生命周期" class="headerlink" title="八、对象的生命周期"></a>八、对象的生命周期</h2><h3 id="1-创建阶段"><a href="#1-创建阶段" class="headerlink" title="1. 创建阶段"></a>1. 创建阶段</h3><p><code>scope=&quot;singleton&quot;</code>: Spring 工厂创建的同时（new ClassPathXmlApplicationContext()），对象被创建。<br>如果想要在 <strong>singleton</strong> 的情况下，使用 <code>getBean()</code> 时才能创建对象，可以加入 <strong>lazy-init</strong> 属性，<code>lazy-init=&quot;true&quot;</code></p>
<p><code>scope=&quot;prototype&quot;</code>: 在调用 getBean() 的时候创建对象。</p>
<h3 id="2-初始化阶段"><a href="#2-初始化阶段" class="headerlink" title="2. 初始化阶段"></a>2. 初始化阶段</h3><p>Spring 工厂在创建完对象后，调用对象的初始化方法，完成对应的初始化操作。</p>
<ol>
<li>初始化方法的提供：程序员根据需求，提供初始化方法，最终完成初始化操作。</li>
<li>初始化调用：Spring 工厂调用。</li>
</ol>
<p>初始化实现方式：</p>
<ol>
<li>实现 InitializingBean 接口，重写 afterPropertiesSet() 方法。</li>
<li>对象中提供一个普通的方法<br>  在配置文件中添加 init-method 属性，值为我们定义的普通的方法名称，注意不需要 <code>()</code>。</li>
</ol>
<p><strong>Q:</strong> 如果一个对象实现了 InitializingBean 接口，也提供了普通的方法，那么执行的顺序是什么样子的呢？<br><strong>A:</strong> 先执行 InitializingBean，再执行普通方法。</p>
<h3 id="3-销毁阶段"><a href="#3-销毁阶段" class="headerlink" title="3. 销毁阶段"></a>3. 销毁阶段</h3><p>Spring 销毁对象前，会调用对象的销毁方法，完成销毁。销毁方法的操作只适用于 <code>scope=&quot;singleton&quot;</code> 的对象。销毁操作主要指资源的释放操作。例如 io，connection 等的关闭。</p>
<p>销毁方法：程序员根据自己的需求，定义销毁方法。<br>调用：Spring 工厂完成调用</p>
<p>实现方式：</p>
<ul>
<li>实现 DisposableBean 接口，重写 destroy() 方法；</li>
<li>自定义销毁方法，在配置文件的 destroy-method 属性中写自定义的方法名。</li>
</ul>
<p><strong>Q:</strong> Spring 什么时候销毁对象？<br><strong>A:</strong> ctx.close();</p>
<p><strong>Q:</strong> 如果一个对象实现了 DisposableBean 接口，也提供了普通的销毁方法，那么执行的顺序是什么样子的呢？<br><strong>A:</strong> 执行顺序：先执行 DisposableBean 接口的实现方法，再执行普通方法。</p>
<h2 id="九、配置文件参数化"><a href="#九、配置文件参数化" class="headerlink" title="九、配置文件参数化"></a>九、配置文件参数化</h2><p>把Spring配置文件中需要经常修改的字符串信息，转移到一个更小的配置文件中。例如，数据库的连接可能在后期维护中会更换账户和密码，这时就可以把这些内容放到另一个文件中，这个文件专门存储变化的数据。</p>
<ul>
<li>提供一个小的配置文件（.properties 文件），名字、位置任意。</li>
<li>Spring 的配置文件和小配置文件整合。</li>
</ul>
<p><code>db.properties</code> 文件：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.driverClassName</span> = <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span> = <span class="string">jdbc:mysql://localhost:3306/jhlz?useSSL=false</span></span><br><span class="line"><span class="attr">jdbc.username</span> = <span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span> = <span class="string">root</span></span><br></pre></td></tr></table></figure>

<p><code>spring-config.xml</code> 文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置小文件的路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:/db.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;conn&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xxx.ConnectionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClassName&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="十、类型转换器"><a href="#十、类型转换器" class="headerlink" title="十、类型转换器"></a>十、类型转换器</h2><h3 id="1-自定义类型转换器实现"><a href="#1-自定义类型转换器实现" class="headerlink" title="1. 自定义类型转换器实现"></a>1. 自定义类型转换器实现</h3><ol>
<li>实现 Converter 接口，定义转换的类型与实现。</li>
<li>配置文件注册配置</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 创建自定义转换对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myDateConverter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xxx.MyDateConverter&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注册类型转换器 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 目的：告诉 Spring 框架，开发的是一个类型转换器。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;conversionService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;converters&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;myDateConverter&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span>&gt;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注册 ConversionServiceFactoryBean 时的 id 必须为 conversionService，大小写也需要一样。<br>Spring 框架其实内置了日期类型的转换器，但只是针对 <code>2021/12/12</code> 这种格式，至于其它格式依然需要程序员手动实现。</p>
</blockquote>
<h2 id="十一、后置处理Bean"><a href="#十一、后置处理Bean" class="headerlink" title="十一、后置处理Bean"></a>十一、后置处理Bean</h2><p>BeanPostProcess 作用： 对 Spring 工厂所创建的对象，进行再加工。</p>
<p>实现 BeanPostProcessor 接口，重写其中的方法。最好是在 after 的方法中写需要的逻辑。</p>
<blockquote>
<p>BeanPostProcessor 会对 Spring 工厂创建的所有对象都生效。</p>
</blockquote>
<h2 id="十二、静态、动态代理的概念"><a href="#十二、静态、动态代理的概念" class="headerlink" title="十二、静态、动态代理的概念"></a>十二、静态、动态代理的概念</h2><p>代理设计模式的作用就是额外功能的增强，可以通过动态字节码技术创建 包括JDK CGLIB ASM Javasist（MyBatis也支持）<br>装饰器设计模式：本职功能的增强</p>
<h3 id="1-静态代理"><a href="#1-静态代理" class="headerlink" title="1. 静态代理"></a>1. 静态代理</h3><p>静态代理：为每一个原始类，手工编写一个代理类（有 <code>.java</code> 和 <code>.class</code> 文件）</p>
<p>由此我们可以知道静态代理存在的问题：</p>
<ol>
<li>静态文件数量过多，不利于项目管理；</li>
<li>额外功能的维护性差（代理类中，额外功能修改复杂）。</li>
</ol>
<h3 id="2-动态代理"><a href="#2-动态代理" class="headerlink" title="2. 动态代理"></a>2. 动态代理</h3><ol>
<li>JDK 动态代理 <code>Proxy.newProxyInstance()</code> 通过接口创建代理的实现类。</li>
<li>CGlib 动态代理 Enhancer 通过继承父类创建的代理类。</li>
</ol>
<h2 id="十三、Spring-AOP（Aspect-Oriented-Programing）-编程"><a href="#十三、Spring-AOP（Aspect-Oriented-Programing）-编程" class="headerlink" title="十三、Spring AOP（Aspect Oriented Programing） 编程"></a>十三、Spring AOP（Aspect Oriented Programing） 编程</h2><p>概念：基于 Spring 的动态代理开发，通过代理类为原始类增加额外功能。<br>好处：利于原始类的维护。<br>本质：JDK 动态代理。</p>
<p>思考：</p>
<ol>
<li>AOP 如何创建动态代理类？（动态字节码技术）</li>
<li>Spring 的工厂是如何加工创建代理对象？（通过原始对象的id值，获得代理对象）（BeanPostProcessor）</li>
</ol>
<p>SpringBoot中修改创建代理的方式，添加 <code>@EnableApsectJAutoProxy</code>，覆盖SpringBoot的内置设置。</p>
<p>Spring AOP： 默认使用 JDK 代理<br>SpringBoot AOP： 默认使用 CGlib 代理</p>
<h3 id="1-开发步骤"><a href="#1-开发步骤" class="headerlink" title="1. 开发步骤"></a>1. 开发步骤</h3><ol>
<li>原始对象</li>
<li>额外功能（MethodInterCeptor）</li>
<li>切入点</li>
<li>组装切面（额外功能 + 切入点）</li>
</ol>
<h3 id="2-AOP的底层实现原理"><a href="#2-AOP的底层实现原理" class="headerlink" title="2. AOP的底层实现原理"></a>2. AOP的底层实现原理</h3><h4 id="2-1-JDK动态代理"><a href="#2-1-JDK动态代理" class="headerlink" title="2.1 JDK动态代理"></a>2.1 JDK动态代理</h4><ol>
<li><p>类加载器的作用<br>通过了类加载器把对应类的字节码文件加载到JVM<br>通过类加载器创建类的 Class 对象，进而创建这个类的对象。</p>
</li>
<li><p>如何获得类加载器？<br>每一个类的 <code>.class</code> 文件自动分配与之对应的 ClassLoader.</p>
</li>
<li><p>动态代理创建的过程中，需要 ClassLoader 创建代理类的 Class 对象，可是因为动态代理类没有对应的 <code>.class</code> 文件，JVM 也就不会为其分配 ClassLoader，如何创建？<br>借用一个 ClassLoader，任意的 ClassLoader 都可以。</p>
</li>
</ol>
<h4 id="2-2-CGlib-动态代理"><a href="#2-2-CGlib-动态代理" class="headerlink" title="2.2 CGlib 动态代理"></a>2.2 CGlib 动态代理</h4><p>CGlib创建动态代理的原理：父子继承关系创建代理对象，原始类作为父类，代理类作为子类，这样既可以保证两者方法一致，同时在代理类中提供新的实现（额外功能+原始方法）。</p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://fastly.jsdelivr.net/gh/prettywinter/dist/images/doc/CGlib创建代理对象.png" fancybox="true"/></div></div>

<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://fastly.jsdelivr.net/gh/prettywinter/dist/images/doc/CGlib代理.png" fancybox="true"/></div></div>

<h3 id="3-基于注解的AOP开发"><a href="#3-基于注解的AOP开发" class="headerlink" title="3. 基于注解的AOP开发"></a>3. 基于注解的AOP开发</h3><p>Spring 配置文件加入：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 告知Spring是基于注解的AOP --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspect-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>在默认情况下：AOP 编程底层使用 JDK 动态代理创建代理对象。那么如何切换到 CGlib 动态代理呢？有两种方式，一种是针对 <strong>注解式</strong> 开发，另一种是针对 <strong>传统</strong> 开发。</p>
<ol>
<li><p>注解式 AOP 开发：修改 Spring 的配置文件，在开启动态代理的标签中添加属性 <code>proxy-target-class=&quot;true&quot;</code></p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 告知Spring是基于注解的AOP --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspect-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>传统 AOP 开发切换到 CGlib 配置</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pc&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* login(..)) or execution(* register(..))&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;arround&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pc&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>编写一个 Aop 配置类：导入 aop 依赖；在 Aop 配置类上加上 @Aspect、@Configuration 注解；编写切面增强方法。</p>
<ol>
<li>切入点表达式<ul>
<li>方法级别的切入点表达式：<code>execution(* com.XXX.*.*(..))</code>，第一个 * 号代表可以返回任意类型值。</li>
<li>类级别的切入点表达式：<code>within(com.XXX.*)</code></li>
<li>自定义注解表达式：<code>@annotation(com.XXX)</code></li>
</ul>
</li>
<li>增强方式<ul>
<li>前置增强 (@Befor)、后置增强(@After)、环绕增强 (@Arround)、后置返回增强 (@AfterReturning)、异常增强 (@AfterThrowing)</li>
<li>前置和后置都没有返回值，方法参数都是 JointPoint</li>
<li>环绕增强中，需要调用 <code>proceed()</code> 才能继续处理业务逻辑(类似拦截器)，该方法返回值为业务的返回值，因此环绕增强的返回类型比较推荐设置为 Object。</li>
<li>环绕增强的方法参数是 ProceedingJointPoint</li>
</ul>
</li>
</ol>
<h3 id="4-AOP开发过程中的坑"><a href="#4-AOP开发过程中的坑" class="headerlink" title="4. AOP开发过程中的坑"></a>4. AOP开发过程中的坑</h3><p>在同一个的业务类中，进行业务方法间的相互调用，只有最外层方法才加入了额外功能，内部的方法通过普通的方式调用，调用的都是原始方法。如果想让内层的方法也通过代理对象调用，必须实现 ApplicationContextAware 接口获得工厂，进而获得代理对象。</p>
<h3 id="5-AOP总结"><a href="#5-AOP总结" class="headerlink" title="5. AOP总结"></a>5. AOP总结</h3><div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://fastly.jsdelivr.net/gh/prettywinter/dist/images/doc/AOP总结.png" fancybox="true"/></div></div>

<h2 id="十四、拦截器、过滤器"><a href="#十四、拦截器、过滤器" class="headerlink" title="十四、拦截器、过滤器"></a>十四、拦截器、过滤器</h2><h3 id="1-拦截器"><a href="#1-拦截器" class="headerlink" title="1. 拦截器"></a>1. 拦截器</h3><ol>
<li>实现 HandlerInterceptor 接口；</li>
<li>重写 preHandle、postHandle、afterCompletion 方法，其中 preHandle 方法中返回 true 代表放行，返回 false 代表中断。</li>
</ol>
<p>preHandle 返回值为 true 时，执行控制器中的方法，当控制器方法执行完成后会返回拦截器中执行拦截器中的 postHandle 方法，postHandle 执行完成之后响应请求。在响应请求完成后会执行 afterCompletion 方法，该方法无论执行 <strong>成功</strong> 或者 <strong>失败</strong> 都会执行。</p>
<pre><code><figure class="highlight java"><figcaption><span>CustomerInterceptor.class</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 先执行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> HandlerInterceptor.<span class="built_in">super</span>.preHandle(request, response, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 上面结果为 true 时执行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        HandlerInterceptor.<span class="built_in">super</span>.postHandle(request, response, handler, modelAndView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 最后都会执行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        HandlerInterceptor.<span class="built_in">super</span>.afterCompletion(request, response, handler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<ol start="3">
<li><p>配置拦截器：实现 WebMvcConfigurer 接口；重写 addInterceptors 方法，添加编写的拦截器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">         registry.addInterceptor(customerInterceptor());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>拦截器只能拦截 controller 相关请求，不能拦截 jsp 静态资源文件；<br>拦截器可以中断请求轨迹；<br>请求之前如果该请求配置了拦截器，请求会先经过拦截器，放行之后执行请求的 controller，controller 执行完成后会回到拦截器继续执行拦截器代码。<br>如果配置了多个拦截器，默认执行的顺序和栈结构是一样的；但是也可以通过 <code>order()</code> 方法修改，里面填 int 类型的数字，数字大的优先执行。</p>
</blockquote>
<h3 id="2-过滤器"><a href="#2-过滤器" class="headerlink" title="2. 过滤器"></a>2. 过滤器</h3><p>关于过滤器，它和拦截器比较像，编写方式也非常简单，实现 Filter 接口即可。但是要清楚：过滤器是 Java 提供的，拦截器是 Spring 提供的。下面的内容引用 Spring 的原文：</p>
<blockquote>
<p>HandlerInterceptor is basically similar to a Servlet Filter, but in contrast to the latter it just allows custom pre-processing with the option of prohibiting the execution of the handler itself, and custom post-processing. Filters are more powerful, for example they allow for exchanging the request and response objects that are handed down the chain. Note that a filter gets configured in web.xml, a HandlerInterceptor in the application context.</p>
<p>汉译一下：HandlerInterceptor基本上类似于Servlet Filter，但与后者不同的是，它只允许自定义预处理(带有禁止执行处理程序本身的选项)和自定义后处理。过滤器更强大，例如，它们允许交换沿链传递的请求和响应对象。注意，过滤器是在web.xml中配置的，HandlerInterceptor是在应用程序上下文中配置的。</p>
</blockquote>
<h2 id="十五、Spring的事务管理"><a href="#十五、Spring的事务管理" class="headerlink" title="十五、Spring的事务管理"></a>十五、Spring的事务管理</h2><p>Spring 管理事物的方式：</p>
<ul>
<li>编程式事务，在代码中硬编码。(不推荐使用)</li>
<li>声明式事务，在配置文件中配置(推荐使用)<ol>
<li>基于XML的声明式事务</li>
<li>基于注解的声明式事务</li>
</ol>
</li>
</ul>
<h3 id="1-事务并发产生的问题"><a href="#1-事务并发产生的问题" class="headerlink" title="1. 事务并发产生的问题"></a>1. 事务并发产生的问题</h3><h4 id="1-1-脏读"><a href="#1-1-脏读" class="headerlink" title="1.1 脏读"></a>1.1 脏读</h4><p>一个事务读取了另外一个事务没有提交的数据。<br>解决方案：@Transactional(isolation&#x3D;Isolation.READ_COMMITTED)</p>
<h4 id="1-2-不可重复读"><a href="#1-2-不可重复读" class="headerlink" title="1.2 不可重复读"></a>1.2 不可重复读</h4><p>在同一个事务中，多次查询同一条数据，但是读取的结果不同。<br>解决方案：@Transactional(isolation&#x3D;Isolation.REPEATABLE_READ)<br>本质：一把行锁</p>
<h4 id="1-3-幻影读"><a href="#1-3-幻影读" class="headerlink" title="1.3 幻影读"></a>1.3 幻影读</h4><p>在一个事务中，对整表数据查询，显示的结果不一样。注意：是整表。会在本事务中出现数据不一致。<br>解决方案：@Transactional(isolation&#x3D;Isolation.SERIALIZABLE)<br>本质：表级锁。</p>
<p>隔离属性在实战中的建议：推荐使用 Spring 指定的 ISOLATION_DEFAULT</p>
<ol>
<li>MySQL repeatable_read</li>
<li>Oracle read_commited</li>
</ol>
<blockquote>
<p>在真正的项目中，并发访问情况是很低的。如果真的遇到并发问题，那么可以使用乐观锁解决，基于系统层面的，不会对系统的性能有太大的影响。<br>比如：Hibernate（JPA） Version、MyBatis 通过拦截器自定义开发。</p>
</blockquote>
<h3 id="2-传播属性"><a href="#2-传播属性" class="headerlink" title="2. 传播属性"></a>2. 传播属性</h3><p>概念：它描述了事务解决嵌套问题的特征。<br>什么是事务的嵌套：它指的是一个大的事务中，包含了若干个小的事务。<br>问题：大事务中融入了很多小的事务，它们彼此影响，最终就会导致外部大的事务失败，丧失了事务的原子性。</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>外部不存在事务</th>
<th>外部存在事务</th>
<th>用法</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>REQUIRED</td>
<td>开启事务</td>
<td>融合到外部事务中</td>
<td>@Transactional(Propagation.REQUIRED)</td>
<td>增删改</td>
</tr>
<tr>
<td>SUPPORTS</td>
<td>不开启事务</td>
<td>融合到外部事务中</td>
<td>@Transactional(Propagation.SUPPORTS)</td>
<td>查询</td>
</tr>
<tr>
<td>REQUIRES_NEW</td>
<td>开启新的事务</td>
<td>挂起外部事务，开启新的事务</td>
<td>@Transactional(propagation.REQUIRES_NEW)</td>
<td>日志记录</td>
</tr>
<tr>
<td>NOT_SUPPORTED</td>
<td>不开启事务</td>
<td>挂起外部事务</td>
<td>@Transactional(Propagation.NOT_SUPPORTED)</td>
<td>极其不常用</td>
</tr>
<tr>
<td>NEVER</td>
<td>不开启事务</td>
<td>抛出异常</td>
<td>@Transactional(Propagation.NEVER)</td>
<td>极其不常用</td>
</tr>
<tr>
<td>MANDATORY</td>
<td>抛出异常</td>
<td>融合到外部事务</td>
<td>@Transactional(Propagation.MANDATORY)</td>
<td>极其不常用</td>
</tr>
</tbody></table>
<h4 id="2-1-只读属性-readOnly"><a href="#2-1-只读属性-readOnly" class="headerlink" title="2.1 只读属性(readOnly)"></a>2.1 只读属性(readOnly)</h4><p>默认为 false，不开启。针对只查询的操作，可以设为 true 开启可以提高系统的运行效率。</p>
<h4 id="2-2-超时属性-timeout"><a href="#2-2-超时属性-timeout" class="headerlink" title="2.2 超时属性(timeout)"></a>2.2 超时属性(timeout)</h4><p>timeout 以秒为单位，默认值为 -1，最终由对应的数据库来指定。</p>
<h4 id="2-3-异常属性-rollbackFor"><a href="#2-3-异常属性-rollbackFor" class="headerlink" title="2.3 异常属性(rollbackFor)"></a>2.3 异常属性(rollbackFor)</h4><p>Spring 的事务处理过程中，默认对于 RuntimeException 及其子类，采用的回滚的策略；<br>对于 Exception 及其子类，采用的是提交的策略。</p>
<p>手动指定：<br>rollbackFor &#x3D; Exception.class<br>noRollbackFor &#x3D; RuntimeException.class</p>
<blockquote>
<p>建议在实战中使用 RuntimeException 及其子类，使用事务异常属性的默认值。</p>
</blockquote>
<h4 id="2-4-事务属性常见配置总结"><a href="#2-4-事务属性常见配置总结" class="headerlink" title="2.4 事务属性常见配置总结"></a>2.4 事务属性常见配置总结</h4><ol>
<li>隔离属性   默认值</li>
<li>传播属性   Required（默认值）  增删改  Supports 查询操作</li>
<li>只读属性   readOnly false  增删改  true  查询操作</li>
<li>超时属性   默认值 -1</li>
<li>异常属性   默认值</li>
</ol>
<p>增删改操作  @Transaction<br>查询操作  @Transaction(propagation&#x3D;Propagation.SUPPORTS, readOnly&#x3D;true)</p>
<h2 id="十六、Spring-MVC"><a href="#十六、Spring-MVC" class="headerlink" title="十六、Spring MVC"></a>十六、Spring MVC</h2><h3 id="1-为什么要整合MVC框架"><a href="#1-为什么要整合MVC框架" class="headerlink" title="1. 为什么要整合MVC框架"></a>1. 为什么要整合MVC框架</h3><ol>
<li>MVC 框架提供了控制器调用 Service 请求响应的处理，</li>
<li>接收请求参数 request.getParameter()</li>
<li>控制程序的运行流程</li>
<li>视图解析（jsp JSON Freemarker Thyemeleaf）</li>
</ol>
<h3 id="2-Spring-可以整合那些-MVC-框架"><a href="#2-Spring-可以整合那些-MVC-框架" class="headerlink" title="2. Spring 可以整合那些 MVC 框架"></a>2. Spring 可以整合那些 MVC 框架</h3><ol>
<li>struts 1</li>
<li>webwork</li>
<li>jsf</li>
<li>struts 2</li>
<li>springMVC</li>
</ol>
<h3 id="3-Spring整合MVC框架的核心思路"><a href="#3-Spring整合MVC框架的核心思路" class="headerlink" title="3. Spring整合MVC框架的核心思路"></a>3. Spring整合MVC框架的核心思路</h3><h4 id="3-1-准备工厂"><a href="#3-1-准备工厂" class="headerlink" title="3.1 准备工厂"></a>3.1 准备工厂</h4><ol>
<li><p>Web 开发过程中如何创建工厂<br><code>ApplicationContext ctx = new new WebXmlApplicationContext(&quot;/applicationContext.xml&quot;);</code></p>
</li>
<li><p>如何保证工厂唯一同时被共用<br>工厂存储在 ServletContext 这个作用域中 ServletContext.setAttribute(“xxxx”, ctx);</p>
</li>
</ol>
<p>唯一：<br>WebXmlApplicationContext</p>
<p>@Configuration的使用：<br>使用这个注解可以让 Spring 工厂创建 bean，可以不用在 applicationContext.xml 中编写 bean 标签。</p>
<p>创建工厂的代码改变了，需要使用 AnnotationConfigApplicationContext。指定配置 bean 的 Class。<br><code>ApplicationContext ctx = new AnnotationConfigApplicationContext(xxxConfig.class);</code><br>指定配置 bean 所在的路径。<br><code>ApplicationContext ctx = new AnnotationConfigApplicationContext(&quot;com.config&quot;);</code></p>
<h3 id="4-Spring工厂创建对象的优先级"><a href="#4-Spring工厂创建对象的优先级" class="headerlink" title="4. Spring工厂创建对象的优先级"></a>4. Spring工厂创建对象的优先级</h3><p>bean 标签 &gt; @Bean &gt; @Component 及其衍生注解。</p>
<ul>
<li>Spring 读取Properties文件：<br>PropertiesPlaceholderConfigurer</li>
<li>读取yml文件转换为Proterties：YamlPropertiesFactoryBean#setResources()YamlPropertiesFactoryBean#getObject()</li>
</ul>
<p>Spring与YML集成依赖（最低所需版本：1.18）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.yaml<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>snakeyaml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.30<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

  
  


  </article>
  
<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">Prev</div><a href="/wiki/Java/SpringFramework/Spring%E6%B3%A8%E8%A7%A3">注解</a></div><div class="item" id="next"><div class="note">Next</div><a href="/wiki/Java/SpringFramework/SpringBoot">SpringBoot</a></div></section></div>

  

  <div class='related-wrap md-text reveal' id="comments">
    <section class='header cmt-title cap theme'>
      Join the discussion
    </section>
    <section class='body cmt-body giscus'>
      

<svg class="loading" style="vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg>

<div id="giscus" data-repo="prettywinter/dist" data-repo-id="R_kgDOJcVqNA" data-category="Announcements" data-category-id="DIC_kwDOJcVqNM4CWHBg" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous"></div>

    </section>
  </div>




      
<footer class="page-footer reveal fs12"><hr><div class="text"><p>本站由 <a href="/">@prettywinter</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar">Stellar</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = stellar.config.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.19.0';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.19.0';
  stellar.config = {
    date_suffix: {
      just: 'Just',
      min: 'minutes ago',
      hour: 'hours ago',
      day: 'days ago',
      month: 'months ago',
    },
    root : '/',
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.css","js":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.copycode = Object.assign({"enable":true,"js":"/js/plugins/copycode.js","default_text":"Copy","success_text":"Copied"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->

  <script>
  function loadJS() {
    const els = document.querySelectorAll("#comments #giscus");
    if (els.length === 0) return;
    els.forEach((el, i) => {
      try {
        el.innerHTML = '';
      } catch (error) {
        console.log(error);
      }
      var script = document.createElement('script');
      script.src = 'https://giscus.app/client.js';
      script.async = true;
      for (let key of Object.keys(el.attributes)) {
        let attr = el.attributes[key];
        if (['class', 'id'].includes(attr.name) === false) {
          script.setAttribute(attr.name, attr.value);
        }
      }
      el.appendChild(script);
    });
  }
  window.addEventListener('DOMContentLoaded', (event) => {
    loadJS();
  });
</script>




<!-- inject -->


  </div>
</body>
</html>
